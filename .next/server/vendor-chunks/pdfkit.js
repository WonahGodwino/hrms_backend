"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfkit";
exports.ids = ["vendor-chunks/pdfkit"];
exports.modules = {

/***/ "(rsc)/./node_modules/pdfkit/js/pdfkit.es5.js":
/*!**********************************************!*\
  !*** ./node_modules/pdfkit/js/pdfkit.es5.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zlib */ \"zlib\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zlib__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto-js */ \"(rsc)/./node_modules/crypto-js/index.js\");\n/* harmony import */ var crypto_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var fontkit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fontkit */ \"(rsc)/./node_modules/fontkit/dist/module.mjs\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var linebreak__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! linebreak */ \"(rsc)/./node_modules/linebreak/dist/module.mjs\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! png-js */ \"(rsc)/./node_modules/png-js/png-node.js\");\n/* harmony import */ var png_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(png_js__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/*\r\nPDFAbstractReference - abstract class for PDF reference\r\n*/\nvar PDFAbstractReference = /*#__PURE__*/function () {\n  function PDFAbstractReference() {\n    _classCallCheck(this, PDFAbstractReference);\n  }\n\n  _createClass(PDFAbstractReference, [{\n    key: \"toString\",\n    value: function toString() {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }]);\n\n  return PDFAbstractReference;\n}();\n\nvar PDFTree = /*#__PURE__*/function () {\n  function PDFTree() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PDFTree);\n\n    this._items = {}; // disable /Limits output for this tree\n\n    this.limits = typeof options.limits === 'boolean' ? options.limits : true;\n  }\n\n  _createClass(PDFTree, [{\n    key: \"add\",\n    value: function add(key, val) {\n      return this._items[key] = val;\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      return this._items[key];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var _this = this;\n\n      // Needs to be sorted by key\n      var sortedKeys = Object.keys(this._items).sort(function (a, b) {\n        return _this._compareKeys(a, b);\n      });\n      var out = ['<<'];\n\n      if (this.limits && sortedKeys.length > 1) {\n        var first = sortedKeys[0],\n            last = sortedKeys[sortedKeys.length - 1];\n        out.push(\"  /Limits \".concat(PDFObject.convert([this._dataForKey(first), this._dataForKey(last)])));\n      }\n\n      out.push(\"  /\".concat(this._keysName(), \" [\"));\n\n      var _iterator = _createForOfIteratorHelper(sortedKeys),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var key = _step.value;\n          out.push(\"    \".concat(PDFObject.convert(this._dataForKey(key)), \" \").concat(PDFObject.convert(this._items[key])));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      out.push(']');\n      out.push('>>');\n      return out.join('\\n');\n    }\n  }, {\n    key: \"_compareKeys\",\n    value: function _compareKeys()\n    /*a, b*/\n    {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }, {\n    key: \"_keysName\",\n    value: function _keysName() {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }, {\n    key: \"_dataForKey\",\n    value: function _dataForKey()\n    /*k*/\n    {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }]);\n\n  return PDFTree;\n}();\n\nvar pad = function pad(str, length) {\n  return (Array(length + 1).join('0') + str).slice(-length);\n};\n\nvar escapableRe = /[\\n\\r\\t\\b\\f()\\\\]/g;\nvar escapable = {\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t',\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\\\': '\\\\\\\\',\n  '(': '\\\\(',\n  ')': '\\\\)'\n}; // Convert little endian UTF-16 to big endian\n\nvar swapBytes = function swapBytes(buff) {\n  var l = buff.length;\n\n  if (l & 0x01) {\n    throw new Error('Buffer length must be even');\n  } else {\n    for (var i = 0, end = l - 1; i < end; i += 2) {\n      var a = buff[i];\n      buff[i] = buff[i + 1];\n      buff[i + 1] = a;\n    }\n  }\n\n  return buff;\n};\n\nvar PDFObject = /*#__PURE__*/function () {\n  function PDFObject() {\n    _classCallCheck(this, PDFObject);\n  }\n\n  _createClass(PDFObject, null, [{\n    key: \"convert\",\n    value: function convert(object) {\n      var encryptFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      // String literals are converted to the PDF name type\n      if (typeof object === 'string') {\n        return \"/\".concat(object); // String objects are converted to PDF strings (UTF-16)\n      } else if (object instanceof String) {\n        var string = object; // Detect if this is a unicode string\n\n        var isUnicode = false;\n\n        for (var i = 0, end = string.length; i < end; i++) {\n          if (string.charCodeAt(i) > 0x7f) {\n            isUnicode = true;\n            break;\n          }\n        } // If so, encode it as big endian UTF-16\n\n\n        var stringBuffer;\n\n        if (isUnicode) {\n          stringBuffer = swapBytes(Buffer.from(\"\\uFEFF\".concat(string), 'utf16le'));\n        } else {\n          stringBuffer = Buffer.from(string.valueOf(), 'ascii');\n        } // Encrypt the string when necessary\n\n\n        if (encryptFn) {\n          string = encryptFn(stringBuffer).toString('binary');\n        } else {\n          string = stringBuffer.toString('binary');\n        } // Escape characters as required by the spec\n\n\n        string = string.replace(escapableRe, function (c) {\n          return escapable[c];\n        });\n        return \"(\".concat(string, \")\"); // Buffers are converted to PDF hex strings\n      } else if (Buffer.isBuffer(object)) {\n        return \"<\".concat(object.toString('hex'), \">\");\n      } else if (object instanceof PDFAbstractReference || object instanceof PDFTree) {\n        return object.toString();\n      } else if (object instanceof Date) {\n        var _string = \"D:\".concat(pad(object.getUTCFullYear(), 4)) + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z'; // Encrypt the string when necessary\n\n\n        if (encryptFn) {\n          _string = encryptFn(Buffer.from(_string, 'ascii')).toString('binary'); // Escape characters as required by the spec\n\n          _string = _string.replace(escapableRe, function (c) {\n            return escapable[c];\n          });\n        }\n\n        return \"(\".concat(_string, \")\");\n      } else if (Array.isArray(object)) {\n        var items = object.map(function (e) {\n          return PDFObject.convert(e, encryptFn);\n        }).join(' ');\n        return \"[\".concat(items, \"]\");\n      } else if ({}.toString.call(object) === '[object Object]') {\n        var out = ['<<'];\n\n        for (var key in object) {\n          var val = object[key];\n          out.push(\"/\".concat(key, \" \").concat(PDFObject.convert(val, encryptFn)));\n        }\n\n        out.push('>>');\n        return out.join('\\n');\n      } else if (typeof object === 'number') {\n        return PDFObject.number(object);\n      } else {\n        return \"\".concat(object);\n      }\n    }\n  }, {\n    key: \"number\",\n    value: function number(n) {\n      if (n > -1e21 && n < 1e21) {\n        return Math.round(n * 1e6) / 1e6;\n      }\n\n      throw new Error(\"unsupported number: \".concat(n));\n    }\n  }]);\n\n  return PDFObject;\n}();\n\nvar PDFReference = /*#__PURE__*/function (_PDFAbstractReference) {\n  _inherits(PDFReference, _PDFAbstractReference);\n\n  var _super = _createSuper(PDFReference);\n\n  function PDFReference(document, id) {\n    var _this;\n\n    var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, PDFReference);\n\n    _this = _super.call(this);\n    _this.document = document;\n    _this.id = id;\n    _this.data = data;\n    _this.gen = 0;\n    _this.compress = _this.document.compress && !_this.data.Filter;\n    _this.uncompressedLength = 0;\n    _this.buffer = [];\n    return _this;\n  }\n\n  _createClass(PDFReference, [{\n    key: \"write\",\n    value: function write(chunk) {\n      if (!Buffer.isBuffer(chunk)) {\n        chunk = Buffer.from(chunk + '\\n', 'binary');\n      }\n\n      this.uncompressedLength += chunk.length;\n\n      if (this.data.Length == null) {\n        this.data.Length = 0;\n      }\n\n      this.buffer.push(chunk);\n      this.data.Length += chunk.length;\n\n      if (this.compress) {\n        return this.data.Filter = 'FlateDecode';\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk) {\n      if (chunk) {\n        this.write(chunk);\n      }\n\n      return this.finalize();\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      this.offset = this.document._offset;\n      var encryptFn = this.document._security ? this.document._security.getEncryptFn(this.id, this.gen) : null;\n\n      if (this.buffer.length) {\n        this.buffer = Buffer.concat(this.buffer);\n\n        if (this.compress) {\n          this.buffer = zlib__WEBPACK_IMPORTED_MODULE_2___default().deflateSync(this.buffer);\n        }\n\n        if (encryptFn) {\n          this.buffer = encryptFn(this.buffer);\n        }\n\n        this.data.Length = this.buffer.length;\n      }\n\n      this.document._write(\"\".concat(this.id, \" \").concat(this.gen, \" obj\"));\n\n      this.document._write(PDFObject.convert(this.data, encryptFn));\n\n      if (this.buffer.length) {\n        this.document._write('stream');\n\n        this.document._write(this.buffer);\n\n        this.buffer = []; // free up memory\n\n        this.document._write('\\nendstream');\n      }\n\n      this.document._write('endobj');\n\n      this.document._refEnd(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.id, \" \").concat(this.gen, \" R\");\n    }\n  }]);\n\n  return PDFReference;\n}(PDFAbstractReference);\n\n/*\r\nPDFPage - represents a single page in the PDF document\r\nBy Devon Govett\r\n*/\nvar DEFAULT_MARGINS = {\n  top: 72,\n  left: 72,\n  bottom: 72,\n  right: 72\n};\nvar SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n};\n\nvar PDFPage = /*#__PURE__*/function () {\n  function PDFPage(document) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, PDFPage);\n\n    this.document = document;\n    this.size = options.size || 'letter';\n    this.layout = options.layout || 'portrait'; // process margins\n\n    if (typeof options.margin === 'number') {\n      this.margins = {\n        top: options.margin,\n        left: options.margin,\n        bottom: options.margin,\n        right: options.margin\n      }; // default to 1 inch margins\n    } else {\n      this.margins = options.margins || DEFAULT_MARGINS;\n    } // calculate page dimensions\n\n\n    var dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];\n    this.width = dimensions[this.layout === 'portrait' ? 0 : 1];\n    this.height = dimensions[this.layout === 'portrait' ? 1 : 0];\n    this.content = this.document.ref(); // Initialize the Font, XObject, and ExtGState dictionaries\n\n    this.resources = this.document.ref({\n      ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI']\n    }); // The page dictionary\n\n    this.dictionary = this.document.ref({\n      Type: 'Page',\n      Parent: this.document._root.data.Pages,\n      MediaBox: [0, 0, this.width, this.height],\n      Contents: this.content,\n      Resources: this.resources\n    });\n    this.markings = [];\n  } // Lazily create these objects\n\n\n  _createClass(PDFPage, [{\n    key: \"maxY\",\n    value: function maxY() {\n      return this.height - this.margins.bottom;\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk) {\n      return this.content.write(chunk);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.dictionary.end();\n      this.resources.end();\n      return this.content.end();\n    }\n  }, {\n    key: \"fonts\",\n    get: function get() {\n      var data = this.resources.data;\n      return data.Font != null ? data.Font : data.Font = {};\n    }\n  }, {\n    key: \"xobjects\",\n    get: function get() {\n      var data = this.resources.data;\n      return data.XObject != null ? data.XObject : data.XObject = {};\n    }\n  }, {\n    key: \"ext_gstates\",\n    get: function get() {\n      var data = this.resources.data;\n      return data.ExtGState != null ? data.ExtGState : data.ExtGState = {};\n    }\n  }, {\n    key: \"patterns\",\n    get: function get() {\n      var data = this.resources.data;\n      return data.Pattern != null ? data.Pattern : data.Pattern = {};\n    }\n  }, {\n    key: \"colorSpaces\",\n    get: function get() {\n      var data = this.resources.data;\n      return data.ColorSpace || (data.ColorSpace = {});\n    }\n  }, {\n    key: \"annotations\",\n    get: function get() {\n      var data = this.dictionary.data;\n      return data.Annots != null ? data.Annots : data.Annots = [];\n    }\n  }, {\n    key: \"structParentTreeKey\",\n    get: function get() {\n      var data = this.dictionary.data;\n      return data.StructParents != null ? data.StructParents : data.StructParents = this.document.createStructParentTreeNextKey();\n    }\n  }]);\n\n  return PDFPage;\n}();\n\nvar PDFNameTree = /*#__PURE__*/function (_PDFTree) {\n  _inherits(PDFNameTree, _PDFTree);\n\n  var _super = _createSuper(PDFNameTree);\n\n  function PDFNameTree() {\n    _classCallCheck(this, PDFNameTree);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PDFNameTree, [{\n    key: \"_compareKeys\",\n    value: function _compareKeys(a, b) {\n      return a.localeCompare(b);\n    }\n  }, {\n    key: \"_keysName\",\n    value: function _keysName() {\n      return \"Names\";\n    }\n  }, {\n    key: \"_dataForKey\",\n    value: function _dataForKey(k) {\n      return new String(k);\n    }\n  }]);\n\n  return PDFNameTree;\n}(PDFTree);\n\n/**\r\n * Check if value is in a range group.\r\n * @param {number} value\r\n * @param {number[]} rangeGroup\r\n * @returns {boolean}\r\n */\nfunction inRange(value, rangeGroup) {\n  if (value < rangeGroup[0]) return false;\n  var startRange = 0;\n  var endRange = rangeGroup.length / 2;\n\n  while (startRange <= endRange) {\n    var middleRange = Math.floor((startRange + endRange) / 2); // actual array index\n\n    var arrayIndex = middleRange * 2; // Check if value is in range pointed by actual index\n\n    if (value >= rangeGroup[arrayIndex] && value <= rangeGroup[arrayIndex + 1]) {\n      return true;\n    }\n\n    if (value > rangeGroup[arrayIndex + 1]) {\n      // Search Right Side Of Array\n      startRange = middleRange + 1;\n    } else {\n      // Search Left Side Of Array\n      endRange = middleRange - 1;\n    }\n  }\n\n  return false;\n}\n\n/**\r\n * A.1 Unassigned code points in Unicode 3.2\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-A.1\r\n */\n\nvar unassigned_code_points = [0x0221, 0x0221, 0x0234, 0x024f, 0x02ae, 0x02af, 0x02ef, 0x02ff, 0x0350, 0x035f, 0x0370, 0x0373, 0x0376, 0x0379, 0x037b, 0x037d, 0x037f, 0x0383, 0x038b, 0x038b, 0x038d, 0x038d, 0x03a2, 0x03a2, 0x03cf, 0x03cf, 0x03f7, 0x03ff, 0x0487, 0x0487, 0x04cf, 0x04cf, 0x04f6, 0x04f7, 0x04fa, 0x04ff, 0x0510, 0x0530, 0x0557, 0x0558, 0x0560, 0x0560, 0x0588, 0x0588, 0x058b, 0x0590, 0x05a2, 0x05a2, 0x05ba, 0x05ba, 0x05c5, 0x05cf, 0x05eb, 0x05ef, 0x05f5, 0x060b, 0x060d, 0x061a, 0x061c, 0x061e, 0x0620, 0x0620, 0x063b, 0x063f, 0x0656, 0x065f, 0x06ee, 0x06ef, 0x06ff, 0x06ff, 0x070e, 0x070e, 0x072d, 0x072f, 0x074b, 0x077f, 0x07b2, 0x0900, 0x0904, 0x0904, 0x093a, 0x093b, 0x094e, 0x094f, 0x0955, 0x0957, 0x0971, 0x0980, 0x0984, 0x0984, 0x098d, 0x098e, 0x0991, 0x0992, 0x09a9, 0x09a9, 0x09b1, 0x09b1, 0x09b3, 0x09b5, 0x09ba, 0x09bb, 0x09bd, 0x09bd, 0x09c5, 0x09c6, 0x09c9, 0x09ca, 0x09ce, 0x09d6, 0x09d8, 0x09db, 0x09de, 0x09de, 0x09e4, 0x09e5, 0x09fb, 0x0a01, 0x0a03, 0x0a04, 0x0a0b, 0x0a0e, 0x0a11, 0x0a12, 0x0a29, 0x0a29, 0x0a31, 0x0a31, 0x0a34, 0x0a34, 0x0a37, 0x0a37, 0x0a3a, 0x0a3b, 0x0a3d, 0x0a3d, 0x0a43, 0x0a46, 0x0a49, 0x0a4a, 0x0a4e, 0x0a58, 0x0a5d, 0x0a5d, 0x0a5f, 0x0a65, 0x0a75, 0x0a80, 0x0a84, 0x0a84, 0x0a8c, 0x0a8c, 0x0a8e, 0x0a8e, 0x0a92, 0x0a92, 0x0aa9, 0x0aa9, 0x0ab1, 0x0ab1, 0x0ab4, 0x0ab4, 0x0aba, 0x0abb, 0x0ac6, 0x0ac6, 0x0aca, 0x0aca, 0x0ace, 0x0acf, 0x0ad1, 0x0adf, 0x0ae1, 0x0ae5, 0x0af0, 0x0b00, 0x0b04, 0x0b04, 0x0b0d, 0x0b0e, 0x0b11, 0x0b12, 0x0b29, 0x0b29, 0x0b31, 0x0b31, 0x0b34, 0x0b35, 0x0b3a, 0x0b3b, 0x0b44, 0x0b46, 0x0b49, 0x0b4a, 0x0b4e, 0x0b55, 0x0b58, 0x0b5b, 0x0b5e, 0x0b5e, 0x0b62, 0x0b65, 0x0b71, 0x0b81, 0x0b84, 0x0b84, 0x0b8b, 0x0b8d, 0x0b91, 0x0b91, 0x0b96, 0x0b98, 0x0b9b, 0x0b9b, 0x0b9d, 0x0b9d, 0x0ba0, 0x0ba2, 0x0ba5, 0x0ba7, 0x0bab, 0x0bad, 0x0bb6, 0x0bb6, 0x0bba, 0x0bbd, 0x0bc3, 0x0bc5, 0x0bc9, 0x0bc9, 0x0bce, 0x0bd6, 0x0bd8, 0x0be6, 0x0bf3, 0x0c00, 0x0c04, 0x0c04, 0x0c0d, 0x0c0d, 0x0c11, 0x0c11, 0x0c29, 0x0c29, 0x0c34, 0x0c34, 0x0c3a, 0x0c3d, 0x0c45, 0x0c45, 0x0c49, 0x0c49, 0x0c4e, 0x0c54, 0x0c57, 0x0c5f, 0x0c62, 0x0c65, 0x0c70, 0x0c81, 0x0c84, 0x0c84, 0x0c8d, 0x0c8d, 0x0c91, 0x0c91, 0x0ca9, 0x0ca9, 0x0cb4, 0x0cb4, 0x0cba, 0x0cbd, 0x0cc5, 0x0cc5, 0x0cc9, 0x0cc9, 0x0cce, 0x0cd4, 0x0cd7, 0x0cdd, 0x0cdf, 0x0cdf, 0x0ce2, 0x0ce5, 0x0cf0, 0x0d01, 0x0d04, 0x0d04, 0x0d0d, 0x0d0d, 0x0d11, 0x0d11, 0x0d29, 0x0d29, 0x0d3a, 0x0d3d, 0x0d44, 0x0d45, 0x0d49, 0x0d49, 0x0d4e, 0x0d56, 0x0d58, 0x0d5f, 0x0d62, 0x0d65, 0x0d70, 0x0d81, 0x0d84, 0x0d84, 0x0d97, 0x0d99, 0x0db2, 0x0db2, 0x0dbc, 0x0dbc, 0x0dbe, 0x0dbf, 0x0dc7, 0x0dc9, 0x0dcb, 0x0dce, 0x0dd5, 0x0dd5, 0x0dd7, 0x0dd7, 0x0de0, 0x0df1, 0x0df5, 0x0e00, 0x0e3b, 0x0e3e, 0x0e5c, 0x0e80, 0x0e83, 0x0e83, 0x0e85, 0x0e86, 0x0e89, 0x0e89, 0x0e8b, 0x0e8c, 0x0e8e, 0x0e93, 0x0e98, 0x0e98, 0x0ea0, 0x0ea0, 0x0ea4, 0x0ea4, 0x0ea6, 0x0ea6, 0x0ea8, 0x0ea9, 0x0eac, 0x0eac, 0x0eba, 0x0eba, 0x0ebe, 0x0ebf, 0x0ec5, 0x0ec5, 0x0ec7, 0x0ec7, 0x0ece, 0x0ecf, 0x0eda, 0x0edb, 0x0ede, 0x0eff, 0x0f48, 0x0f48, 0x0f6b, 0x0f70, 0x0f8c, 0x0f8f, 0x0f98, 0x0f98, 0x0fbd, 0x0fbd, 0x0fcd, 0x0fce, 0x0fd0, 0x0fff, 0x1022, 0x1022, 0x1028, 0x1028, 0x102b, 0x102b, 0x1033, 0x1035, 0x103a, 0x103f, 0x105a, 0x109f, 0x10c6, 0x10cf, 0x10f9, 0x10fa, 0x10fc, 0x10ff, 0x115a, 0x115e, 0x11a3, 0x11a7, 0x11fa, 0x11ff, 0x1207, 0x1207, 0x1247, 0x1247, 0x1249, 0x1249, 0x124e, 0x124f, 0x1257, 0x1257, 0x1259, 0x1259, 0x125e, 0x125f, 0x1287, 0x1287, 0x1289, 0x1289, 0x128e, 0x128f, 0x12af, 0x12af, 0x12b1, 0x12b1, 0x12b6, 0x12b7, 0x12bf, 0x12bf, 0x12c1, 0x12c1, 0x12c6, 0x12c7, 0x12cf, 0x12cf, 0x12d7, 0x12d7, 0x12ef, 0x12ef, 0x130f, 0x130f, 0x1311, 0x1311, 0x1316, 0x1317, 0x131f, 0x131f, 0x1347, 0x1347, 0x135b, 0x1360, 0x137d, 0x139f, 0x13f5, 0x1400, 0x1677, 0x167f, 0x169d, 0x169f, 0x16f1, 0x16ff, 0x170d, 0x170d, 0x1715, 0x171f, 0x1737, 0x173f, 0x1754, 0x175f, 0x176d, 0x176d, 0x1771, 0x1771, 0x1774, 0x177f, 0x17dd, 0x17df, 0x17ea, 0x17ff, 0x180f, 0x180f, 0x181a, 0x181f, 0x1878, 0x187f, 0x18aa, 0x1dff, 0x1e9c, 0x1e9f, 0x1efa, 0x1eff, 0x1f16, 0x1f17, 0x1f1e, 0x1f1f, 0x1f46, 0x1f47, 0x1f4e, 0x1f4f, 0x1f58, 0x1f58, 0x1f5a, 0x1f5a, 0x1f5c, 0x1f5c, 0x1f5e, 0x1f5e, 0x1f7e, 0x1f7f, 0x1fb5, 0x1fb5, 0x1fc5, 0x1fc5, 0x1fd4, 0x1fd5, 0x1fdc, 0x1fdc, 0x1ff0, 0x1ff1, 0x1ff5, 0x1ff5, 0x1fff, 0x1fff, 0x2053, 0x2056, 0x2058, 0x205e, 0x2064, 0x2069, 0x2072, 0x2073, 0x208f, 0x209f, 0x20b2, 0x20cf, 0x20eb, 0x20ff, 0x213b, 0x213c, 0x214c, 0x2152, 0x2184, 0x218f, 0x23cf, 0x23ff, 0x2427, 0x243f, 0x244b, 0x245f, 0x24ff, 0x24ff, 0x2614, 0x2615, 0x2618, 0x2618, 0x267e, 0x267f, 0x268a, 0x2700, 0x2705, 0x2705, 0x270a, 0x270b, 0x2728, 0x2728, 0x274c, 0x274c, 0x274e, 0x274e, 0x2753, 0x2755, 0x2757, 0x2757, 0x275f, 0x2760, 0x2795, 0x2797, 0x27b0, 0x27b0, 0x27bf, 0x27cf, 0x27ec, 0x27ef, 0x2b00, 0x2e7f, 0x2e9a, 0x2e9a, 0x2ef4, 0x2eff, 0x2fd6, 0x2fef, 0x2ffc, 0x2fff, 0x3040, 0x3040, 0x3097, 0x3098, 0x3100, 0x3104, 0x312d, 0x3130, 0x318f, 0x318f, 0x31b8, 0x31ef, 0x321d, 0x321f, 0x3244, 0x3250, 0x327c, 0x327e, 0x32cc, 0x32cf, 0x32ff, 0x32ff, 0x3377, 0x337a, 0x33de, 0x33df, 0x33ff, 0x33ff, 0x4db6, 0x4dff, 0x9fa6, 0x9fff, 0xa48d, 0xa48f, 0xa4c7, 0xabff, 0xd7a4, 0xd7ff, 0xfa2e, 0xfa2f, 0xfa6b, 0xfaff, 0xfb07, 0xfb12, 0xfb18, 0xfb1c, 0xfb37, 0xfb37, 0xfb3d, 0xfb3d, 0xfb3f, 0xfb3f, 0xfb42, 0xfb42, 0xfb45, 0xfb45, 0xfbb2, 0xfbd2, 0xfd40, 0xfd4f, 0xfd90, 0xfd91, 0xfdc8, 0xfdcf, 0xfdfd, 0xfdff, 0xfe10, 0xfe1f, 0xfe24, 0xfe2f, 0xfe47, 0xfe48, 0xfe53, 0xfe53, 0xfe67, 0xfe67, 0xfe6c, 0xfe6f, 0xfe75, 0xfe75, 0xfefd, 0xfefe, 0xff00, 0xff00, 0xffbf, 0xffc1, 0xffc8, 0xffc9, 0xffd0, 0xffd1, 0xffd8, 0xffd9, 0xffdd, 0xffdf, 0xffe7, 0xffe7, 0xffef, 0xfff8, 0x10000, 0x102ff, 0x1031f, 0x1031f, 0x10324, 0x1032f, 0x1034b, 0x103ff, 0x10426, 0x10427, 0x1044e, 0x1cfff, 0x1d0f6, 0x1d0ff, 0x1d127, 0x1d129, 0x1d1de, 0x1d3ff, 0x1d455, 0x1d455, 0x1d49d, 0x1d49d, 0x1d4a0, 0x1d4a1, 0x1d4a3, 0x1d4a4, 0x1d4a7, 0x1d4a8, 0x1d4ad, 0x1d4ad, 0x1d4ba, 0x1d4ba, 0x1d4bc, 0x1d4bc, 0x1d4c1, 0x1d4c1, 0x1d4c4, 0x1d4c4, 0x1d506, 0x1d506, 0x1d50b, 0x1d50c, 0x1d515, 0x1d515, 0x1d51d, 0x1d51d, 0x1d53a, 0x1d53a, 0x1d53f, 0x1d53f, 0x1d545, 0x1d545, 0x1d547, 0x1d549, 0x1d551, 0x1d551, 0x1d6a4, 0x1d6a7, 0x1d7ca, 0x1d7cd, 0x1d800, 0x1fffd, 0x2a6d7, 0x2f7ff, 0x2fa1e, 0x2fffd, 0x30000, 0x3fffd, 0x40000, 0x4fffd, 0x50000, 0x5fffd, 0x60000, 0x6fffd, 0x70000, 0x7fffd, 0x80000, 0x8fffd, 0x90000, 0x9fffd, 0xa0000, 0xafffd, 0xb0000, 0xbfffd, 0xc0000, 0xcfffd, 0xd0000, 0xdfffd, 0xe0000, 0xe0000, 0xe0002, 0xe001f, 0xe0080, 0xefffd]; // prettier-ignore-end\n\nvar isUnassignedCodePoint = function isUnassignedCodePoint(character) {\n  return inRange(character, unassigned_code_points);\n}; // prettier-ignore-start\n\n/**\r\n * B.1 Commonly mapped to nothing\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-B.1\r\n */\n\n\nvar commonly_mapped_to_nothing = [0x00ad, 0x00ad, 0x034f, 0x034f, 0x1806, 0x1806, 0x180b, 0x180b, 0x180c, 0x180c, 0x180d, 0x180d, 0x200b, 0x200b, 0x200c, 0x200c, 0x200d, 0x200d, 0x2060, 0x2060, 0xfe00, 0xfe00, 0xfe01, 0xfe01, 0xfe02, 0xfe02, 0xfe03, 0xfe03, 0xfe04, 0xfe04, 0xfe05, 0xfe05, 0xfe06, 0xfe06, 0xfe07, 0xfe07, 0xfe08, 0xfe08, 0xfe09, 0xfe09, 0xfe0a, 0xfe0a, 0xfe0b, 0xfe0b, 0xfe0c, 0xfe0c, 0xfe0d, 0xfe0d, 0xfe0e, 0xfe0e, 0xfe0f, 0xfe0f, 0xfeff, 0xfeff]; // prettier-ignore-end\n\nvar isCommonlyMappedToNothing = function isCommonlyMappedToNothing(character) {\n  return inRange(character, commonly_mapped_to_nothing);\n}; // prettier-ignore-start\n\n/**\r\n * C.1.2 Non-ASCII space characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.1.2\r\n */\n\n\nvar non_ASCII_space_characters = [0x00a0, 0x00a0\n/* NO-BREAK SPACE */\n, 0x1680, 0x1680\n/* OGHAM SPACE MARK */\n, 0x2000, 0x2000\n/* EN QUAD */\n, 0x2001, 0x2001\n/* EM QUAD */\n, 0x2002, 0x2002\n/* EN SPACE */\n, 0x2003, 0x2003\n/* EM SPACE */\n, 0x2004, 0x2004\n/* THREE-PER-EM SPACE */\n, 0x2005, 0x2005\n/* FOUR-PER-EM SPACE */\n, 0x2006, 0x2006\n/* SIX-PER-EM SPACE */\n, 0x2007, 0x2007\n/* FIGURE SPACE */\n, 0x2008, 0x2008\n/* PUNCTUATION SPACE */\n, 0x2009, 0x2009\n/* THIN SPACE */\n, 0x200a, 0x200a\n/* HAIR SPACE */\n, 0x200b, 0x200b\n/* ZERO WIDTH SPACE */\n, 0x202f, 0x202f\n/* NARROW NO-BREAK SPACE */\n, 0x205f, 0x205f\n/* MEDIUM MATHEMATICAL SPACE */\n, 0x3000, 0x3000\n/* IDEOGRAPHIC SPACE */\n]; // prettier-ignore-end\n\nvar isNonASCIISpaceCharacter = function isNonASCIISpaceCharacter(character) {\n  return inRange(character, non_ASCII_space_characters);\n}; // prettier-ignore-start\n\n\nvar non_ASCII_controls_characters = [\n/**\r\n * C.2.2 Non-ASCII control characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.2\r\n */\n0x0080, 0x009f\n/* [CONTROL CHARACTERS] */\n, 0x06dd, 0x06dd\n/* ARABIC END OF AYAH */\n, 0x070f, 0x070f\n/* SYRIAC ABBREVIATION MARK */\n, 0x180e, 0x180e\n/* MONGOLIAN VOWEL SEPARATOR */\n, 0x200c, 0x200c\n/* ZERO WIDTH NON-JOINER */\n, 0x200d, 0x200d\n/* ZERO WIDTH JOINER */\n, 0x2028, 0x2028\n/* LINE SEPARATOR */\n, 0x2029, 0x2029\n/* PARAGRAPH SEPARATOR */\n, 0x2060, 0x2060\n/* WORD JOINER */\n, 0x2061, 0x2061\n/* FUNCTION APPLICATION */\n, 0x2062, 0x2062\n/* INVISIBLE TIMES */\n, 0x2063, 0x2063\n/* INVISIBLE SEPARATOR */\n, 0x206a, 0x206f\n/* [CONTROL CHARACTERS] */\n, 0xfeff, 0xfeff\n/* ZERO WIDTH NO-BREAK SPACE */\n, 0xfff9, 0xfffc\n/* [CONTROL CHARACTERS] */\n, 0x1d173, 0x1d17a\n/* [MUSICAL CONTROL CHARACTERS] */\n];\nvar non_character_codepoints = [\n/**\r\n * C.4 Non-character code points\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.4\r\n */\n0xfdd0, 0xfdef\n/* [NONCHARACTER CODE POINTS] */\n, 0xfffe, 0xffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x1fffe, 0x1ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x2fffe, 0x2ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x3fffe, 0x3ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x4fffe, 0x4ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x5fffe, 0x5ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x6fffe, 0x6ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x7fffe, 0x7ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x8fffe, 0x8ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x9fffe, 0x9ffff\n/* [NONCHARACTER CODE POINTS] */\n, 0xafffe, 0xaffff\n/* [NONCHARACTER CODE POINTS] */\n, 0xbfffe, 0xbffff\n/* [NONCHARACTER CODE POINTS] */\n, 0xcfffe, 0xcffff\n/* [NONCHARACTER CODE POINTS] */\n, 0xdfffe, 0xdffff\n/* [NONCHARACTER CODE POINTS] */\n, 0xefffe, 0xeffff\n/* [NONCHARACTER CODE POINTS] */\n, 0x10fffe, 0x10ffff\n/* [NONCHARACTER CODE POINTS] */\n];\n/**\r\n * 2.3.  Prohibited Output\r\n */\n\nvar prohibited_characters = [\n/**\r\n * C.2.1 ASCII control characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.2.1\r\n */\n0, 0x001f\n/* [CONTROL CHARACTERS] */\n, 0x007f, 0x007f\n/* DELETE */\n,\n/**\r\n * C.8 Change display properties or are deprecated\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.8\r\n */\n0x0340, 0x0340\n/* COMBINING GRAVE TONE MARK */\n, 0x0341, 0x0341\n/* COMBINING ACUTE TONE MARK */\n, 0x200e, 0x200e\n/* LEFT-TO-RIGHT MARK */\n, 0x200f, 0x200f\n/* RIGHT-TO-LEFT MARK */\n, 0x202a, 0x202a\n/* LEFT-TO-RIGHT EMBEDDING */\n, 0x202b, 0x202b\n/* RIGHT-TO-LEFT EMBEDDING */\n, 0x202c, 0x202c\n/* POP DIRECTIONAL FORMATTING */\n, 0x202d, 0x202d\n/* LEFT-TO-RIGHT OVERRIDE */\n, 0x202e, 0x202e\n/* RIGHT-TO-LEFT OVERRIDE */\n, 0x206a, 0x206a\n/* INHIBIT SYMMETRIC SWAPPING */\n, 0x206b, 0x206b\n/* ACTIVATE SYMMETRIC SWAPPING */\n, 0x206c, 0x206c\n/* INHIBIT ARABIC FORM SHAPING */\n, 0x206d, 0x206d\n/* ACTIVATE ARABIC FORM SHAPING */\n, 0x206e, 0x206e\n/* NATIONAL DIGIT SHAPES */\n, 0x206f, 0x206f\n/* NOMINAL DIGIT SHAPES */\n,\n/**\r\n * C.7 Inappropriate for canonical representation\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.7\r\n */\n0x2ff0, 0x2ffb\n/* [IDEOGRAPHIC DESCRIPTION CHARACTERS] */\n,\n/**\r\n * C.5 Surrogate codes\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.5\r\n */\n0xd800, 0xdfff,\n/**\r\n * C.3 Private use\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.3\r\n */\n0xe000, 0xf8ff\n/* [PRIVATE USE, PLANE 0] */\n,\n/**\r\n * C.6 Inappropriate for plain text\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.6\r\n */\n0xfff9, 0xfff9\n/* INTERLINEAR ANNOTATION ANCHOR */\n, 0xfffa, 0xfffa\n/* INTERLINEAR ANNOTATION SEPARATOR */\n, 0xfffb, 0xfffb\n/* INTERLINEAR ANNOTATION TERMINATOR */\n, 0xfffc, 0xfffc\n/* OBJECT REPLACEMENT CHARACTER */\n, 0xfffd, 0xfffd\n/* REPLACEMENT CHARACTER */\n,\n/**\r\n * C.9 Tagging characters\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.9\r\n */\n0xe0001, 0xe0001\n/* LANGUAGE TAG */\n, 0xe0020, 0xe007f\n/* [TAGGING CHARACTERS] */\n,\n/**\r\n * C.3 Private use\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-C.3\r\n */\n0xf0000, 0xffffd\n/* [PRIVATE USE, PLANE 15] */\n, 0x100000, 0x10fffd\n/* [PRIVATE USE, PLANE 16] */\n]; // prettier-ignore-end\n\nvar isProhibitedCharacter = function isProhibitedCharacter(character) {\n  return inRange(character, non_ASCII_space_characters) || inRange(character, prohibited_characters) || inRange(character, non_ASCII_controls_characters) || inRange(character, non_character_codepoints);\n}; // prettier-ignore-start\n\n/**\r\n * D.1 Characters with bidirectional property \"R\" or \"AL\"\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-D.1\r\n */\n\n\nvar bidirectional_r_al = [0x05be, 0x05be, 0x05c0, 0x05c0, 0x05c3, 0x05c3, 0x05d0, 0x05ea, 0x05f0, 0x05f4, 0x061b, 0x061b, 0x061f, 0x061f, 0x0621, 0x063a, 0x0640, 0x064a, 0x066d, 0x066f, 0x0671, 0x06d5, 0x06dd, 0x06dd, 0x06e5, 0x06e6, 0x06fa, 0x06fe, 0x0700, 0x070d, 0x0710, 0x0710, 0x0712, 0x072c, 0x0780, 0x07a5, 0x07b1, 0x07b1, 0x200f, 0x200f, 0xfb1d, 0xfb1d, 0xfb1f, 0xfb28, 0xfb2a, 0xfb36, 0xfb38, 0xfb3c, 0xfb3e, 0xfb3e, 0xfb40, 0xfb41, 0xfb43, 0xfb44, 0xfb46, 0xfbb1, 0xfbd3, 0xfd3d, 0xfd50, 0xfd8f, 0xfd92, 0xfdc7, 0xfdf0, 0xfdfc, 0xfe70, 0xfe74, 0xfe76, 0xfefc]; // prettier-ignore-end\n\nvar isBidirectionalRAL = function isBidirectionalRAL(character) {\n  return inRange(character, bidirectional_r_al);\n}; // prettier-ignore-start\n\n/**\r\n * D.2 Characters with bidirectional property \"L\"\r\n * @link https://tools.ietf.org/html/rfc3454#appendix-D.2\r\n */\n\n\nvar bidirectional_l = [0x0041, 0x005a, 0x0061, 0x007a, 0x00aa, 0x00aa, 0x00b5, 0x00b5, 0x00ba, 0x00ba, 0x00c0, 0x00d6, 0x00d8, 0x00f6, 0x00f8, 0x0220, 0x0222, 0x0233, 0x0250, 0x02ad, 0x02b0, 0x02b8, 0x02bb, 0x02c1, 0x02d0, 0x02d1, 0x02e0, 0x02e4, 0x02ee, 0x02ee, 0x037a, 0x037a, 0x0386, 0x0386, 0x0388, 0x038a, 0x038c, 0x038c, 0x038e, 0x03a1, 0x03a3, 0x03ce, 0x03d0, 0x03f5, 0x0400, 0x0482, 0x048a, 0x04ce, 0x04d0, 0x04f5, 0x04f8, 0x04f9, 0x0500, 0x050f, 0x0531, 0x0556, 0x0559, 0x055f, 0x0561, 0x0587, 0x0589, 0x0589, 0x0903, 0x0903, 0x0905, 0x0939, 0x093d, 0x0940, 0x0949, 0x094c, 0x0950, 0x0950, 0x0958, 0x0961, 0x0964, 0x0970, 0x0982, 0x0983, 0x0985, 0x098c, 0x098f, 0x0990, 0x0993, 0x09a8, 0x09aa, 0x09b0, 0x09b2, 0x09b2, 0x09b6, 0x09b9, 0x09be, 0x09c0, 0x09c7, 0x09c8, 0x09cb, 0x09cc, 0x09d7, 0x09d7, 0x09dc, 0x09dd, 0x09df, 0x09e1, 0x09e6, 0x09f1, 0x09f4, 0x09fa, 0x0a05, 0x0a0a, 0x0a0f, 0x0a10, 0x0a13, 0x0a28, 0x0a2a, 0x0a30, 0x0a32, 0x0a33, 0x0a35, 0x0a36, 0x0a38, 0x0a39, 0x0a3e, 0x0a40, 0x0a59, 0x0a5c, 0x0a5e, 0x0a5e, 0x0a66, 0x0a6f, 0x0a72, 0x0a74, 0x0a83, 0x0a83, 0x0a85, 0x0a8b, 0x0a8d, 0x0a8d, 0x0a8f, 0x0a91, 0x0a93, 0x0aa8, 0x0aaa, 0x0ab0, 0x0ab2, 0x0ab3, 0x0ab5, 0x0ab9, 0x0abd, 0x0ac0, 0x0ac9, 0x0ac9, 0x0acb, 0x0acc, 0x0ad0, 0x0ad0, 0x0ae0, 0x0ae0, 0x0ae6, 0x0aef, 0x0b02, 0x0b03, 0x0b05, 0x0b0c, 0x0b0f, 0x0b10, 0x0b13, 0x0b28, 0x0b2a, 0x0b30, 0x0b32, 0x0b33, 0x0b36, 0x0b39, 0x0b3d, 0x0b3e, 0x0b40, 0x0b40, 0x0b47, 0x0b48, 0x0b4b, 0x0b4c, 0x0b57, 0x0b57, 0x0b5c, 0x0b5d, 0x0b5f, 0x0b61, 0x0b66, 0x0b70, 0x0b83, 0x0b83, 0x0b85, 0x0b8a, 0x0b8e, 0x0b90, 0x0b92, 0x0b95, 0x0b99, 0x0b9a, 0x0b9c, 0x0b9c, 0x0b9e, 0x0b9f, 0x0ba3, 0x0ba4, 0x0ba8, 0x0baa, 0x0bae, 0x0bb5, 0x0bb7, 0x0bb9, 0x0bbe, 0x0bbf, 0x0bc1, 0x0bc2, 0x0bc6, 0x0bc8, 0x0bca, 0x0bcc, 0x0bd7, 0x0bd7, 0x0be7, 0x0bf2, 0x0c01, 0x0c03, 0x0c05, 0x0c0c, 0x0c0e, 0x0c10, 0x0c12, 0x0c28, 0x0c2a, 0x0c33, 0x0c35, 0x0c39, 0x0c41, 0x0c44, 0x0c60, 0x0c61, 0x0c66, 0x0c6f, 0x0c82, 0x0c83, 0x0c85, 0x0c8c, 0x0c8e, 0x0c90, 0x0c92, 0x0ca8, 0x0caa, 0x0cb3, 0x0cb5, 0x0cb9, 0x0cbe, 0x0cbe, 0x0cc0, 0x0cc4, 0x0cc7, 0x0cc8, 0x0cca, 0x0ccb, 0x0cd5, 0x0cd6, 0x0cde, 0x0cde, 0x0ce0, 0x0ce1, 0x0ce6, 0x0cef, 0x0d02, 0x0d03, 0x0d05, 0x0d0c, 0x0d0e, 0x0d10, 0x0d12, 0x0d28, 0x0d2a, 0x0d39, 0x0d3e, 0x0d40, 0x0d46, 0x0d48, 0x0d4a, 0x0d4c, 0x0d57, 0x0d57, 0x0d60, 0x0d61, 0x0d66, 0x0d6f, 0x0d82, 0x0d83, 0x0d85, 0x0d96, 0x0d9a, 0x0db1, 0x0db3, 0x0dbb, 0x0dbd, 0x0dbd, 0x0dc0, 0x0dc6, 0x0dcf, 0x0dd1, 0x0dd8, 0x0ddf, 0x0df2, 0x0df4, 0x0e01, 0x0e30, 0x0e32, 0x0e33, 0x0e40, 0x0e46, 0x0e4f, 0x0e5b, 0x0e81, 0x0e82, 0x0e84, 0x0e84, 0x0e87, 0x0e88, 0x0e8a, 0x0e8a, 0x0e8d, 0x0e8d, 0x0e94, 0x0e97, 0x0e99, 0x0e9f, 0x0ea1, 0x0ea3, 0x0ea5, 0x0ea5, 0x0ea7, 0x0ea7, 0x0eaa, 0x0eab, 0x0ead, 0x0eb0, 0x0eb2, 0x0eb3, 0x0ebd, 0x0ebd, 0x0ec0, 0x0ec4, 0x0ec6, 0x0ec6, 0x0ed0, 0x0ed9, 0x0edc, 0x0edd, 0x0f00, 0x0f17, 0x0f1a, 0x0f34, 0x0f36, 0x0f36, 0x0f38, 0x0f38, 0x0f3e, 0x0f47, 0x0f49, 0x0f6a, 0x0f7f, 0x0f7f, 0x0f85, 0x0f85, 0x0f88, 0x0f8b, 0x0fbe, 0x0fc5, 0x0fc7, 0x0fcc, 0x0fcf, 0x0fcf, 0x1000, 0x1021, 0x1023, 0x1027, 0x1029, 0x102a, 0x102c, 0x102c, 0x1031, 0x1031, 0x1038, 0x1038, 0x1040, 0x1057, 0x10a0, 0x10c5, 0x10d0, 0x10f8, 0x10fb, 0x10fb, 0x1100, 0x1159, 0x115f, 0x11a2, 0x11a8, 0x11f9, 0x1200, 0x1206, 0x1208, 0x1246, 0x1248, 0x1248, 0x124a, 0x124d, 0x1250, 0x1256, 0x1258, 0x1258, 0x125a, 0x125d, 0x1260, 0x1286, 0x1288, 0x1288, 0x128a, 0x128d, 0x1290, 0x12ae, 0x12b0, 0x12b0, 0x12b2, 0x12b5, 0x12b8, 0x12be, 0x12c0, 0x12c0, 0x12c2, 0x12c5, 0x12c8, 0x12ce, 0x12d0, 0x12d6, 0x12d8, 0x12ee, 0x12f0, 0x130e, 0x1310, 0x1310, 0x1312, 0x1315, 0x1318, 0x131e, 0x1320, 0x1346, 0x1348, 0x135a, 0x1361, 0x137c, 0x13a0, 0x13f4, 0x1401, 0x1676, 0x1681, 0x169a, 0x16a0, 0x16f0, 0x1700, 0x170c, 0x170e, 0x1711, 0x1720, 0x1731, 0x1735, 0x1736, 0x1740, 0x1751, 0x1760, 0x176c, 0x176e, 0x1770, 0x1780, 0x17b6, 0x17be, 0x17c5, 0x17c7, 0x17c8, 0x17d4, 0x17da, 0x17dc, 0x17dc, 0x17e0, 0x17e9, 0x1810, 0x1819, 0x1820, 0x1877, 0x1880, 0x18a8, 0x1e00, 0x1e9b, 0x1ea0, 0x1ef9, 0x1f00, 0x1f15, 0x1f18, 0x1f1d, 0x1f20, 0x1f45, 0x1f48, 0x1f4d, 0x1f50, 0x1f57, 0x1f59, 0x1f59, 0x1f5b, 0x1f5b, 0x1f5d, 0x1f5d, 0x1f5f, 0x1f7d, 0x1f80, 0x1fb4, 0x1fb6, 0x1fbc, 0x1fbe, 0x1fbe, 0x1fc2, 0x1fc4, 0x1fc6, 0x1fcc, 0x1fd0, 0x1fd3, 0x1fd6, 0x1fdb, 0x1fe0, 0x1fec, 0x1ff2, 0x1ff4, 0x1ff6, 0x1ffc, 0x200e, 0x200e, 0x2071, 0x2071, 0x207f, 0x207f, 0x2102, 0x2102, 0x2107, 0x2107, 0x210a, 0x2113, 0x2115, 0x2115, 0x2119, 0x211d, 0x2124, 0x2124, 0x2126, 0x2126, 0x2128, 0x2128, 0x212a, 0x212d, 0x212f, 0x2131, 0x2133, 0x2139, 0x213d, 0x213f, 0x2145, 0x2149, 0x2160, 0x2183, 0x2336, 0x237a, 0x2395, 0x2395, 0x249c, 0x24e9, 0x3005, 0x3007, 0x3021, 0x3029, 0x3031, 0x3035, 0x3038, 0x303c, 0x3041, 0x3096, 0x309d, 0x309f, 0x30a1, 0x30fa, 0x30fc, 0x30ff, 0x3105, 0x312c, 0x3131, 0x318e, 0x3190, 0x31b7, 0x31f0, 0x321c, 0x3220, 0x3243, 0x3260, 0x327b, 0x327f, 0x32b0, 0x32c0, 0x32cb, 0x32d0, 0x32fe, 0x3300, 0x3376, 0x337b, 0x33dd, 0x33e0, 0x33fe, 0x3400, 0x4db5, 0x4e00, 0x9fa5, 0xa000, 0xa48c, 0xac00, 0xd7a3, 0xd800, 0xfa2d, 0xfa30, 0xfa6a, 0xfb00, 0xfb06, 0xfb13, 0xfb17, 0xff21, 0xff3a, 0xff41, 0xff5a, 0xff66, 0xffbe, 0xffc2, 0xffc7, 0xffca, 0xffcf, 0xffd2, 0xffd7, 0xffda, 0xffdc, 0x10300, 0x1031e, 0x10320, 0x10323, 0x10330, 0x1034a, 0x10400, 0x10425, 0x10428, 0x1044d, 0x1d000, 0x1d0f5, 0x1d100, 0x1d126, 0x1d12a, 0x1d166, 0x1d16a, 0x1d172, 0x1d183, 0x1d184, 0x1d18c, 0x1d1a9, 0x1d1ae, 0x1d1dd, 0x1d400, 0x1d454, 0x1d456, 0x1d49c, 0x1d49e, 0x1d49f, 0x1d4a2, 0x1d4a2, 0x1d4a5, 0x1d4a6, 0x1d4a9, 0x1d4ac, 0x1d4ae, 0x1d4b9, 0x1d4bb, 0x1d4bb, 0x1d4bd, 0x1d4c0, 0x1d4c2, 0x1d4c3, 0x1d4c5, 0x1d505, 0x1d507, 0x1d50a, 0x1d50d, 0x1d514, 0x1d516, 0x1d51c, 0x1d51e, 0x1d539, 0x1d53b, 0x1d53e, 0x1d540, 0x1d544, 0x1d546, 0x1d546, 0x1d54a, 0x1d550, 0x1d552, 0x1d6a3, 0x1d6a8, 0x1d7c9, 0x20000, 0x2a6d6, 0x2f800, 0x2fa1d, 0xf0000, 0xffffd, 0x100000, 0x10fffd]; // prettier-ignore-end\n\nvar isBidirectionalL = function isBidirectionalL(character) {\n  return inRange(character, bidirectional_l);\n};\n\n/**\r\n * non-ASCII space characters [StringPrep, C.1.2] that can be\r\n * mapped to SPACE (U+0020)\r\n */\n\nvar mapping2space = isNonASCIISpaceCharacter;\n/**\r\n * the \"commonly mapped to nothing\" characters [StringPrep, B.1]\r\n * that can be mapped to nothing.\r\n */\n\nvar mapping2nothing = isCommonlyMappedToNothing; // utils\n\nvar getCodePoint = function getCodePoint(character) {\n  return character.codePointAt(0);\n};\n\nvar first = function first(x) {\n  return x[0];\n};\n\nvar last = function last(x) {\n  return x[x.length - 1];\n};\n/**\r\n * Convert provided string into an array of Unicode Code Points.\r\n * Based on https://stackoverflow.com/a/21409165/1556249\r\n * and https://www.npmjs.com/package/code-point-at.\r\n * @param {string} input\r\n * @returns {number[]}\r\n */\n\n\nfunction toCodePoints(input) {\n  var codepoints = [];\n  var size = input.length;\n\n  for (var i = 0; i < size; i += 1) {\n    var before = input.charCodeAt(i);\n\n    if (before >= 0xd800 && before <= 0xdbff && size > i + 1) {\n      var next = input.charCodeAt(i + 1);\n\n      if (next >= 0xdc00 && next <= 0xdfff) {\n        codepoints.push((before - 0xd800) * 0x400 + next - 0xdc00 + 0x10000);\n        i += 1;\n        continue;\n      }\n    }\n\n    codepoints.push(before);\n  }\n\n  return codepoints;\n}\n/**\r\n * SASLprep.\r\n * @param {string} input\r\n * @param {Object} opts\r\n * @param {boolean} opts.allowUnassigned\r\n * @returns {string}\r\n */\n\n\nfunction saslprep(input) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected string.');\n  }\n\n  if (input.length === 0) {\n    return '';\n  } // 1. Map\n\n\n  var mapped_input = toCodePoints(input) // 1.1 mapping to space\n  .map(function (character) {\n    return mapping2space(character) ? 0x20 : character;\n  }) // 1.2 mapping to nothing\n  .filter(function (character) {\n    return !mapping2nothing(character);\n  }); // 2. Normalize\n\n  var normalized_input = String.fromCodePoint.apply(null, mapped_input).normalize('NFKC');\n  var normalized_map = toCodePoints(normalized_input); // 3. Prohibit\n\n  var hasProhibited = normalized_map.some(isProhibitedCharacter);\n\n  if (hasProhibited) {\n    throw new Error('Prohibited character, see https://tools.ietf.org/html/rfc4013#section-2.3');\n  } // Unassigned Code Points\n\n\n  if (opts.allowUnassigned !== true) {\n    var hasUnassigned = normalized_map.some(isUnassignedCodePoint);\n\n    if (hasUnassigned) {\n      throw new Error('Unassigned code point, see https://tools.ietf.org/html/rfc4013#section-2.5');\n    }\n  } // 4. check bidi\n\n\n  var hasBidiRAL = normalized_map.some(isBidirectionalRAL);\n  var hasBidiL = normalized_map.some(isBidirectionalL); // 4.1 If a string contains any RandALCat character, the string MUST NOT\n  // contain any LCat character.\n\n  if (hasBidiRAL && hasBidiL) {\n    throw new Error('String must not contain RandALCat and LCat at the same time,' + ' see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n  /**\r\n   * 4.2 If a string contains any RandALCat character, a RandALCat\r\n   * character MUST be the first character of the string, and a\r\n   * RandALCat character MUST be the last character of the string.\r\n   */\n\n\n  var isFirstBidiRAL = isBidirectionalRAL(getCodePoint(first(normalized_input)));\n  var isLastBidiRAL = isBidirectionalRAL(getCodePoint(last(normalized_input)));\n\n  if (hasBidiRAL && !(isFirstBidiRAL && isLastBidiRAL)) {\n    throw new Error('Bidirectional RandALCat character must be the first and the last' + ' character of the string, see https://tools.ietf.org/html/rfc3454#section-6');\n  }\n\n  return normalized_input;\n}\n\nvar PDFSecurity = /*#__PURE__*/function () {\n  _createClass(PDFSecurity, null, [{\n    key: \"generateFileID\",\n    value: function generateFileID() {\n      var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var infoStr = \"\".concat(info.CreationDate.getTime(), \"\\n\");\n\n      for (var key in info) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (!info.hasOwnProperty(key)) {\n          continue;\n        }\n\n        infoStr += \"\".concat(key, \": \").concat(info[key].valueOf(), \"\\n\");\n      }\n\n      return wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(infoStr));\n    }\n  }, {\n    key: \"generateRandomWordArray\",\n    value: function generateRandomWordArray(bytes) {\n      return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.random(bytes);\n    }\n  }, {\n    key: \"create\",\n    value: function create(document) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!options.ownerPassword && !options.userPassword) {\n        return null;\n      }\n\n      return new PDFSecurity(document, options);\n    }\n  }]);\n\n  function PDFSecurity(document) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, PDFSecurity);\n\n    if (!options.ownerPassword && !options.userPassword) {\n      throw new Error('None of owner password and user password is defined.');\n    }\n\n    this.document = document;\n\n    this._setupEncryption(options);\n  }\n\n  _createClass(PDFSecurity, [{\n    key: \"_setupEncryption\",\n    value: function _setupEncryption(options) {\n      switch (options.pdfVersion) {\n        case '1.4':\n        case '1.5':\n          this.version = 2;\n          break;\n\n        case '1.6':\n        case '1.7':\n          this.version = 4;\n          break;\n\n        case '1.7ext3':\n          this.version = 5;\n          break;\n\n        default:\n          this.version = 1;\n          break;\n      }\n\n      var encDict = {\n        Filter: 'Standard'\n      };\n\n      switch (this.version) {\n        case 1:\n        case 2:\n        case 4:\n          this._setupEncryptionV1V2V4(this.version, encDict, options);\n\n          break;\n\n        case 5:\n          this._setupEncryptionV5(encDict, options);\n\n          break;\n      }\n\n      this.dictionary = this.document.ref(encDict);\n    }\n  }, {\n    key: \"_setupEncryptionV1V2V4\",\n    value: function _setupEncryptionV1V2V4(v, encDict, options) {\n      var r, permissions;\n\n      switch (v) {\n        case 1:\n          r = 2;\n          this.keyBits = 40;\n          permissions = getPermissionsR2(options.permissions);\n          break;\n\n        case 2:\n          r = 3;\n          this.keyBits = 128;\n          permissions = getPermissionsR3(options.permissions);\n          break;\n\n        case 4:\n          r = 4;\n          this.keyBits = 128;\n          permissions = getPermissionsR3(options.permissions);\n          break;\n      }\n\n      var paddedUserPassword = processPasswordR2R3R4(options.userPassword);\n      var paddedOwnerPassword = options.ownerPassword ? processPasswordR2R3R4(options.ownerPassword) : paddedUserPassword;\n      var ownerPasswordEntry = getOwnerPasswordR2R3R4(r, this.keyBits, paddedUserPassword, paddedOwnerPassword);\n      this.encryptionKey = getEncryptionKeyR2R3R4(r, this.keyBits, this.document._id, paddedUserPassword, ownerPasswordEntry, permissions);\n      var userPasswordEntry;\n\n      if (r === 2) {\n        userPasswordEntry = getUserPasswordR2(this.encryptionKey);\n      } else {\n        userPasswordEntry = getUserPasswordR3R4(this.document._id, this.encryptionKey);\n      }\n\n      encDict.V = v;\n\n      if (v >= 2) {\n        encDict.Length = this.keyBits;\n      }\n\n      if (v === 4) {\n        encDict.CF = {\n          StdCF: {\n            AuthEvent: 'DocOpen',\n            CFM: 'AESV2',\n            Length: this.keyBits / 8\n          }\n        };\n        encDict.StmF = 'StdCF';\n        encDict.StrF = 'StdCF';\n      }\n\n      encDict.R = r;\n      encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n      encDict.U = wordArrayToBuffer(userPasswordEntry);\n      encDict.P = permissions;\n    }\n  }, {\n    key: \"_setupEncryptionV5\",\n    value: function _setupEncryptionV5(encDict, options) {\n      this.keyBits = 256;\n      var permissions = getPermissionsR3(options.permissions);\n      var processedUserPassword = processPasswordR5(options.userPassword);\n      var processedOwnerPassword = options.ownerPassword ? processPasswordR5(options.ownerPassword) : processedUserPassword;\n      this.encryptionKey = getEncryptionKeyR5(PDFSecurity.generateRandomWordArray);\n      var userPasswordEntry = getUserPasswordR5(processedUserPassword, PDFSecurity.generateRandomWordArray);\n      var userKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(userPasswordEntry.words.slice(10, 12), 8);\n      var userEncryptionKeyEntry = getUserEncryptionKeyR5(processedUserPassword, userKeySalt, this.encryptionKey);\n      var ownerPasswordEntry = getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, PDFSecurity.generateRandomWordArray);\n      var ownerKeySalt = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(ownerPasswordEntry.words.slice(10, 12), 8);\n      var ownerEncryptionKeyEntry = getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, this.encryptionKey);\n      var permsEntry = getEncryptedPermissionsR5(permissions, this.encryptionKey, PDFSecurity.generateRandomWordArray);\n      encDict.V = 5;\n      encDict.Length = this.keyBits;\n      encDict.CF = {\n        StdCF: {\n          AuthEvent: 'DocOpen',\n          CFM: 'AESV3',\n          Length: this.keyBits / 8\n        }\n      };\n      encDict.StmF = 'StdCF';\n      encDict.StrF = 'StdCF';\n      encDict.R = 5;\n      encDict.O = wordArrayToBuffer(ownerPasswordEntry);\n      encDict.OE = wordArrayToBuffer(ownerEncryptionKeyEntry);\n      encDict.U = wordArrayToBuffer(userPasswordEntry);\n      encDict.UE = wordArrayToBuffer(userEncryptionKeyEntry);\n      encDict.P = permissions;\n      encDict.Perms = wordArrayToBuffer(permsEntry);\n    }\n  }, {\n    key: \"getEncryptFn\",\n    value: function getEncryptFn(obj, gen) {\n      var digest;\n\n      if (this.version < 5) {\n        digest = this.encryptionKey.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create([(obj & 0xff) << 24 | (obj & 0xff00) << 8 | obj >> 8 & 0xff00 | gen & 0xff, (gen & 0xff00) << 16], 5));\n      }\n\n      if (this.version === 1 || this.version === 2) {\n        var _key = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(digest);\n\n        _key.sigBytes = Math.min(16, this.keyBits / 8 + 5);\n        return function (buffer) {\n          return wordArrayToBuffer(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().RC4.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(buffer), _key).ciphertext);\n        };\n      }\n\n      var key;\n\n      if (this.version === 4) {\n        key = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(digest.concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create([0x73416c54], 4)));\n      } else {\n        key = this.encryptionKey;\n      }\n\n      var iv = PDFSecurity.generateRandomWordArray(16);\n      var options = {\n        mode: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().mode).CBC,\n        padding: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().pad).Pkcs7,\n        iv: iv\n      };\n      return function (buffer) {\n        return wordArrayToBuffer(iv.clone().concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().AES.encrypt(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(buffer), key, options).ciphertext));\n      };\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.dictionary.end();\n    }\n  }]);\n\n  return PDFSecurity;\n}();\n\nfunction getPermissionsR2() {\n  var permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var permissions = 0xffffffc0 >> 0;\n\n  if (permissionObject.printing) {\n    permissions |= 4;\n  }\n\n  if (permissionObject.modifying) {\n    permissions |= 8;\n  }\n\n  if (permissionObject.copying) {\n    permissions |= 16;\n  }\n\n  if (permissionObject.annotating) {\n    permissions |= 32;\n  }\n\n  return permissions;\n}\n\nfunction getPermissionsR3() {\n  var permissionObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var permissions = 0xfffff0c0 >> 0;\n\n  if (permissionObject.printing === 'lowResolution') {\n    permissions |= 4;\n  }\n\n  if (permissionObject.printing === 'highResolution') {\n    permissions |= 2052;\n  }\n\n  if (permissionObject.modifying) {\n    permissions |= 8;\n  }\n\n  if (permissionObject.copying) {\n    permissions |= 16;\n  }\n\n  if (permissionObject.annotating) {\n    permissions |= 32;\n  }\n\n  if (permissionObject.fillingForms) {\n    permissions |= 256;\n  }\n\n  if (permissionObject.contentAccessibility) {\n    permissions |= 512;\n  }\n\n  if (permissionObject.documentAssembly) {\n    permissions |= 1024;\n  }\n\n  return permissions;\n}\n\nfunction getUserPasswordR2(encryptionKey) {\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().RC4.encrypt(processPasswordR2R3R4(), encryptionKey).ciphertext;\n}\n\nfunction getUserPasswordR3R4(documentId, encryptionKey) {\n  var key = encryptionKey.clone();\n  var cipher = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(processPasswordR2R3R4().concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(documentId)));\n\n  for (var i = 0; i < 20; i++) {\n    var xorRound = Math.ceil(key.sigBytes / 4);\n\n    for (var j = 0; j < xorRound; j++) {\n      key.words[j] = encryptionKey.words[j] ^ (i | i << 8 | i << 16 | i << 24);\n    }\n\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n\n  return cipher.concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(null, 16));\n}\n\nfunction getOwnerPasswordR2R3R4(r, keyBits, paddedUserPassword, paddedOwnerPassword) {\n  var digest = paddedOwnerPassword;\n  var round = r >= 3 ? 51 : 1;\n\n  for (var i = 0; i < round; i++) {\n    digest = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(digest);\n  }\n\n  var key = digest.clone();\n  key.sigBytes = keyBits / 8;\n  var cipher = paddedUserPassword;\n  round = r >= 3 ? 20 : 1;\n\n  for (var _i = 0; _i < round; _i++) {\n    var xorRound = Math.ceil(key.sigBytes / 4);\n\n    for (var j = 0; j < xorRound; j++) {\n      key.words[j] = digest.words[j] ^ (_i | _i << 8 | _i << 16 | _i << 24);\n    }\n\n    cipher = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().RC4.encrypt(cipher, key).ciphertext;\n  }\n\n  return cipher;\n}\n\nfunction getEncryptionKeyR2R3R4(r, keyBits, documentId, paddedUserPassword, ownerPasswordEntry, permissions) {\n  var key = paddedUserPassword.clone().concat(ownerPasswordEntry).concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create([lsbFirstWord(permissions)], 4)).concat(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(documentId));\n  var round = r >= 3 ? 51 : 1;\n\n  for (var i = 0; i < round; i++) {\n    key = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(key);\n    key.sigBytes = keyBits / 8;\n  }\n\n  return key;\n}\n\nfunction getUserPasswordR5(processedUserPassword, generateRandomWordArray) {\n  var validationSalt = generateRandomWordArray(8);\n  var keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().SHA256(processedUserPassword.clone().concat(validationSalt)).concat(validationSalt).concat(keySalt);\n}\n\nfunction getUserEncryptionKeyR5(processedUserPassword, userKeySalt, encryptionKey) {\n  var key = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().SHA256(processedUserPassword.clone().concat(userKeySalt));\n  var options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\n\nfunction getOwnerPasswordR5(processedOwnerPassword, userPasswordEntry, generateRandomWordArray) {\n  var validationSalt = generateRandomWordArray(8);\n  var keySalt = generateRandomWordArray(8);\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().SHA256(processedOwnerPassword.clone().concat(validationSalt).concat(userPasswordEntry)).concat(validationSalt).concat(keySalt);\n}\n\nfunction getOwnerEncryptionKeyR5(processedOwnerPassword, ownerKeySalt, userPasswordEntry, encryptionKey) {\n  var key = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().SHA256(processedOwnerPassword.clone().concat(ownerKeySalt).concat(userPasswordEntry));\n  var options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().mode).CBC,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().pad).NoPadding,\n    iv: crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(null, 16)\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().AES.encrypt(encryptionKey, key, options).ciphertext;\n}\n\nfunction getEncryptionKeyR5(generateRandomWordArray) {\n  return generateRandomWordArray(32);\n}\n\nfunction getEncryptedPermissionsR5(permissions, encryptionKey, generateRandomWordArray) {\n  var cipher = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create([lsbFirstWord(permissions), 0xffffffff, 0x54616462], 12).concat(generateRandomWordArray(4));\n  var options = {\n    mode: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().mode).ECB,\n    padding: (crypto_js__WEBPACK_IMPORTED_MODULE_3___default().pad).NoPadding\n  };\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().AES.encrypt(cipher, encryptionKey, options).ciphertext;\n}\n\nfunction processPasswordR2R3R4() {\n  var password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var out = Buffer.alloc(32);\n  var length = password.length;\n  var index = 0;\n\n  while (index < length && index < 32) {\n    var code = password.charCodeAt(index);\n\n    if (code > 0xff) {\n      throw new Error('Password contains one or more invalid characters.');\n    }\n\n    out[index] = code;\n    index++;\n  }\n\n  while (index < 32) {\n    out[index] = PASSWORD_PADDING[index - length];\n    index++;\n  }\n\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(out);\n}\n\nfunction processPasswordR5() {\n  var password = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  password = unescape(encodeURIComponent(saslprep(password)));\n  var length = Math.min(127, password.length);\n  var out = Buffer.alloc(length);\n\n  for (var i = 0; i < length; i++) {\n    out[i] = password.charCodeAt(i);\n  }\n\n  return crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(out);\n}\n\nfunction lsbFirstWord(data) {\n  return (data & 0xff) << 24 | (data & 0xff00) << 8 | data >> 8 & 0xff00 | data >> 24 & 0xff;\n}\n\nfunction wordArrayToBuffer(wordArray) {\n  var byteArray = [];\n\n  for (var i = 0; i < wordArray.sigBytes; i++) {\n    byteArray.push(wordArray.words[Math.floor(i / 4)] >> 8 * (3 - i % 4) & 0xff);\n  }\n\n  return Buffer.from(byteArray);\n}\n\nvar PASSWORD_PADDING = [0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41, 0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08, 0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80, 0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a];\n\nvar number = PDFObject.number;\n\nvar PDFGradient = /*#__PURE__*/function () {\n  function PDFGradient(doc) {\n    _classCallCheck(this, PDFGradient);\n\n    this.doc = doc;\n    this.stops = [];\n    this.embedded = false;\n    this.transform = [1, 0, 0, 1, 0, 0];\n  }\n\n  _createClass(PDFGradient, [{\n    key: \"stop\",\n    value: function stop(pos, color, opacity) {\n      if (opacity == null) {\n        opacity = 1;\n      }\n\n      color = this.doc._normalizeColor(color);\n\n      if (this.stops.length === 0) {\n        if (color.length === 3) {\n          this._colorSpace = 'DeviceRGB';\n        } else if (color.length === 4) {\n          this._colorSpace = 'DeviceCMYK';\n        } else if (color.length === 1) {\n          this._colorSpace = 'DeviceGray';\n        } else {\n          throw new Error('Unknown color space');\n        }\n      } else if (this._colorSpace === 'DeviceRGB' && color.length !== 3 || this._colorSpace === 'DeviceCMYK' && color.length !== 4 || this._colorSpace === 'DeviceGray' && color.length !== 1) {\n        throw new Error('All gradient stops must use the same color space');\n      }\n\n      opacity = Math.max(0, Math.min(1, opacity));\n      this.stops.push([pos, color, opacity]);\n      return this;\n    }\n  }, {\n    key: \"setTransform\",\n    value: function setTransform(m11, m12, m21, m22, dx, dy) {\n      this.transform = [m11, m12, m21, m22, dx, dy];\n      return this;\n    }\n  }, {\n    key: \"embed\",\n    value: function embed(m) {\n      var fn;\n      var stopsLength = this.stops.length;\n\n      if (stopsLength === 0) {\n        return;\n      }\n\n      this.embedded = true;\n      this.matrix = m; // if the last stop comes before 100%, add a copy at 100%\n\n      var last = this.stops[stopsLength - 1];\n\n      if (last[0] < 1) {\n        this.stops.push([1, last[1], last[2]]);\n      }\n\n      var bounds = [];\n      var encode = [];\n      var stops = [];\n\n      for (var i = 0; i < stopsLength - 1; i++) {\n        encode.push(0, 1);\n\n        if (i + 2 !== stopsLength) {\n          bounds.push(this.stops[i + 1][0]);\n        }\n\n        fn = this.doc.ref({\n          FunctionType: 2,\n          Domain: [0, 1],\n          C0: this.stops[i + 0][1],\n          C1: this.stops[i + 1][1],\n          N: 1\n        });\n        stops.push(fn);\n        fn.end();\n      } // if there are only two stops, we don't need a stitching function\n\n\n      if (stopsLength === 1) {\n        fn = stops[0];\n      } else {\n        fn = this.doc.ref({\n          FunctionType: 3,\n          // stitching function\n          Domain: [0, 1],\n          Functions: stops,\n          Bounds: bounds,\n          Encode: encode\n        });\n        fn.end();\n      }\n\n      this.id = \"Sh\".concat(++this.doc._gradCount);\n      var shader = this.shader(fn);\n      shader.end();\n      var pattern = this.doc.ref({\n        Type: 'Pattern',\n        PatternType: 2,\n        Shading: shader,\n        Matrix: this.matrix.map(number)\n      });\n      pattern.end();\n\n      if (this.stops.some(function (stop) {\n        return stop[2] < 1;\n      })) {\n        var grad = this.opacityGradient();\n        grad._colorSpace = 'DeviceGray';\n\n        var _iterator = _createForOfIteratorHelper(this.stops),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var stop = _step.value;\n            grad.stop(stop[0], [stop[2]]);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        grad = grad.embed(this.matrix);\n        var pageBBox = [0, 0, this.doc.page.width, this.doc.page.height];\n        var form = this.doc.ref({\n          Type: 'XObject',\n          Subtype: 'Form',\n          FormType: 1,\n          BBox: pageBBox,\n          Group: {\n            Type: 'Group',\n            S: 'Transparency',\n            CS: 'DeviceGray'\n          },\n          Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Pattern: {\n              Sh1: grad\n            }\n          }\n        });\n        form.write('/Pattern cs /Sh1 scn');\n        form.end(\"\".concat(pageBBox.join(' '), \" re f\"));\n        var gstate = this.doc.ref({\n          Type: 'ExtGState',\n          SMask: {\n            Type: 'Mask',\n            S: 'Luminosity',\n            G: form\n          }\n        });\n        gstate.end();\n        var opacityPattern = this.doc.ref({\n          Type: 'Pattern',\n          PatternType: 1,\n          PaintType: 1,\n          TilingType: 2,\n          BBox: pageBBox,\n          XStep: pageBBox[2],\n          YStep: pageBBox[3],\n          Resources: {\n            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],\n            Pattern: {\n              Sh1: pattern\n            },\n            ExtGState: {\n              Gs1: gstate\n            }\n          }\n        });\n        opacityPattern.write('/Gs1 gs /Pattern cs /Sh1 scn');\n        opacityPattern.end(\"\".concat(pageBBox.join(' '), \" re f\"));\n        this.doc.page.patterns[this.id] = opacityPattern;\n      } else {\n        this.doc.page.patterns[this.id] = pattern;\n      }\n\n      return pattern;\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(stroke) {\n      // apply gradient transform to existing document ctm\n      var _this$doc$_ctm = _slicedToArray(this.doc._ctm, 6),\n          m0 = _this$doc$_ctm[0],\n          m1 = _this$doc$_ctm[1],\n          m2 = _this$doc$_ctm[2],\n          m3 = _this$doc$_ctm[3],\n          m4 = _this$doc$_ctm[4],\n          m5 = _this$doc$_ctm[5];\n\n      var _this$transform = _slicedToArray(this.transform, 6),\n          m11 = _this$transform[0],\n          m12 = _this$transform[1],\n          m21 = _this$transform[2],\n          m22 = _this$transform[3],\n          dx = _this$transform[4],\n          dy = _this$transform[5];\n\n      var m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n\n      if (!this.embedded || m.join(' ') !== this.matrix.join(' ')) {\n        this.embed(m);\n      }\n\n      this.doc._setColorSpace('Pattern', stroke);\n\n      var op = stroke ? 'SCN' : 'scn';\n      return this.doc.addContent(\"/\".concat(this.id, \" \").concat(op));\n    }\n  }]);\n\n  return PDFGradient;\n}();\n\nvar PDFLinearGradient = /*#__PURE__*/function (_PDFGradient) {\n  _inherits(PDFLinearGradient, _PDFGradient);\n\n  var _super = _createSuper(PDFLinearGradient);\n\n  function PDFLinearGradient(doc, x1, y1, x2, y2) {\n    var _this;\n\n    _classCallCheck(this, PDFLinearGradient);\n\n    _this = _super.call(this, doc);\n    _this.x1 = x1;\n    _this.y1 = y1;\n    _this.x2 = x2;\n    _this.y2 = y2;\n    return _this;\n  }\n\n  _createClass(PDFLinearGradient, [{\n    key: \"shader\",\n    value: function shader(fn) {\n      return this.doc.ref({\n        ShadingType: 2,\n        ColorSpace: this._colorSpace,\n        Coords: [this.x1, this.y1, this.x2, this.y2],\n        Function: fn,\n        Extend: [true, true]\n      });\n    }\n  }, {\n    key: \"opacityGradient\",\n    value: function opacityGradient() {\n      return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);\n    }\n  }]);\n\n  return PDFLinearGradient;\n}(PDFGradient);\n\nvar PDFRadialGradient = /*#__PURE__*/function (_PDFGradient2) {\n  _inherits(PDFRadialGradient, _PDFGradient2);\n\n  var _super2 = _createSuper(PDFRadialGradient);\n\n  function PDFRadialGradient(doc, x1, y1, r1, x2, y2, r2) {\n    var _this2;\n\n    _classCallCheck(this, PDFRadialGradient);\n\n    _this2 = _super2.call(this, doc);\n    _this2.doc = doc;\n    _this2.x1 = x1;\n    _this2.y1 = y1;\n    _this2.r1 = r1;\n    _this2.x2 = x2;\n    _this2.y2 = y2;\n    _this2.r2 = r2;\n    return _this2;\n  }\n\n  _createClass(PDFRadialGradient, [{\n    key: \"shader\",\n    value: function shader(fn) {\n      return this.doc.ref({\n        ShadingType: 3,\n        ColorSpace: this._colorSpace,\n        Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],\n        Function: fn,\n        Extend: [true, true]\n      });\n    }\n  }, {\n    key: \"opacityGradient\",\n    value: function opacityGradient() {\n      return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);\n    }\n  }]);\n\n  return PDFRadialGradient;\n}(PDFGradient);\n\nvar Gradient = {\n  PDFGradient: PDFGradient,\n  PDFLinearGradient: PDFLinearGradient,\n  PDFRadialGradient: PDFRadialGradient\n};\n\n/*\r\nPDF tiling pattern support. Uncolored only.\r\n */\nvar underlyingColorSpaces = ['DeviceCMYK', 'DeviceRGB'];\n\nvar PDFTilingPattern = /*#__PURE__*/function () {\n  function PDFTilingPattern(doc, bBox, xStep, yStep, stream) {\n    _classCallCheck(this, PDFTilingPattern);\n\n    this.doc = doc;\n    this.bBox = bBox;\n    this.xStep = xStep;\n    this.yStep = yStep;\n    this.stream = stream;\n  }\n\n  _createClass(PDFTilingPattern, [{\n    key: \"createPattern\",\n    value: function createPattern() {\n      // no resources needed for our current usage\n      // required entry\n      var resources = this.doc.ref();\n      resources.end(); // apply default transform matrix (flipped in the default doc._ctm)\n      // see document.js & gradient.js\n\n      var _this$doc$_ctm = _slicedToArray(this.doc._ctm, 6),\n          m0 = _this$doc$_ctm[0],\n          m1 = _this$doc$_ctm[1],\n          m2 = _this$doc$_ctm[2],\n          m3 = _this$doc$_ctm[3],\n          m4 = _this$doc$_ctm[4],\n          m5 = _this$doc$_ctm[5];\n\n      var m11 = 1,\n          m12 = 0,\n          m21 = 0,\n          m22 = 1,\n          dx = 0,\n          dy = 0;\n      var m = [m0 * m11 + m2 * m12, m1 * m11 + m3 * m12, m0 * m21 + m2 * m22, m1 * m21 + m3 * m22, m0 * dx + m2 * dy + m4, m1 * dx + m3 * dy + m5];\n      var pattern = this.doc.ref({\n        Type: 'Pattern',\n        PatternType: 1,\n        // tiling\n        PaintType: 2,\n        // 1-colored, 2-uncolored\n        TilingType: 2,\n        // 2-no distortion\n        BBox: this.bBox,\n        XStep: this.xStep,\n        YStep: this.yStep,\n        Matrix: m.map(function (v) {\n          return +v.toFixed(5);\n        }),\n        Resources: resources\n      });\n      pattern.end(this.stream);\n      return pattern;\n    }\n  }, {\n    key: \"embedPatternColorSpaces\",\n    value: function embedPatternColorSpaces() {\n      var _this = this;\n\n      // map each pattern to an underlying color space\n      // and embed on each page\n      underlyingColorSpaces.forEach(function (csName) {\n        var csId = _this.getPatternColorSpaceId(csName);\n\n        if (_this.doc.page.colorSpaces[csId]) return;\n\n        var cs = _this.doc.ref(['Pattern', csName]);\n\n        cs.end();\n        _this.doc.page.colorSpaces[csId] = cs;\n      });\n    }\n  }, {\n    key: \"getPatternColorSpaceId\",\n    value: function getPatternColorSpaceId(underlyingColorspace) {\n      return \"CsP\".concat(underlyingColorspace);\n    }\n  }, {\n    key: \"embed\",\n    value: function embed() {\n      if (!this.id) {\n        this.doc._patternCount = this.doc._patternCount + 1;\n        this.id = 'P' + this.doc._patternCount;\n        this.pattern = this.createPattern();\n      } // patterns are embedded in each page\n\n\n      if (!this.doc.page.patterns[this.id]) {\n        this.doc.page.patterns[this.id] = this.pattern;\n      }\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(stroke, patternColor) {\n      // do any embedding/creating that might be needed\n      this.embedPatternColorSpaces();\n      this.embed();\n\n      var normalizedColor = this.doc._normalizeColor(patternColor);\n\n      if (!normalizedColor) throw Error(\"invalid pattern color. (value: \".concat(patternColor, \")\")); // select one of the pattern color spaces\n\n      var csId = this.getPatternColorSpaceId(this.doc._getColorSpace(normalizedColor));\n\n      this.doc._setColorSpace(csId, stroke); // stroke/fill using the pattern and color (in the above underlying color space)\n\n\n      var op = stroke ? 'SCN' : 'scn';\n      return this.doc.addContent(\"\".concat(normalizedColor.join(' '), \" /\").concat(this.id, \" \").concat(op));\n    }\n  }]);\n\n  return PDFTilingPattern;\n}();\n\nvar pattern = {\n  PDFTilingPattern: PDFTilingPattern\n};\n\nvar PDFGradient$1 = Gradient.PDFGradient,\n    PDFLinearGradient$1 = Gradient.PDFLinearGradient,\n    PDFRadialGradient$1 = Gradient.PDFRadialGradient;\nvar PDFTilingPattern$1 = pattern.PDFTilingPattern;\nvar ColorMixin = {\n  initColor: function initColor() {\n    // The opacity dictionaries\n    this._opacityRegistry = {};\n    this._opacityCount = 0;\n    this._patternCount = 0;\n    return this._gradCount = 0;\n  },\n  _normalizeColor: function _normalizeColor(color) {\n    if (typeof color === 'string') {\n      if (color.charAt(0) === '#') {\n        if (color.length === 4) {\n          color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, '#$1$1$2$2$3$3');\n        }\n\n        var hex = parseInt(color.slice(1), 16);\n        color = [hex >> 16, hex >> 8 & 0xff, hex & 0xff];\n      } else if (namedColors[color]) {\n        color = namedColors[color];\n      }\n    }\n\n    if (Array.isArray(color)) {\n      // RGB\n      if (color.length === 3) {\n        color = color.map(function (part) {\n          return part / 255;\n        }); // CMYK\n      } else if (color.length === 4) {\n        color = color.map(function (part) {\n          return part / 100;\n        });\n      }\n\n      return color;\n    }\n\n    return null;\n  },\n  _setColor: function _setColor(color, stroke) {\n    if (color instanceof PDFGradient$1) {\n      color.apply(stroke);\n      return true; // see if tiling pattern, decode & apply it it\n    } else if (Array.isArray(color) && color[0] instanceof PDFTilingPattern$1) {\n      color[0].apply(stroke, color[1]);\n      return true;\n    } // any other case should be a normal color and not a pattern\n\n\n    return this._setColorCore(color, stroke);\n  },\n  _setColorCore: function _setColorCore(color, stroke) {\n    color = this._normalizeColor(color);\n\n    if (!color) {\n      return false;\n    }\n\n    var op = stroke ? 'SCN' : 'scn';\n\n    var space = this._getColorSpace(color);\n\n    this._setColorSpace(space, stroke);\n\n    color = color.join(' ');\n    this.addContent(\"\".concat(color, \" \").concat(op));\n    return true;\n  },\n  _setColorSpace: function _setColorSpace(space, stroke) {\n    var op = stroke ? 'CS' : 'cs';\n    return this.addContent(\"/\".concat(space, \" \").concat(op));\n  },\n  _getColorSpace: function _getColorSpace(color) {\n    return color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';\n  },\n  fillColor: function fillColor(color, opacity) {\n    var set = this._setColor(color, false);\n\n    if (set) {\n      this.fillOpacity(opacity);\n    } // save this for text wrapper, which needs to reset\n    // the fill color on new pages\n\n\n    this._fillColor = [color, opacity];\n    return this;\n  },\n  strokeColor: function strokeColor(color, opacity) {\n    var set = this._setColor(color, true);\n\n    if (set) {\n      this.strokeOpacity(opacity);\n    }\n\n    return this;\n  },\n  opacity: function opacity(_opacity) {\n    this._doOpacity(_opacity, _opacity);\n\n    return this;\n  },\n  fillOpacity: function fillOpacity(opacity) {\n    this._doOpacity(opacity, null);\n\n    return this;\n  },\n  strokeOpacity: function strokeOpacity(opacity) {\n    this._doOpacity(null, opacity);\n\n    return this;\n  },\n  _doOpacity: function _doOpacity(fillOpacity, strokeOpacity) {\n    var dictionary, name;\n\n    if (fillOpacity == null && strokeOpacity == null) {\n      return;\n    }\n\n    if (fillOpacity != null) {\n      fillOpacity = Math.max(0, Math.min(1, fillOpacity));\n    }\n\n    if (strokeOpacity != null) {\n      strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));\n    }\n\n    var key = \"\".concat(fillOpacity, \"_\").concat(strokeOpacity);\n\n    if (this._opacityRegistry[key]) {\n      var _this$_opacityRegistr = _slicedToArray(this._opacityRegistry[key], 2);\n\n      dictionary = _this$_opacityRegistr[0];\n      name = _this$_opacityRegistr[1];\n    } else {\n      dictionary = {\n        Type: 'ExtGState'\n      };\n\n      if (fillOpacity != null) {\n        dictionary.ca = fillOpacity;\n      }\n\n      if (strokeOpacity != null) {\n        dictionary.CA = strokeOpacity;\n      }\n\n      dictionary = this.ref(dictionary);\n      dictionary.end();\n      var id = ++this._opacityCount;\n      name = \"Gs\".concat(id);\n      this._opacityRegistry[key] = [dictionary, name];\n    }\n\n    this.page.ext_gstates[name] = dictionary;\n    return this.addContent(\"/\".concat(name, \" gs\"));\n  },\n  linearGradient: function linearGradient(x1, y1, x2, y2) {\n    return new PDFLinearGradient$1(this, x1, y1, x2, y2);\n  },\n  radialGradient: function radialGradient(x1, y1, r1, x2, y2, r2) {\n    return new PDFRadialGradient$1(this, x1, y1, r1, x2, y2, r2);\n  },\n  pattern: function pattern(bbox, xStep, yStep, stream) {\n    return new PDFTilingPattern$1(this, bbox, xStep, yStep, stream);\n  }\n};\nvar namedColors = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  grey: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\n\nvar cx, cy, px, py, sx, sy;\ncx = cy = px = py = sx = sy = 0;\nvar parameters = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0\n};\n\nvar parse = function parse(path) {\n  var cmd;\n  var ret = [];\n  var args = [];\n  var curArg = '';\n  var foundDecimal = false;\n  var params = 0;\n\n  var _iterator = _createForOfIteratorHelper(path),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var c = _step.value;\n\n      if (parameters[c] != null) {\n        params = parameters[c];\n\n        if (cmd) {\n          // save existing command\n          if (curArg.length > 0) {\n            args[args.length] = +curArg;\n          }\n\n          ret[ret.length] = {\n            cmd: cmd,\n            args: args\n          };\n          args = [];\n          curArg = '';\n          foundDecimal = false;\n        }\n\n        cmd = c;\n      } else if ([' ', ','].includes(c) || c === '-' && curArg.length > 0 && curArg[curArg.length - 1] !== 'e' || c === '.' && foundDecimal) {\n        if (curArg.length === 0) {\n          continue;\n        }\n\n        if (args.length === params) {\n          // handle reused commands\n          ret[ret.length] = {\n            cmd: cmd,\n            args: args\n          };\n          args = [+curArg]; // handle assumed commands\n\n          if (cmd === 'M') {\n            cmd = 'L';\n          }\n\n          if (cmd === 'm') {\n            cmd = 'l';\n          }\n        } else {\n          args[args.length] = +curArg;\n        }\n\n        foundDecimal = c === '.'; // fix for negative numbers or repeated decimals with no delimeter between commands\n\n        curArg = ['-', '.'].includes(c) ? c : '';\n      } else {\n        curArg += c;\n\n        if (c === '.') {\n          foundDecimal = true;\n        }\n      }\n    } // add the last command\n\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (curArg.length > 0) {\n    if (args.length === params) {\n      // handle reused commands\n      ret[ret.length] = {\n        cmd: cmd,\n        args: args\n      };\n      args = [+curArg]; // handle assumed commands\n\n      if (cmd === 'M') {\n        cmd = 'L';\n      }\n\n      if (cmd === 'm') {\n        cmd = 'l';\n      }\n    } else {\n      args[args.length] = +curArg;\n    }\n  }\n\n  ret[ret.length] = {\n    cmd: cmd,\n    args: args\n  };\n  return ret;\n};\n\nvar _apply = function apply(commands, doc) {\n  // current point, control point, and subpath starting point\n  cx = cy = px = py = sx = sy = 0; // run the commands\n\n  for (var i = 0; i < commands.length; i++) {\n    var c = commands[i];\n\n    if (typeof runners[c.cmd] === 'function') {\n      runners[c.cmd](doc, c.args);\n    }\n  }\n};\n\nvar runners = {\n  M: function M(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  m: function m(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    sx = cx;\n    sy = cy;\n    return doc.moveTo(cx, cy);\n  },\n  C: function C(doc, a) {\n    cx = a[4];\n    cy = a[5];\n    px = a[2];\n    py = a[3];\n    return doc.bezierCurveTo.apply(doc, _toConsumableArray(a));\n  },\n  c: function c(doc, a) {\n    doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);\n    px = cx + a[2];\n    py = cy + a[3];\n    cx += a[4];\n    return cy += a[5];\n  },\n  S: function S(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    return cy = a[3];\n  },\n  s: function s(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    }\n\n    doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  Q: function Q(doc, a) {\n    px = a[0];\n    py = a[1];\n    cx = a[2];\n    cy = a[3];\n    return doc.quadraticCurveTo(a[0], a[1], cx, cy);\n  },\n  q: function q(doc, a) {\n    doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);\n    px = cx + a[0];\n    py = cy + a[1];\n    cx += a[2];\n    return cy += a[3];\n  },\n  T: function T(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n\n    doc.quadraticCurveTo(px, py, a[0], a[1]);\n    px = cx - (px - cx);\n    py = cy - (py - cy);\n    cx = a[0];\n    return cy = a[1];\n  },\n  t: function t(doc, a) {\n    if (px === null) {\n      px = cx;\n      py = cy;\n    } else {\n      px = cx - (px - cx);\n      py = cy - (py - cy);\n    }\n\n    doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);\n    cx += a[0];\n    return cy += a[1];\n  },\n  A: function A(doc, a) {\n    solveArc(doc, cx, cy, a);\n    cx = a[5];\n    return cy = a[6];\n  },\n  a: function a(doc, _a) {\n    _a[5] += cx;\n    _a[6] += cy;\n    solveArc(doc, cx, cy, _a);\n    cx = _a[5];\n    return cy = _a[6];\n  },\n  L: function L(doc, a) {\n    cx = a[0];\n    cy = a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  l: function l(doc, a) {\n    cx += a[0];\n    cy += a[1];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  H: function H(doc, a) {\n    cx = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  h: function h(doc, a) {\n    cx += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  V: function V(doc, a) {\n    cy = a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  v: function v(doc, a) {\n    cy += a[0];\n    px = py = null;\n    return doc.lineTo(cx, cy);\n  },\n  Z: function Z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  },\n  z: function z(doc) {\n    doc.closePath();\n    cx = sx;\n    return cy = sy;\n  }\n};\n\nvar solveArc = function solveArc(doc, x, y, coords) {\n  var _coords = _slicedToArray(coords, 7),\n      rx = _coords[0],\n      ry = _coords[1],\n      rot = _coords[2],\n      large = _coords[3],\n      sweep = _coords[4],\n      ex = _coords[5],\n      ey = _coords[6];\n\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n\n  var _iterator2 = _createForOfIteratorHelper(segs),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var seg = _step2.value;\n      var bez = segmentToBezier.apply(void 0, _toConsumableArray(seg));\n      doc.bezierCurveTo.apply(doc, _toConsumableArray(bez));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}; // from Inkscape svgtopdf, thanks!\n\n\nvar arcToSegments = function arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  var th = rotateX * (Math.PI / 180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = px * px / (rx * rx) + py * py / (ry * ry);\n\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = -sin_th / ry;\n  var a11 = cos_th / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n  var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);\n  var sfactor_sq = 1 / d - 0.25;\n\n  if (sfactor_sq < 0) {\n    sfactor_sq = 0;\n  }\n\n  var sfactor = Math.sqrt(sfactor_sq);\n\n  if (sweep === large) {\n    sfactor = -sfactor;\n  }\n\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);\n  var th0 = Math.atan2(y0 - yc, x0 - xc);\n  var th1 = Math.atan2(y1 - yc, x1 - xc);\n  var th_arc = th1 - th0;\n\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n\n  for (var i = 0; i < segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i + 1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return result;\n};\n\nvar segmentToBezier = function segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n  var th_half = 0.5 * (th1 - th0);\n  var t = 8 / 3 * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);\n  var x1 = cx + Math.cos(th0) - t * Math.sin(th0);\n  var y1 = cy + Math.sin(th0) + t * Math.cos(th0);\n  var x3 = cx + Math.cos(th1);\n  var y3 = cy + Math.sin(th1);\n  var x2 = x3 + t * Math.sin(th1);\n  var y2 = y3 - t * Math.cos(th1);\n  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];\n};\n\nvar SVGPath = /*#__PURE__*/function () {\n  function SVGPath() {\n    _classCallCheck(this, SVGPath);\n  }\n\n  _createClass(SVGPath, null, [{\n    key: \"apply\",\n    value: function apply(doc, path) {\n      var commands = parse(path);\n\n      _apply(commands, doc);\n    }\n  }]);\n\n  return SVGPath;\n}();\n\nvar number$1 = PDFObject.number; // This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\n\nvar KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar VectorMixin = {\n  initVector: function initVector() {\n    this._ctm = [1, 0, 0, 1, 0, 0]; // current transformation matrix\n\n    return this._ctmStack = [];\n  },\n  save: function save() {\n    this._ctmStack.push(this._ctm.slice()); // TODO: save/restore colorspace and styles so not setting it unnessesarily all the time?\n\n\n    return this.addContent('q');\n  },\n  restore: function restore() {\n    this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];\n    return this.addContent('Q');\n  },\n  closePath: function closePath() {\n    return this.addContent('h');\n  },\n  lineWidth: function lineWidth(w) {\n    return this.addContent(\"\".concat(number$1(w), \" w\"));\n  },\n  _CAP_STYLES: {\n    BUTT: 0,\n    ROUND: 1,\n    SQUARE: 2\n  },\n  lineCap: function lineCap(c) {\n    if (typeof c === 'string') {\n      c = this._CAP_STYLES[c.toUpperCase()];\n    }\n\n    return this.addContent(\"\".concat(c, \" J\"));\n  },\n  _JOIN_STYLES: {\n    MITER: 0,\n    ROUND: 1,\n    BEVEL: 2\n  },\n  lineJoin: function lineJoin(j) {\n    if (typeof j === 'string') {\n      j = this._JOIN_STYLES[j.toUpperCase()];\n    }\n\n    return this.addContent(\"\".concat(j, \" j\"));\n  },\n  miterLimit: function miterLimit(m) {\n    return this.addContent(\"\".concat(number$1(m), \" M\"));\n  },\n  dash: function dash(length) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var originalLength = length;\n\n    if (!Array.isArray(length)) {\n      length = [length, options.space || length];\n    }\n\n    var valid = length.every(function (x) {\n      return Number.isFinite(x) && x > 0;\n    });\n\n    if (!valid) {\n      throw new Error(\"dash(\".concat(JSON.stringify(originalLength), \", \").concat(JSON.stringify(options), \") invalid, lengths must be numeric and greater than zero\"));\n    }\n\n    length = length.map(number$1).join(' ');\n    return this.addContent(\"[\".concat(length, \"] \").concat(number$1(options.phase || 0), \" d\"));\n  },\n  undash: function undash() {\n    return this.addContent('[] 0 d');\n  },\n  moveTo: function moveTo(x, y) {\n    return this.addContent(\"\".concat(number$1(x), \" \").concat(number$1(y), \" m\"));\n  },\n  lineTo: function lineTo(x, y) {\n    return this.addContent(\"\".concat(number$1(x), \" \").concat(number$1(y), \" l\"));\n  },\n  bezierCurveTo: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    return this.addContent(\"\".concat(number$1(cp1x), \" \").concat(number$1(cp1y), \" \").concat(number$1(cp2x), \" \").concat(number$1(cp2y), \" \").concat(number$1(x), \" \").concat(number$1(y), \" c\"));\n  },\n  quadraticCurveTo: function quadraticCurveTo(cpx, cpy, x, y) {\n    return this.addContent(\"\".concat(number$1(cpx), \" \").concat(number$1(cpy), \" \").concat(number$1(x), \" \").concat(number$1(y), \" v\"));\n  },\n  rect: function rect(x, y, w, h) {\n    return this.addContent(\"\".concat(number$1(x), \" \").concat(number$1(y), \" \").concat(number$1(w), \" \").concat(number$1(h), \" re\"));\n  },\n  roundedRect: function roundedRect(x, y, w, h, r) {\n    if (r == null) {\n      r = 0;\n    }\n\n    r = Math.min(r, 0.5 * w, 0.5 * h); // amount to inset control points from corners (see `ellipse`)\n\n    var c = r * (1.0 - KAPPA);\n    this.moveTo(x + r, y);\n    this.lineTo(x + w - r, y);\n    this.bezierCurveTo(x + w - c, y, x + w, y + c, x + w, y + r);\n    this.lineTo(x + w, y + h - r);\n    this.bezierCurveTo(x + w, y + h - c, x + w - c, y + h, x + w - r, y + h);\n    this.lineTo(x + r, y + h);\n    this.bezierCurveTo(x + c, y + h, x, y + h - c, x, y + h - r);\n    this.lineTo(x, y + r);\n    this.bezierCurveTo(x, y + c, x + c, y, x + r, y);\n    return this.closePath();\n  },\n  ellipse: function ellipse(x, y, r1, r2) {\n    // based on http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084\n    if (r2 == null) {\n      r2 = r1;\n    }\n\n    x -= r1;\n    y -= r2;\n    var ox = r1 * KAPPA;\n    var oy = r2 * KAPPA;\n    var xe = x + r1 * 2;\n    var ye = y + r2 * 2;\n    var xm = x + r1;\n    var ym = y + r2;\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    return this.closePath();\n  },\n  circle: function circle(x, y, radius) {\n    return this.ellipse(x, y, radius);\n  },\n  arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise == null) {\n      anticlockwise = false;\n    }\n\n    var TWO_PI = 2.0 * Math.PI;\n    var HALF_PI = 0.5 * Math.PI;\n    var deltaAng = endAngle - startAngle;\n\n    if (Math.abs(deltaAng) > TWO_PI) {\n      // draw only full circle if more than that is specified\n      deltaAng = TWO_PI;\n    } else if (deltaAng !== 0 && anticlockwise !== deltaAng < 0) {\n      // necessary to flip direction of rendering\n      var dir = anticlockwise ? -1 : 1;\n      deltaAng = dir * TWO_PI + deltaAng;\n    }\n\n    var numSegs = Math.ceil(Math.abs(deltaAng) / HALF_PI);\n    var segAng = deltaAng / numSegs;\n    var handleLen = segAng / HALF_PI * KAPPA * radius;\n    var curAng = startAngle; // component distances between anchor point and control point\n\n    var deltaCx = -Math.sin(curAng) * handleLen;\n    var deltaCy = Math.cos(curAng) * handleLen; // anchor point\n\n    var ax = x + Math.cos(curAng) * radius;\n    var ay = y + Math.sin(curAng) * radius; // calculate and render segments\n\n    this.moveTo(ax, ay);\n\n    for (var segIdx = 0; segIdx < numSegs; segIdx++) {\n      // starting control point\n      var cp1x = ax + deltaCx;\n      var cp1y = ay + deltaCy; // step angle\n\n      curAng += segAng; // next anchor point\n\n      ax = x + Math.cos(curAng) * radius;\n      ay = y + Math.sin(curAng) * radius; // next control point delta\n\n      deltaCx = -Math.sin(curAng) * handleLen;\n      deltaCy = Math.cos(curAng) * handleLen; // ending control point\n\n      var cp2x = ax - deltaCx;\n      var cp2y = ay - deltaCy; // render segment\n\n      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ax, ay);\n    }\n\n    return this;\n  },\n  polygon: function polygon() {\n    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n\n    this.moveTo.apply(this, _toConsumableArray(points.shift() || []));\n\n    for (var _i = 0, _points = points; _i < _points.length; _i++) {\n      var point = _points[_i];\n      this.lineTo.apply(this, _toConsumableArray(point || []));\n    }\n\n    return this.closePath();\n  },\n  path: function path(_path) {\n    SVGPath.apply(this, _path);\n    return this;\n  },\n  _windingRule: function _windingRule(rule) {\n    if (/even-?odd/.test(rule)) {\n      return '*';\n    }\n\n    return '';\n  },\n  fill: function fill(color, rule) {\n    if (/(even-?odd)|(non-?zero)/.test(color)) {\n      rule = color;\n      color = null;\n    }\n\n    if (color) {\n      this.fillColor(color);\n    }\n\n    return this.addContent(\"f\".concat(this._windingRule(rule)));\n  },\n  stroke: function stroke(color) {\n    if (color) {\n      this.strokeColor(color);\n    }\n\n    return this.addContent('S');\n  },\n  fillAndStroke: function fillAndStroke(fillColor, strokeColor, rule) {\n    if (strokeColor == null) {\n      strokeColor = fillColor;\n    }\n\n    var isFillRule = /(even-?odd)|(non-?zero)/;\n\n    if (isFillRule.test(fillColor)) {\n      rule = fillColor;\n      fillColor = null;\n    }\n\n    if (isFillRule.test(strokeColor)) {\n      rule = strokeColor;\n      strokeColor = fillColor;\n    }\n\n    if (fillColor) {\n      this.fillColor(fillColor);\n      this.strokeColor(strokeColor);\n    }\n\n    return this.addContent(\"B\".concat(this._windingRule(rule)));\n  },\n  clip: function clip(rule) {\n    return this.addContent(\"W\".concat(this._windingRule(rule), \" n\"));\n  },\n  transform: function transform(m11, m12, m21, m22, dx, dy) {\n    // keep track of the current transformation matrix\n    var m = this._ctm;\n\n    var _m = _slicedToArray(m, 6),\n        m0 = _m[0],\n        m1 = _m[1],\n        m2 = _m[2],\n        m3 = _m[3],\n        m4 = _m[4],\n        m5 = _m[5];\n\n    m[0] = m0 * m11 + m2 * m12;\n    m[1] = m1 * m11 + m3 * m12;\n    m[2] = m0 * m21 + m2 * m22;\n    m[3] = m1 * m21 + m3 * m22;\n    m[4] = m0 * dx + m2 * dy + m4;\n    m[5] = m1 * dx + m3 * dy + m5;\n    var values = [m11, m12, m21, m22, dx, dy].map(function (v) {\n      return number$1(v);\n    }).join(' ');\n    return this.addContent(\"\".concat(values, \" cm\"));\n  },\n  translate: function translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  },\n  rotate: function rotate(angle) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var y;\n    var rad = angle * Math.PI / 180;\n    var cos = Math.cos(rad);\n    var sin = Math.sin(rad);\n    var x = y = 0;\n\n    if (options.origin != null) {\n      var _options$origin = _slicedToArray(options.origin, 2);\n\n      x = _options$origin[0];\n      y = _options$origin[1];\n      var x1 = x * cos - y * sin;\n      var y1 = x * sin + y * cos;\n      x -= x1;\n      y -= y1;\n    }\n\n    return this.transform(cos, sin, -sin, cos, x, y);\n  },\n  scale: function scale(xFactor, yFactor) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var y;\n\n    if (yFactor == null) {\n      yFactor = xFactor;\n    }\n\n    if (typeof yFactor === 'object') {\n      options = yFactor;\n      yFactor = xFactor;\n    }\n\n    var x = y = 0;\n\n    if (options.origin != null) {\n      var _options$origin2 = _slicedToArray(options.origin, 2);\n\n      x = _options$origin2[0];\n      y = _options$origin2[1];\n      x -= xFactor * x;\n      y -= yFactor * y;\n    }\n\n    return this.transform(xFactor, 0, 0, yFactor, x, y);\n  }\n};\n\nvar WIN_ANSI_MAP = {\n  402: 131,\n  8211: 150,\n  8212: 151,\n  8216: 145,\n  8217: 146,\n  8218: 130,\n  8220: 147,\n  8221: 148,\n  8222: 132,\n  8224: 134,\n  8225: 135,\n  8226: 149,\n  8230: 133,\n  8364: 128,\n  8240: 137,\n  8249: 139,\n  8250: 155,\n  710: 136,\n  8482: 153,\n  338: 140,\n  339: 156,\n  732: 152,\n  352: 138,\n  353: 154,\n  376: 159,\n  381: 142,\n  382: 158\n};\nvar characters = \".notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n.notdef       .notdef        .notdef        .notdef\\n  \\nspace         exclam         quotedbl       numbersign\\ndollar        percent        ampersand      quotesingle\\nparenleft     parenright     asterisk       plus\\ncomma         hyphen         period         slash\\nzero          one            two            three\\nfour          five           six            seven\\neight         nine           colon          semicolon\\nless          equal          greater        question\\n  \\nat            A              B              C\\nD             E              F              G\\nH             I              J              K\\nL             M              N              O\\nP             Q              R              S\\nT             U              V              W\\nX             Y              Z              bracketleft\\nbackslash     bracketright   asciicircum    underscore\\n  \\ngrave         a              b              c\\nd             e              f              g\\nh             i              j              k\\nl             m              n              o\\np             q              r              s\\nt             u              v              w\\nx             y              z              braceleft\\nbar           braceright     asciitilde     .notdef\\n  \\nEuro          .notdef        quotesinglbase florin\\nquotedblbase  ellipsis       dagger         daggerdbl\\ncircumflex    perthousand    Scaron         guilsinglleft\\nOE            .notdef        Zcaron         .notdef\\n.notdef       quoteleft      quoteright     quotedblleft\\nquotedblright bullet         endash         emdash\\ntilde         trademark      scaron         guilsinglright\\noe            .notdef        zcaron         ydieresis\\n  \\nspace         exclamdown     cent           sterling\\ncurrency      yen            brokenbar      section\\ndieresis      copyright      ordfeminine    guillemotleft\\nlogicalnot    hyphen         registered     macron\\ndegree        plusminus      twosuperior    threesuperior\\nacute         mu             paragraph      periodcentered\\ncedilla       onesuperior    ordmasculine   guillemotright\\nonequarter    onehalf        threequarters  questiondown\\n  \\nAgrave        Aacute         Acircumflex    Atilde\\nAdieresis     Aring          AE             Ccedilla\\nEgrave        Eacute         Ecircumflex    Edieresis\\nIgrave        Iacute         Icircumflex    Idieresis\\nEth           Ntilde         Ograve         Oacute\\nOcircumflex   Otilde         Odieresis      multiply\\nOslash        Ugrave         Uacute         Ucircumflex\\nUdieresis     Yacute         Thorn          germandbls\\n  \\nagrave        aacute         acircumflex    atilde\\nadieresis     aring          ae             ccedilla\\negrave        eacute         ecircumflex    edieresis\\nigrave        iacute         icircumflex    idieresis\\neth           ntilde         ograve         oacute\\nocircumflex   otilde         odieresis      divide\\noslash        ugrave         uacute         ucircumflex\\nudieresis     yacute         thorn          ydieresis\".split(/\\s+/);\n\nvar AFMFont = /*#__PURE__*/function () {\n  _createClass(AFMFont, null, [{\n    key: \"open\",\n    value: function open(filename) {\n      return new AFMFont(fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(filename, 'utf8'));\n    }\n  }]);\n\n  function AFMFont(contents) {\n    _classCallCheck(this, AFMFont);\n\n    this.contents = contents;\n    this.attributes = {};\n    this.glyphWidths = {};\n    this.boundingBoxes = {};\n    this.kernPairs = {};\n    this.parse(); // todo: remove charWidths since appears to not be used\n\n    this.charWidths = new Array(256);\n\n    for (var char = 0; char <= 255; char++) {\n      this.charWidths[char] = this.glyphWidths[characters[char]];\n    }\n\n    this.bbox = this.attributes['FontBBox'].split(/\\s+/).map(function (e) {\n      return +e;\n    });\n    this.ascender = +(this.attributes['Ascender'] || 0);\n    this.descender = +(this.attributes['Descender'] || 0);\n    this.xHeight = +(this.attributes['XHeight'] || 0);\n    this.capHeight = +(this.attributes['CapHeight'] || 0);\n    this.lineGap = this.bbox[3] - this.bbox[1] - (this.ascender - this.descender);\n  }\n\n  _createClass(AFMFont, [{\n    key: \"parse\",\n    value: function parse() {\n      var section = '';\n\n      var _iterator = _createForOfIteratorHelper(this.contents.split('\\n')),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          var match;\n          var a;\n\n          if (match = line.match(/^Start(\\w+)/)) {\n            section = match[1];\n            continue;\n          } else if (match = line.match(/^End(\\w+)/)) {\n            section = '';\n            continue;\n          }\n\n          switch (section) {\n            case 'FontMetrics':\n              match = line.match(/(^\\w+)\\s+(.*)/);\n              var key = match[1];\n              var value = match[2];\n\n              if (a = this.attributes[key]) {\n                if (!Array.isArray(a)) {\n                  a = this.attributes[key] = [a];\n                }\n\n                a.push(value);\n              } else {\n                this.attributes[key] = value;\n              }\n\n              break;\n\n            case 'CharMetrics':\n              if (!/^CH?\\s/.test(line)) {\n                continue;\n              }\n\n              var name = line.match(/\\bN\\s+(\\.?\\w+)\\s*;/)[1];\n              this.glyphWidths[name] = +line.match(/\\bWX\\s+(\\d+)\\s*;/)[1];\n              break;\n\n            case 'KernPairs':\n              match = line.match(/^KPX\\s+(\\.?\\w+)\\s+(\\.?\\w+)\\s+(-?\\d+)/);\n\n              if (match) {\n                this.kernPairs[match[1] + '\\0' + match[2]] = parseInt(match[3]);\n              }\n\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"encodeText\",\n    value: function encodeText(text) {\n      var res = [];\n\n      for (var i = 0, len = text.length; i < len; i++) {\n        var char = text.charCodeAt(i);\n        char = WIN_ANSI_MAP[char] || char;\n        res.push(char.toString(16));\n      }\n\n      return res;\n    }\n  }, {\n    key: \"glyphsForString\",\n    value: function glyphsForString(string) {\n      var glyphs = [];\n\n      for (var i = 0, len = string.length; i < len; i++) {\n        var charCode = string.charCodeAt(i);\n        glyphs.push(this.characterToGlyph(charCode));\n      }\n\n      return glyphs;\n    }\n  }, {\n    key: \"characterToGlyph\",\n    value: function characterToGlyph(character) {\n      return characters[WIN_ANSI_MAP[character] || character] || '.notdef';\n    }\n  }, {\n    key: \"widthOfGlyph\",\n    value: function widthOfGlyph(glyph) {\n      return this.glyphWidths[glyph] || 0;\n    }\n  }, {\n    key: \"getKernPair\",\n    value: function getKernPair(left, right) {\n      return this.kernPairs[left + '\\0' + right] || 0;\n    }\n  }, {\n    key: \"advancesForGlyphs\",\n    value: function advancesForGlyphs(glyphs) {\n      var advances = [];\n\n      for (var index = 0; index < glyphs.length; index++) {\n        var left = glyphs[index];\n        var right = glyphs[index + 1];\n        advances.push(this.widthOfGlyph(left) + this.getKernPair(left, right));\n      }\n\n      return advances;\n    }\n  }]);\n\n  return AFMFont;\n}();\n\nvar PDFFont = /*#__PURE__*/function () {\n  function PDFFont() {\n    _classCallCheck(this, PDFFont);\n  }\n\n  _createClass(PDFFont, [{\n    key: \"encode\",\n    value: function encode() {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }, {\n    key: \"widthOfString\",\n    value: function widthOfString() {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.embedded || this.dictionary == null) {\n        return;\n      }\n\n      this.embed();\n      return this.embedded = true;\n    }\n  }, {\n    key: \"embed\",\n    value: function embed() {\n      throw new Error('Must be implemented by subclasses');\n    }\n  }, {\n    key: \"lineHeight\",\n    value: function lineHeight(size, includeGap) {\n      if (includeGap == null) {\n        includeGap = false;\n      }\n\n      var gap = includeGap ? this.lineGap : 0;\n      return (this.ascender + gap - this.descender) / 1000 * size;\n    }\n  }]);\n\n  return PDFFont;\n}();\n\nvar STANDARD_FONTS = {\n  Courier: function Courier() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Courier.afm', 'utf8');\n  },\n  'Courier-Bold': function CourierBold() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Courier-Bold.afm', 'utf8');\n  },\n  'Courier-Oblique': function CourierOblique() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Courier-Oblique.afm', 'utf8');\n  },\n  'Courier-BoldOblique': function CourierBoldOblique() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Courier-BoldOblique.afm', 'utf8');\n  },\n  Helvetica: function Helvetica() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Helvetica.afm', 'utf8');\n  },\n  'Helvetica-Bold': function HelveticaBold() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Helvetica-Bold.afm', 'utf8');\n  },\n  'Helvetica-Oblique': function HelveticaOblique() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Helvetica-Oblique.afm', 'utf8');\n  },\n  'Helvetica-BoldOblique': function HelveticaBoldOblique() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Helvetica-BoldOblique.afm', 'utf8');\n  },\n  'Times-Roman': function TimesRoman() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Times-Roman.afm', 'utf8');\n  },\n  'Times-Bold': function TimesBold() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Times-Bold.afm', 'utf8');\n  },\n  'Times-Italic': function TimesItalic() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Times-Italic.afm', 'utf8');\n  },\n  'Times-BoldItalic': function TimesBoldItalic() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Times-BoldItalic.afm', 'utf8');\n  },\n  Symbol: function Symbol() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/Symbol.afm', 'utf8');\n  },\n  ZapfDingbats: function ZapfDingbats() {\n    return fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(__dirname + '/data/ZapfDingbats.afm', 'utf8');\n  }\n};\n\nvar StandardFont = /*#__PURE__*/function (_PDFFont) {\n  _inherits(StandardFont, _PDFFont);\n\n  var _super = _createSuper(StandardFont);\n\n  function StandardFont(document, name, id) {\n    var _this;\n\n    _classCallCheck(this, StandardFont);\n\n    _this = _super.call(this);\n    _this.document = document;\n    _this.name = name;\n    _this.id = id;\n    _this.font = new AFMFont(STANDARD_FONTS[_this.name]());\n    var _this$font = _this.font;\n    _this.ascender = _this$font.ascender;\n    _this.descender = _this$font.descender;\n    _this.bbox = _this$font.bbox;\n    _this.lineGap = _this$font.lineGap;\n    _this.xHeight = _this$font.xHeight;\n    _this.capHeight = _this$font.capHeight;\n    return _this;\n  }\n\n  _createClass(StandardFont, [{\n    key: \"embed\",\n    value: function embed() {\n      this.dictionary.data = {\n        Type: 'Font',\n        BaseFont: this.name,\n        Subtype: 'Type1',\n        Encoding: 'WinAnsiEncoding'\n      };\n      return this.dictionary.end();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(text) {\n      var encoded = this.font.encodeText(text);\n      var glyphs = this.font.glyphsForString(\"\".concat(text));\n      var advances = this.font.advancesForGlyphs(glyphs);\n      var positions = [];\n\n      for (var i = 0; i < glyphs.length; i++) {\n        var glyph = glyphs[i];\n        positions.push({\n          xAdvance: advances[i],\n          yAdvance: 0,\n          xOffset: 0,\n          yOffset: 0,\n          advanceWidth: this.font.widthOfGlyph(glyph)\n        });\n      }\n\n      return [encoded, positions];\n    }\n  }, {\n    key: \"widthOfString\",\n    value: function widthOfString(string, size) {\n      var glyphs = this.font.glyphsForString(\"\".concat(string));\n      var advances = this.font.advancesForGlyphs(glyphs);\n      var width = 0;\n\n      var _iterator = _createForOfIteratorHelper(advances),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var advance = _step.value;\n          width += advance;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var scale = size / 1000;\n      return width * scale;\n    }\n  }], [{\n    key: \"isStandardFont\",\n    value: function isStandardFont(name) {\n      return name in STANDARD_FONTS;\n    }\n  }]);\n\n  return StandardFont;\n}(PDFFont);\n\nvar toHex = function toHex(num) {\n  return \"0000\".concat(num.toString(16)).slice(-4);\n};\n\nvar EmbeddedFont = /*#__PURE__*/function (_PDFFont) {\n  _inherits(EmbeddedFont, _PDFFont);\n\n  var _super = _createSuper(EmbeddedFont);\n\n  function EmbeddedFont(document, font, id) {\n    var _this;\n\n    _classCallCheck(this, EmbeddedFont);\n\n    _this = _super.call(this);\n    _this.document = document;\n    _this.font = font;\n    _this.id = id;\n    _this.subset = _this.font.createSubset();\n    _this.unicode = [[0]];\n    _this.widths = [_this.font.getGlyph(0).advanceWidth];\n    _this.name = _this.font.postscriptName;\n    _this.scale = 1000 / _this.font.unitsPerEm;\n    _this.ascender = _this.font.ascent * _this.scale;\n    _this.descender = _this.font.descent * _this.scale;\n    _this.xHeight = _this.font.xHeight * _this.scale;\n    _this.capHeight = _this.font.capHeight * _this.scale;\n    _this.lineGap = _this.font.lineGap * _this.scale;\n    _this.bbox = _this.font.bbox;\n\n    if (document.options.fontLayoutCache !== false) {\n      _this.layoutCache = Object.create(null);\n    }\n\n    return _this;\n  }\n\n  _createClass(EmbeddedFont, [{\n    key: \"layoutRun\",\n    value: function layoutRun(text, features) {\n      var run = this.font.layout(text, features); // Normalize position values\n\n      for (var i = 0; i < run.positions.length; i++) {\n        var position = run.positions[i];\n\n        for (var key in position) {\n          position[key] *= this.scale;\n        }\n\n        position.advanceWidth = run.glyphs[i].advanceWidth * this.scale;\n      }\n\n      return run;\n    }\n  }, {\n    key: \"layoutCached\",\n    value: function layoutCached(text) {\n      if (!this.layoutCache) {\n        return this.layoutRun(text);\n      }\n\n      var cached;\n\n      if (cached = this.layoutCache[text]) {\n        return cached;\n      }\n\n      var run = this.layoutRun(text);\n      this.layoutCache[text] = run;\n      return run;\n    }\n  }, {\n    key: \"layout\",\n    value: function layout(text, features, onlyWidth) {\n      // Skip the cache if any user defined features are applied\n      if (features) {\n        return this.layoutRun(text, features);\n      }\n\n      var glyphs = onlyWidth ? null : [];\n      var positions = onlyWidth ? null : [];\n      var advanceWidth = 0; // Split the string by words to increase cache efficiency.\n      // For this purpose, spaces and tabs are a good enough delimeter.\n\n      var last = 0;\n      var index = 0;\n\n      while (index <= text.length) {\n        var needle;\n\n        if (index === text.length && last < index || (needle = text.charAt(index), [' ', '\\t'].includes(needle))) {\n          var run = this.layoutCached(text.slice(last, ++index));\n\n          if (!onlyWidth) {\n            glyphs = glyphs.concat(run.glyphs);\n            positions = positions.concat(run.positions);\n          }\n\n          advanceWidth += run.advanceWidth;\n          last = index;\n        } else {\n          index++;\n        }\n      }\n\n      return {\n        glyphs: glyphs,\n        positions: positions,\n        advanceWidth: advanceWidth\n      };\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(text, features) {\n      var _this$layout = this.layout(text, features),\n          glyphs = _this$layout.glyphs,\n          positions = _this$layout.positions;\n\n      var res = [];\n\n      for (var i = 0; i < glyphs.length; i++) {\n        var glyph = glyphs[i];\n        var gid = this.subset.includeGlyph(glyph.id);\n        res.push(\"0000\".concat(gid.toString(16)).slice(-4));\n\n        if (this.widths[gid] == null) {\n          this.widths[gid] = glyph.advanceWidth * this.scale;\n        }\n\n        if (this.unicode[gid] == null) {\n          this.unicode[gid] = glyph.codePoints;\n        }\n      }\n\n      return [res, positions];\n    }\n  }, {\n    key: \"widthOfString\",\n    value: function widthOfString(string, size, features) {\n      var width = this.layout(string, features, true).advanceWidth;\n      var scale = size / 1000;\n      return width * scale;\n    }\n  }, {\n    key: \"embed\",\n    value: function embed() {\n      var _this2 = this;\n\n      var isCFF = this.subset.cff != null;\n      var fontFile = this.document.ref();\n\n      if (isCFF) {\n        fontFile.data.Subtype = 'CIDFontType0C';\n      }\n\n      this.subset.encodeStream().on('data', function (data) {\n        return fontFile.write(data);\n      }).on('end', function () {\n        return fontFile.end();\n      });\n      var familyClass = ((this.font['OS/2'] != null ? this.font['OS/2'].sFamilyClass : undefined) || 0) >> 8;\n      var flags = 0;\n\n      if (this.font.post.isFixedPitch) {\n        flags |= 1 << 0;\n      }\n\n      if (1 <= familyClass && familyClass <= 7) {\n        flags |= 1 << 1;\n      }\n\n      flags |= 1 << 2; // assume the font uses non-latin characters\n\n      if (familyClass === 10) {\n        flags |= 1 << 3;\n      }\n\n      if (this.font.head.macStyle.italic) {\n        flags |= 1 << 6;\n      } // generate a tag (6 uppercase letters. 17 is the char code offset from '0' to 'A'. 73 will map to 'Z')\n\n\n      var tag = [1, 2, 3, 4, 5, 6].map(function (i) {\n        return String.fromCharCode((_this2.id.charCodeAt(i) || 73) + 17);\n      }).join('');\n      var name = tag + '+' + this.font.postscriptName;\n      var bbox = this.font.bbox;\n      var descriptor = this.document.ref({\n        Type: 'FontDescriptor',\n        FontName: name,\n        Flags: flags,\n        FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],\n        ItalicAngle: this.font.italicAngle,\n        Ascent: this.ascender,\n        Descent: this.descender,\n        CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,\n        XHeight: (this.font.xHeight || 0) * this.scale,\n        StemV: 0\n      }); // not sure how to calculate this\n\n      if (isCFF) {\n        descriptor.data.FontFile3 = fontFile;\n      } else {\n        descriptor.data.FontFile2 = fontFile;\n      }\n\n      if (this.document.subset) {\n        var CIDSet = Buffer.from('FFFFFFFFC0', 'hex');\n        var CIDSetRef = this.document.ref();\n        CIDSetRef.write(CIDSet);\n        CIDSetRef.end();\n        descriptor.data.CIDSet = CIDSetRef;\n      }\n\n      descriptor.end();\n      var descendantFontData = {\n        Type: 'Font',\n        Subtype: 'CIDFontType0',\n        BaseFont: name,\n        CIDSystemInfo: {\n          Registry: new String('Adobe'),\n          Ordering: new String('Identity'),\n          Supplement: 0\n        },\n        FontDescriptor: descriptor,\n        W: [0, this.widths]\n      };\n\n      if (!isCFF) {\n        descendantFontData.Subtype = 'CIDFontType2';\n        descendantFontData.CIDToGIDMap = 'Identity';\n      }\n\n      var descendantFont = this.document.ref(descendantFontData);\n      descendantFont.end();\n      this.dictionary.data = {\n        Type: 'Font',\n        Subtype: 'Type0',\n        BaseFont: name,\n        Encoding: 'Identity-H',\n        DescendantFonts: [descendantFont],\n        ToUnicode: this.toUnicodeCmap()\n      };\n      return this.dictionary.end();\n    } // Maps the glyph ids encoded in the PDF back to unicode strings\n    // Because of ligature substitutions and the like, there may be one or more\n    // unicode characters represented by each glyph.\n\n  }, {\n    key: \"toUnicodeCmap\",\n    value: function toUnicodeCmap() {\n      var cmap = this.document.ref();\n      var entries = [];\n\n      var _iterator = _createForOfIteratorHelper(this.unicode),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var codePoints = _step.value;\n          var encoded = []; // encode codePoints to utf16\n\n          var _iterator2 = _createForOfIteratorHelper(codePoints),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var value = _step2.value;\n\n              if (value > 0xffff) {\n                value -= 0x10000;\n                encoded.push(toHex(value >>> 10 & 0x3ff | 0xd800));\n                value = 0xdc00 | value & 0x3ff;\n              }\n\n              encoded.push(toHex(value));\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          entries.push(\"<\".concat(encoded.join(' '), \">\"));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      cmap.end(\"/CIDInit /ProcSet findresource begin\\n12 dict begin\\nbegincmap\\n/CIDSystemInfo <<\\n  /Registry (Adobe)\\n  /Ordering (UCS)\\n  /Supplement 0\\n>> def\\n/CMapName /Adobe-Identity-UCS def\\n/CMapType 2 def\\n1 begincodespacerange\\n<0000><ffff>\\nendcodespacerange\\n1 beginbfrange\\n<0000> <\".concat(toHex(entries.length - 1), \"> [\").concat(entries.join(' '), \"]\\nendbfrange\\nendcmap\\nCMapName currentdict /CMap defineresource pop\\nend\\nend\"));\n      return cmap;\n    }\n  }]);\n\n  return EmbeddedFont;\n}(PDFFont);\n\nvar PDFFontFactory = /*#__PURE__*/function () {\n  function PDFFontFactory() {\n    _classCallCheck(this, PDFFontFactory);\n  }\n\n  _createClass(PDFFontFactory, null, [{\n    key: \"open\",\n    value: function open(document, src, family, id) {\n      var font;\n\n      if (typeof src === 'string') {\n        if (StandardFont.isStandardFont(src)) {\n          return new StandardFont(document, src, id);\n        }\n\n        src = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(src);\n      }\n\n      if (Buffer.isBuffer(src)) {\n        font = fontkit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(src, family);\n      } else if (src instanceof Uint8Array) {\n        font = fontkit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(Buffer.from(src), family);\n      } else if (src instanceof ArrayBuffer) {\n        font = fontkit__WEBPACK_IMPORTED_MODULE_4__[\"default\"].create(Buffer.from(new Uint8Array(src)), family);\n      }\n\n      if (font == null) {\n        throw new Error('Not a supported font format or standard PDF font.');\n      }\n\n      return new EmbeddedFont(document, font, id);\n    }\n  }]);\n\n  return PDFFontFactory;\n}();\n\nvar FontsMixin = {\n  initFonts: function initFonts() {\n    var defaultFont = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Helvetica';\n    // Lookup table for embedded fonts\n    this._fontFamilies = {};\n    this._fontCount = 0; // Font state\n\n    this._fontSize = 12;\n    this._font = null;\n    this._registeredFonts = {}; // Set the default font\n\n    if (defaultFont) {\n      this.font(defaultFont);\n    }\n  },\n  font: function font(src, family, size) {\n    var cacheKey, font;\n\n    if (typeof family === 'number') {\n      size = family;\n      family = null;\n    } // check registered fonts if src is a string\n\n\n    if (typeof src === 'string' && this._registeredFonts[src]) {\n      cacheKey = src;\n      var _this$_registeredFont = this._registeredFonts[src];\n      src = _this$_registeredFont.src;\n      family = _this$_registeredFont.family;\n    } else {\n      cacheKey = family || src;\n\n      if (typeof cacheKey !== 'string') {\n        cacheKey = null;\n      }\n    }\n\n    if (size != null) {\n      this.fontSize(size);\n    } // fast path: check if the font is already in the PDF\n\n\n    if (font = this._fontFamilies[cacheKey]) {\n      this._font = font;\n      return this;\n    } // load the font\n\n\n    var id = \"F\".concat(++this._fontCount);\n    this._font = PDFFontFactory.open(this, src, family, id); // check for existing font familes with the same name already in the PDF\n    // useful if the font was passed as a buffer\n\n    if (font = this._fontFamilies[this._font.name]) {\n      this._font = font;\n      return this;\n    } // save the font for reuse later\n\n\n    if (cacheKey) {\n      this._fontFamilies[cacheKey] = this._font;\n    }\n\n    if (this._font.name) {\n      this._fontFamilies[this._font.name] = this._font;\n    }\n\n    return this;\n  },\n  fontSize: function fontSize(_fontSize) {\n    this._fontSize = _fontSize;\n    return this;\n  },\n  currentLineHeight: function currentLineHeight(includeGap) {\n    if (includeGap == null) {\n      includeGap = false;\n    }\n\n    return this._font.lineHeight(this._fontSize, includeGap);\n  },\n  registerFont: function registerFont(name, src, family) {\n    this._registeredFonts[name] = {\n      src: src,\n      family: family\n    };\n    return this;\n  }\n};\n\nvar LineWrapper = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(LineWrapper, _EventEmitter);\n\n  var _super = _createSuper(LineWrapper);\n\n  function LineWrapper(document, options) {\n    var _this;\n\n    _classCallCheck(this, LineWrapper);\n\n    _this = _super.call(this);\n    _this.document = document;\n    _this.indent = options.indent || 0;\n    _this.characterSpacing = options.characterSpacing || 0;\n    _this.wordSpacing = options.wordSpacing === 0;\n    _this.columns = options.columns || 1;\n    _this.columnGap = options.columnGap != null ? options.columnGap : 18; // 1/4 inch\n\n    _this.lineWidth = (options.width - _this.columnGap * (_this.columns - 1)) / _this.columns;\n    _this.spaceLeft = _this.lineWidth;\n    _this.startX = _this.document.x;\n    _this.startY = _this.document.y;\n    _this.column = 1;\n    _this.ellipsis = options.ellipsis;\n    _this.continuedX = 0;\n    _this.features = options.features; // calculate the maximum Y position the text can appear at\n\n    if (options.height != null) {\n      _this.height = options.height;\n      _this.maxY = _this.startY + options.height;\n    } else {\n      _this.maxY = _this.document.page.maxY();\n    } // handle paragraph indents\n\n\n    _this.on('firstLine', function (options) {\n      // if this is the first line of the text segment, and\n      // we're continuing where we left off, indent that much\n      // otherwise use the user specified indent option\n      var indent = _this.continuedX || _this.indent;\n      _this.document.x += indent;\n      _this.lineWidth -= indent;\n      return _this.once('line', function () {\n        _this.document.x -= indent;\n        _this.lineWidth += indent;\n\n        if (options.continued && !_this.continuedX) {\n          _this.continuedX = _this.indent;\n        }\n\n        if (!options.continued) {\n          return _this.continuedX = 0;\n        }\n      });\n    }); // handle left aligning last lines of paragraphs\n\n\n    _this.on('lastLine', function (options) {\n      var align = options.align;\n\n      if (align === 'justify') {\n        options.align = 'left';\n      }\n\n      _this.lastLine = true;\n      return _this.once('line', function () {\n        _this.document.y += options.paragraphGap || 0;\n        options.align = align;\n        return _this.lastLine = false;\n      });\n    });\n\n    return _this;\n  }\n\n  _createClass(LineWrapper, [{\n    key: \"wordWidth\",\n    value: function wordWidth(word) {\n      return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;\n    }\n  }, {\n    key: \"eachWord\",\n    value: function eachWord(text, fn) {\n      // setup a unicode line breaker\n      var bk;\n      var breaker = new linebreak__WEBPACK_IMPORTED_MODULE_6__[\"default\"](text);\n      var last = null;\n      var wordWidths = Object.create(null);\n\n      while (bk = breaker.nextBreak()) {\n        var shouldContinue;\n        var word = text.slice((last != null ? last.position : undefined) || 0, bk.position);\n        var w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word); // if the word is longer than the whole line, chop it up\n        // TODO: break by grapheme clusters, not JS string characters\n\n        if (w > this.lineWidth + this.continuedX) {\n          // make some fake break objects\n          var lbk = last;\n          var fbk = {};\n\n          while (word.length) {\n            // fit as much of the word as possible into the space we have\n            var l, mightGrow;\n\n            if (w > this.spaceLeft) {\n              // start our check at the end of our available space - this method is faster than a loop of each character and it resolves\n              // an issue with long loops when processing massive words, such as a huge number of spaces\n              l = Math.ceil(this.spaceLeft / (w / word.length));\n              w = this.wordWidth(word.slice(0, l));\n              mightGrow = w <= this.spaceLeft && l < word.length;\n            } else {\n              l = word.length;\n            }\n\n            var mustShrink = w > this.spaceLeft && l > 0; // shrink or grow word as necessary after our near-guess above\n\n            while (mustShrink || mightGrow) {\n              if (mustShrink) {\n                w = this.wordWidth(word.slice(0, --l));\n                mustShrink = w > this.spaceLeft && l > 0;\n              } else {\n                w = this.wordWidth(word.slice(0, ++l));\n                mustShrink = w > this.spaceLeft && l > 0;\n                mightGrow = w <= this.spaceLeft && l < word.length;\n              }\n            } // check for the edge case where a single character cannot fit into a line.\n\n\n            if (l === 0 && this.spaceLeft === this.lineWidth) {\n              l = 1;\n            } // send a required break unless this is the last piece and a linebreak is not specified\n\n\n            fbk.required = bk.required || l < word.length;\n            shouldContinue = fn(word.slice(0, l), w, fbk, lbk);\n            lbk = {\n              required: false\n            }; // get the remaining piece of the word\n\n            word = word.slice(l);\n            w = this.wordWidth(word);\n\n            if (shouldContinue === false) {\n              break;\n            }\n          }\n        } else {\n          // otherwise just emit the break as it was given to us\n          shouldContinue = fn(word, w, bk, last);\n        }\n\n        if (shouldContinue === false) {\n          break;\n        }\n\n        last = bk;\n      }\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(text, options) {\n      var _this2 = this;\n\n      // override options from previous continued fragments\n      if (options.indent != null) {\n        this.indent = options.indent;\n      }\n\n      if (options.characterSpacing != null) {\n        this.characterSpacing = options.characterSpacing;\n      }\n\n      if (options.wordSpacing != null) {\n        this.wordSpacing = options.wordSpacing;\n      }\n\n      if (options.ellipsis != null) {\n        this.ellipsis = options.ellipsis;\n      } // make sure we're actually on the page\n      // and that the first line of is never by\n      // itself at the bottom of a page (orphans)\n\n\n      var nextY = this.document.y + this.document.currentLineHeight(true);\n\n      if (this.document.y > this.maxY || nextY > this.maxY) {\n        this.nextSection();\n      }\n\n      var buffer = '';\n      var textWidth = 0;\n      var wc = 0;\n      var lc = 0;\n      var y = this.document.y; // used to reset Y pos if options.continued (below)\n\n      var emitLine = function emitLine() {\n        options.textWidth = textWidth + _this2.wordSpacing * (wc - 1);\n        options.wordCount = wc;\n        options.lineWidth = _this2.lineWidth;\n        y = _this2.document.y;\n\n        _this2.emit('line', buffer, options, _this2);\n\n        return lc++;\n      };\n\n      this.emit('sectionStart', options, this);\n      this.eachWord(text, function (word, w, bk, last) {\n        if (last == null || last.required) {\n          _this2.emit('firstLine', options, _this2);\n\n          _this2.spaceLeft = _this2.lineWidth;\n        }\n\n        if (w <= _this2.spaceLeft) {\n          buffer += word;\n          textWidth += w;\n          wc++;\n        }\n\n        if (bk.required || w > _this2.spaceLeft) {\n          // if the user specified a max height and an ellipsis, and is about to pass the\n          // max height and max columns after the next line, append the ellipsis\n          var lh = _this2.document.currentLineHeight(true);\n\n          if (_this2.height != null && _this2.ellipsis && _this2.document.y + lh * 2 > _this2.maxY && _this2.column >= _this2.columns) {\n            if (_this2.ellipsis === true) {\n              _this2.ellipsis = '';\n            } // map default ellipsis character\n\n\n            buffer = buffer.replace(/\\s+$/, '');\n            textWidth = _this2.wordWidth(buffer + _this2.ellipsis); // remove characters from the buffer until the ellipsis fits\n            // to avoid infinite loop need to stop while-loop if buffer is empty string\n\n            while (buffer && textWidth > _this2.lineWidth) {\n              buffer = buffer.slice(0, -1).replace(/\\s+$/, '');\n              textWidth = _this2.wordWidth(buffer + _this2.ellipsis);\n            } // need to add ellipsis only if there is enough space for it\n\n\n            if (textWidth <= _this2.lineWidth) {\n              buffer = buffer + _this2.ellipsis;\n            }\n\n            textWidth = _this2.wordWidth(buffer);\n          }\n\n          if (bk.required) {\n            if (w > _this2.spaceLeft) {\n              emitLine();\n              buffer = word;\n              textWidth = w;\n              wc = 1;\n            }\n\n            _this2.emit('lastLine', options, _this2);\n          }\n\n          emitLine(); // if we've reached the edge of the page,\n          // continue on a new page or column\n\n          if (_this2.document.y + lh > _this2.maxY) {\n            var shouldContinue = _this2.nextSection(); // stop if we reached the maximum height\n\n\n            if (!shouldContinue) {\n              wc = 0;\n              buffer = '';\n              return false;\n            }\n          } // reset the space left and buffer\n\n\n          if (bk.required) {\n            _this2.spaceLeft = _this2.lineWidth;\n            buffer = '';\n            textWidth = 0;\n            return wc = 0;\n          } else {\n            // reset the space left and buffer\n            _this2.spaceLeft = _this2.lineWidth - w;\n            buffer = word;\n            textWidth = w;\n            return wc = 1;\n          }\n        } else {\n          return _this2.spaceLeft -= w;\n        }\n      });\n\n      if (wc > 0) {\n        this.emit('lastLine', options, this);\n        emitLine();\n      }\n\n      this.emit('sectionEnd', options, this); // if the wrap is set to be continued, save the X position\n      // to start the first line of the next segment at, and reset\n      // the y position\n\n      if (options.continued === true) {\n        if (lc > 1) {\n          this.continuedX = 0;\n        }\n\n        this.continuedX += options.textWidth || 0;\n        return this.document.y = y;\n      } else {\n        return this.document.x = this.startX;\n      }\n    }\n  }, {\n    key: \"nextSection\",\n    value: function nextSection(options) {\n      this.emit('sectionEnd', options, this);\n\n      if (++this.column > this.columns) {\n        // if a max height was specified by the user, we're done.\n        // otherwise, the default is to make a new page at the bottom.\n        if (this.height != null) {\n          return false;\n        }\n\n        this.document.continueOnNewPage();\n        this.column = 1;\n        this.startY = this.document.page.margins.top;\n        this.maxY = this.document.page.maxY();\n        this.document.x = this.startX;\n\n        if (this.document._fillColor) {\n          var _this$document;\n\n          (_this$document = this.document).fillColor.apply(_this$document, _toConsumableArray(this.document._fillColor));\n        }\n\n        this.emit('pageBreak', options, this);\n      } else {\n        this.document.x += this.lineWidth + this.columnGap;\n        this.document.y = this.startY;\n        this.emit('columnBreak', options, this);\n      }\n\n      this.emit('sectionStart', options, this);\n      return true;\n    }\n  }]);\n\n  return LineWrapper;\n}(events__WEBPACK_IMPORTED_MODULE_5__.EventEmitter);\n\nvar number$2 = PDFObject.number;\nvar TextMixin = {\n  initText: function initText() {\n    this._line = this._line.bind(this); // Current coordinates\n\n    this.x = 0;\n    this.y = 0;\n    return this._lineGap = 0;\n  },\n  lineGap: function lineGap(_lineGap) {\n    this._lineGap = _lineGap;\n    return this;\n  },\n  moveDown: function moveDown(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n\n    this.y += this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  moveUp: function moveUp(lines) {\n    if (lines == null) {\n      lines = 1;\n    }\n\n    this.y -= this.currentLineHeight(true) * lines + this._lineGap;\n    return this;\n  },\n  _text: function _text(text, x, y, options, lineCallback) {\n    var _this = this;\n\n    options = this._initOptions(x, y, options); // Convert text to a string\n\n    text = text == null ? '' : \"\".concat(text); // if the wordSpacing option is specified, remove multiple consecutive spaces\n\n    if (options.wordSpacing) {\n      text = text.replace(/\\s{2,}/g, ' ');\n    }\n\n    var addStructure = function addStructure() {\n      if (options.structParent) {\n        options.structParent.add(_this.struct(options.structType || 'P', [_this.markStructureContent(options.structType || 'P')]));\n      }\n    }; // word wrapping\n\n\n    if (options.width) {\n      var wrapper = this._wrapper;\n\n      if (!wrapper) {\n        wrapper = new LineWrapper(this, options);\n        wrapper.on('line', lineCallback);\n        wrapper.on('firstLine', addStructure);\n      }\n\n      this._wrapper = options.continued ? wrapper : null;\n      this._textOptions = options.continued ? options : null;\n      wrapper.wrap(text, options); // render paragraphs as single lines\n    } else {\n      var _iterator = _createForOfIteratorHelper(text.split('\\n')),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          addStructure();\n          lineCallback(line, options);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return this;\n  },\n  text: function text(_text2, x, y, options) {\n    return this._text(_text2, x, y, options, this._line);\n  },\n  widthOfString: function widthOfString(string) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);\n  },\n  heightOfString: function heightOfString(text, options) {\n    var _this2 = this;\n\n    var x = this.x,\n        y = this.y;\n    options = this._initOptions(options);\n    options.height = Infinity; // don't break pages\n\n    var lineGap = options.lineGap || this._lineGap || 0;\n\n    this._text(text, this.x, this.y, options, function () {\n      return _this2.y += _this2.currentLineHeight(true) + lineGap;\n    });\n\n    var height = this.y - y;\n    this.x = x;\n    this.y = y;\n    return height;\n  },\n  list: function list(_list, x, y, options, wrapper) {\n    var _this3 = this;\n\n    options = this._initOptions(x, y, options);\n    var listType = options.listType || 'bullet';\n    var unit = Math.round(this._font.ascender / 1000 * this._fontSize);\n    var midLine = unit / 2;\n    var r = options.bulletRadius || unit / 3;\n    var indent = options.textIndent || (listType === 'bullet' ? r * 5 : unit * 2);\n    var itemIndent = options.bulletIndent || (listType === 'bullet' ? r * 8 : unit * 2);\n    var level = 1;\n    var items = [];\n    var levels = [];\n    var numbers = [];\n\n    var flatten = function flatten(list) {\n      var n = 1;\n\n      for (var _i = 0; _i < list.length; _i++) {\n        var item = list[_i];\n\n        if (Array.isArray(item)) {\n          level++;\n          flatten(item);\n          level--;\n        } else {\n          items.push(item);\n          levels.push(level);\n\n          if (listType !== 'bullet') {\n            numbers.push(n++);\n          }\n        }\n      }\n    };\n\n    flatten(_list);\n\n    var label = function label(n) {\n      switch (listType) {\n        case 'numbered':\n          return \"\".concat(n, \".\");\n\n        case 'lettered':\n          var letter = String.fromCharCode((n - 1) % 26 + 65);\n          var times = Math.floor((n - 1) / 26 + 1);\n          var text = Array(times + 1).join(letter);\n          return \"\".concat(text, \".\");\n      }\n    };\n\n    wrapper = new LineWrapper(this, options);\n    wrapper.on('line', this._line);\n    level = 1;\n    var i = 0;\n    wrapper.on('firstLine', function () {\n      var item, itemType, labelType, bodyType;\n\n      if (options.structParent) {\n        if (options.structTypes) {\n          var _options$structTypes = _slicedToArray(options.structTypes, 3);\n\n          itemType = _options$structTypes[0];\n          labelType = _options$structTypes[1];\n          bodyType = _options$structTypes[2];\n        } else {\n          itemType = 'LI';\n          labelType = 'Lbl';\n          bodyType = 'LBody';\n        }\n      }\n\n      if (itemType) {\n        item = _this3.struct(itemType);\n        options.structParent.add(item);\n      } else if (options.structParent) {\n        item = options.structParent;\n      }\n\n      var l;\n\n      if ((l = levels[i++]) !== level) {\n        var diff = itemIndent * (l - level);\n        _this3.x += diff;\n        wrapper.lineWidth -= diff;\n        level = l;\n      }\n\n      if (item && (labelType || bodyType)) {\n        item.add(_this3.struct(labelType || bodyType, [_this3.markStructureContent(labelType || bodyType)]));\n      }\n\n      switch (listType) {\n        case 'bullet':\n          _this3.circle(_this3.x - indent + r, _this3.y + midLine, r);\n\n          _this3.fill();\n\n          break;\n\n        case 'numbered':\n        case 'lettered':\n          var text = label(numbers[i - 1]);\n\n          _this3._fragment(text, _this3.x - indent, _this3.y, options);\n\n          break;\n      }\n\n      if (item && labelType && bodyType) {\n        item.add(_this3.struct(bodyType, [_this3.markStructureContent(bodyType)]));\n      }\n\n      if (item && item !== options.structParent) {\n        item.end();\n      }\n    });\n    wrapper.on('sectionStart', function () {\n      var pos = indent + itemIndent * (level - 1);\n      _this3.x += pos;\n      return wrapper.lineWidth -= pos;\n    });\n    wrapper.on('sectionEnd', function () {\n      var pos = indent + itemIndent * (level - 1);\n      _this3.x -= pos;\n      return wrapper.lineWidth += pos;\n    });\n    wrapper.wrap(items.join('\\n'), options);\n    return this;\n  },\n  _initOptions: function _initOptions() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var y = arguments.length > 1 ? arguments[1] : undefined;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    } // clone options object\n\n\n    var result = Object.assign({}, options); // extend options with previous values for continued text\n\n    if (this._textOptions) {\n      for (var key in this._textOptions) {\n        var val = this._textOptions[key];\n\n        if (key !== 'continued') {\n          if (result[key] === undefined) {\n            result[key] = val;\n          }\n        }\n      }\n    } // Update the current position\n\n\n    if (x != null) {\n      this.x = x;\n    }\n\n    if (y != null) {\n      this.y = y;\n    } // wrap to margins if no x or y position passed\n\n\n    if (result.lineBreak !== false) {\n      if (result.width == null) {\n        result.width = this.page.width - this.x - this.page.margins.right;\n      }\n\n      result.width = Math.max(result.width, 0);\n    }\n\n    if (!result.columns) {\n      result.columns = 0;\n    }\n\n    if (result.columnGap == null) {\n      result.columnGap = 18;\n    } // 1/4 inch\n\n\n    return result;\n  },\n  _line: function _line(text) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var wrapper = arguments.length > 2 ? arguments[2] : undefined;\n\n    this._fragment(text, this.x, this.y, options);\n\n    var lineGap = options.lineGap || this._lineGap || 0;\n\n    if (!wrapper) {\n      return this.x += this.widthOfString(text);\n    } else {\n      return this.y += this.currentLineHeight(true) + lineGap;\n    }\n  },\n  _fragment: function _fragment(text, x, y, options) {\n    var _this4 = this;\n\n    var dy, encoded, i, positions, textWidth, words;\n    text = \"\".concat(text).replace(/\\n/g, '');\n\n    if (text.length === 0) {\n      return;\n    } // handle options\n\n\n    var align = options.align || 'left';\n    var wordSpacing = options.wordSpacing || 0;\n    var characterSpacing = options.characterSpacing || 0; // text alignments\n\n    if (options.width) {\n      switch (align) {\n        case 'right':\n          textWidth = this.widthOfString(text.replace(/\\s+$/, ''), options);\n          x += options.lineWidth - textWidth;\n          break;\n\n        case 'center':\n          x += options.lineWidth / 2 - options.textWidth / 2;\n          break;\n\n        case 'justify':\n          // calculate the word spacing value\n          words = text.trim().split(/\\s+/);\n          textWidth = this.widthOfString(text.replace(/\\s+/g, ''), options);\n          var spaceWidth = this.widthOfString(' ') + characterSpacing;\n          wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);\n          break;\n      }\n    } // text baseline alignments based on http://wiki.apache.org/xmlgraphics-fop/LineLayout/AlignmentHandling\n\n\n    if (typeof options.baseline === 'number') {\n      dy = -options.baseline;\n    } else {\n      switch (options.baseline) {\n        case 'svg-middle':\n          dy = 0.5 * this._font.xHeight;\n          break;\n\n        case 'middle':\n        case 'svg-central':\n          dy = 0.5 * (this._font.descender + this._font.ascender);\n          break;\n\n        case 'bottom':\n        case 'ideographic':\n          dy = this._font.descender;\n          break;\n\n        case 'alphabetic':\n          dy = 0;\n          break;\n\n        case 'mathematical':\n          dy = 0.5 * this._font.ascender;\n          break;\n\n        case 'hanging':\n          dy = 0.8 * this._font.ascender;\n          break;\n\n        case 'top':\n          dy = this._font.ascender;\n          break;\n\n        default:\n          dy = this._font.ascender;\n      }\n\n      dy = dy / 1000 * this._fontSize;\n    } // calculate the actual rendered width of the string after word and character spacing\n\n\n    var renderedWidth = options.textWidth + wordSpacing * (options.wordCount - 1) + characterSpacing * (text.length - 1); // create link annotations if the link option is given\n\n    if (options.link != null) {\n      this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);\n    }\n\n    if (options.goTo != null) {\n      this.goTo(x, y, renderedWidth, this.currentLineHeight(), options.goTo);\n    }\n\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    } // create underline\n\n\n    if (options.underline) {\n      this.save();\n\n      if (!options.stroke) {\n        this.strokeColor.apply(this, _toConsumableArray(this._fillColor || []));\n      }\n\n      var lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n      this.lineWidth(lineWidth);\n      var lineY = y + this.currentLineHeight() - lineWidth;\n      this.moveTo(x, lineY);\n      this.lineTo(x + renderedWidth, lineY);\n      this.stroke();\n      this.restore();\n    } // create strikethrough line\n\n\n    if (options.strike) {\n      this.save();\n\n      if (!options.stroke) {\n        this.strokeColor.apply(this, _toConsumableArray(this._fillColor || []));\n      }\n\n      var _lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);\n\n      this.lineWidth(_lineWidth);\n\n      var _lineY = y + this.currentLineHeight() / 2;\n\n      this.moveTo(x, _lineY);\n      this.lineTo(x + renderedWidth, _lineY);\n      this.stroke();\n      this.restore();\n    }\n\n    this.save(); // oblique (angle in degrees or boolean)\n\n    if (options.oblique) {\n      var skew;\n\n      if (typeof options.oblique === 'number') {\n        skew = -Math.tan(options.oblique * Math.PI / 180);\n      } else {\n        skew = -0.25;\n      }\n\n      this.transform(1, 0, 0, 1, x, y);\n      this.transform(1, 0, skew, 1, -skew * dy, 0);\n      this.transform(1, 0, 0, 1, -x, -y);\n    } // flip coordinate system\n\n\n    this.transform(1, 0, 0, -1, 0, this.page.height);\n    y = this.page.height - y - dy; // add current font to page if necessary\n\n    if (this.page.fonts[this._font.id] == null) {\n      this.page.fonts[this._font.id] = this._font.ref();\n    } // begin the text object\n\n\n    this.addContent('BT'); // text position\n\n    this.addContent(\"1 0 0 1 \".concat(number$2(x), \" \").concat(number$2(y), \" Tm\")); // font and font size\n\n    this.addContent(\"/\".concat(this._font.id, \" \").concat(number$2(this._fontSize), \" Tf\")); // rendering mode\n\n    var mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;\n\n    if (mode) {\n      this.addContent(\"\".concat(mode, \" Tr\"));\n    } // Character spacing\n\n\n    if (characterSpacing) {\n      this.addContent(\"\".concat(number$2(characterSpacing), \" Tc\"));\n    } // Add the actual text\n    // If we have a word spacing value, we need to encode each word separately\n    // since the normal Tw operator only works on character code 32, which isn't\n    // used for embedded fonts.\n\n\n    if (wordSpacing) {\n      words = text.trim().split(/\\s+/);\n      wordSpacing += this.widthOfString(' ') + characterSpacing;\n      wordSpacing *= 1000 / this._fontSize;\n      encoded = [];\n      positions = [];\n\n      var _iterator2 = _createForOfIteratorHelper(words),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var word = _step2.value;\n\n          var _this$_font$encode = this._font.encode(word, options.features),\n              _this$_font$encode2 = _slicedToArray(_this$_font$encode, 2),\n              encodedWord = _this$_font$encode2[0],\n              positionsWord = _this$_font$encode2[1];\n\n          encoded = encoded.concat(encodedWord);\n          positions = positions.concat(positionsWord); // add the word spacing to the end of the word\n          // clone object because of cache\n\n          var space = {};\n          var object = positions[positions.length - 1];\n\n          for (var key in object) {\n            var val = object[key];\n            space[key] = val;\n          }\n\n          space.xAdvance += wordSpacing;\n          positions[positions.length - 1] = space;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else {\n      var _this$_font$encode3 = this._font.encode(text, options.features);\n\n      var _this$_font$encode4 = _slicedToArray(_this$_font$encode3, 2);\n\n      encoded = _this$_font$encode4[0];\n      positions = _this$_font$encode4[1];\n    }\n\n    var scale = this._fontSize / 1000;\n    var commands = [];\n    var last = 0;\n    var hadOffset = false; // Adds a segment of text to the TJ command buffer\n\n    var addSegment = function addSegment(cur) {\n      if (last < cur) {\n        var hex = encoded.slice(last, cur).join('');\n        var advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;\n        commands.push(\"<\".concat(hex, \"> \").concat(number$2(-advance)));\n      }\n\n      return last = cur;\n    }; // Flushes the current TJ commands to the output stream\n\n\n    var flush = function flush(i) {\n      addSegment(i);\n\n      if (commands.length > 0) {\n        _this4.addContent(\"[\".concat(commands.join(' '), \"] TJ\"));\n\n        return commands.length = 0;\n      }\n    };\n\n    for (i = 0; i < positions.length; i++) {\n      // If we have an x or y offset, we have to break out of the current TJ command\n      // so we can move the text position.\n      var pos = positions[i];\n\n      if (pos.xOffset || pos.yOffset) {\n        // Flush the current buffer\n        flush(i); // Move the text position and flush just the current character\n\n        this.addContent(\"1 0 0 1 \".concat(number$2(x + pos.xOffset * scale), \" \").concat(number$2(y + pos.yOffset * scale), \" Tm\"));\n        flush(i + 1);\n        hadOffset = true;\n      } else {\n        // If the last character had an offset, reset the text position\n        if (hadOffset) {\n          this.addContent(\"1 0 0 1 \".concat(number$2(x), \" \").concat(number$2(y), \" Tm\"));\n          hadOffset = false;\n        } // Group segments that don't have any advance adjustments\n\n\n        if (pos.xAdvance - pos.advanceWidth !== 0) {\n          addSegment(i + 1);\n        }\n      }\n\n      x += pos.xAdvance * scale;\n    } // Flush any remaining commands\n\n\n    flush(i); // end the text object\n\n    this.addContent('ET'); // restore flipped coordinate system\n\n    return this.restore();\n  }\n};\n\nvar MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\nvar COLOR_SPACE_MAP = {\n  1: 'DeviceGray',\n  3: 'DeviceRGB',\n  4: 'DeviceCMYK'\n};\n\nvar JPEG = /*#__PURE__*/function () {\n  function JPEG(data, label) {\n    _classCallCheck(this, JPEG);\n\n    var marker;\n    this.data = data;\n    this.label = label;\n\n    if (this.data.readUInt16BE(0) !== 0xffd8) {\n      throw 'SOI not found in JPEG';\n    }\n\n    var pos = 2;\n\n    while (pos < this.data.length) {\n      marker = this.data.readUInt16BE(pos);\n      pos += 2;\n\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n\n      pos += this.data.readUInt16BE(pos);\n    }\n\n    if (!MARKERS.includes(marker)) {\n      throw 'Invalid JPEG.';\n    }\n\n    pos += 2;\n    this.bits = this.data[pos++];\n    this.height = this.data.readUInt16BE(pos);\n    pos += 2;\n    this.width = this.data.readUInt16BE(pos);\n    pos += 2;\n    var channels = this.data[pos++];\n    this.colorSpace = COLOR_SPACE_MAP[channels];\n    this.obj = null;\n  }\n\n  _createClass(JPEG, [{\n    key: \"embed\",\n    value: function embed(document) {\n      if (this.obj) {\n        return;\n      }\n\n      this.obj = document.ref({\n        Type: 'XObject',\n        Subtype: 'Image',\n        BitsPerComponent: this.bits,\n        Width: this.width,\n        Height: this.height,\n        ColorSpace: this.colorSpace,\n        Filter: 'DCTDecode'\n      }); // add extra decode params for CMYK images. By swapping the\n      // min and max values from the default, we invert the colors. See\n      // section 4.8.4 of the spec.\n\n      if (this.colorSpace === 'DeviceCMYK') {\n        this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];\n      }\n\n      this.obj.end(this.data); // free memory\n\n      return this.data = null;\n    }\n  }]);\n\n  return JPEG;\n}();\n\nvar PNGImage = /*#__PURE__*/function () {\n  function PNGImage(data, label) {\n    _classCallCheck(this, PNGImage);\n\n    this.label = label;\n    this.image = new (png_js__WEBPACK_IMPORTED_MODULE_7___default())(data);\n    this.width = this.image.width;\n    this.height = this.image.height;\n    this.imgData = this.image.imgData;\n    this.obj = null;\n  }\n\n  _createClass(PNGImage, [{\n    key: \"embed\",\n    value: function embed(document) {\n      var dataDecoded = false;\n      this.document = document;\n\n      if (this.obj) {\n        return;\n      }\n\n      var hasAlphaChannel = this.image.hasAlphaChannel;\n      var isInterlaced = this.image.interlaceMethod === 1;\n      this.obj = this.document.ref({\n        Type: 'XObject',\n        Subtype: 'Image',\n        BitsPerComponent: hasAlphaChannel ? 8 : this.image.bits,\n        Width: this.width,\n        Height: this.height,\n        Filter: 'FlateDecode'\n      });\n\n      if (!hasAlphaChannel) {\n        var params = this.document.ref({\n          Predictor: isInterlaced ? 1 : 15,\n          Colors: this.image.colors,\n          BitsPerComponent: this.image.bits,\n          Columns: this.width\n        });\n        this.obj.data['DecodeParms'] = params;\n        params.end();\n      }\n\n      if (this.image.palette.length === 0) {\n        this.obj.data['ColorSpace'] = this.image.colorSpace;\n      } else {\n        // embed the color palette in the PDF as an object stream\n        var palette = this.document.ref();\n        palette.end(Buffer.from(this.image.palette)); // build the color space array for the image\n\n        this.obj.data['ColorSpace'] = ['Indexed', 'DeviceRGB', this.image.palette.length / 3 - 1, palette];\n      } // For PNG color types 0, 2 and 3, the transparency data is stored in\n      // a dedicated PNG chunk.\n\n\n      if (this.image.transparency.grayscale != null) {\n        // Use Color Key Masking (spec section 4.8.5)\n        // An array with N elements, where N is two times the number of color components.\n        var val = this.image.transparency.grayscale;\n        this.obj.data['Mask'] = [val, val];\n      } else if (this.image.transparency.rgb) {\n        // Use Color Key Masking (spec section 4.8.5)\n        // An array with N elements, where N is two times the number of color components.\n        var rgb = this.image.transparency.rgb;\n        var mask = [];\n\n        var _iterator = _createForOfIteratorHelper(rgb),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var x = _step.value;\n            mask.push(x, x);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.obj.data['Mask'] = mask;\n      } else if (this.image.transparency.indexed) {\n        // Create a transparency SMask for the image based on the data\n        // in the PLTE and tRNS sections. See below for details on SMasks.\n        dataDecoded = true;\n        return this.loadIndexedAlphaChannel();\n      } else if (hasAlphaChannel) {\n        // For PNG color types 4 and 6, the transparency data is stored as a alpha\n        // channel mixed in with the main image data. Separate this data out into an\n        // SMask object and store it separately in the PDF.\n        dataDecoded = true;\n        return this.splitAlphaChannel();\n      }\n\n      if (isInterlaced && !dataDecoded) {\n        return this.decodeData();\n      }\n\n      this.finalize();\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      if (this.alphaChannel) {\n        var sMask = this.document.ref({\n          Type: 'XObject',\n          Subtype: 'Image',\n          Height: this.height,\n          Width: this.width,\n          BitsPerComponent: 8,\n          Filter: 'FlateDecode',\n          ColorSpace: 'DeviceGray',\n          Decode: [0, 1]\n        });\n        sMask.end(this.alphaChannel);\n        this.obj.data['SMask'] = sMask;\n      } // add the actual image data\n\n\n      this.obj.end(this.imgData); // free memory\n\n      this.image = null;\n      return this.imgData = null;\n    }\n  }, {\n    key: \"splitAlphaChannel\",\n    value: function splitAlphaChannel() {\n      var _this = this;\n\n      return this.image.decodePixels(function (pixels) {\n        var a, p;\n        var colorCount = _this.image.colors;\n        var pixelCount = _this.width * _this.height;\n        var imgData = Buffer.alloc(pixelCount * colorCount);\n        var alphaChannel = Buffer.alloc(pixelCount);\n        var i = p = a = 0;\n        var len = pixels.length; // For 16bit images copy only most significant byte (MSB) - PNG data is always stored in network byte order (MSB first)\n\n        var skipByteCount = _this.image.bits === 16 ? 1 : 0;\n\n        while (i < len) {\n          for (var colorIndex = 0; colorIndex < colorCount; colorIndex++) {\n            imgData[p++] = pixels[i++];\n            i += skipByteCount;\n          }\n\n          alphaChannel[a++] = pixels[i++];\n          i += skipByteCount;\n        }\n\n        _this.imgData = zlib__WEBPACK_IMPORTED_MODULE_2___default().deflateSync(imgData);\n        _this.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_2___default().deflateSync(alphaChannel);\n        return _this.finalize();\n      });\n    }\n  }, {\n    key: \"loadIndexedAlphaChannel\",\n    value: function loadIndexedAlphaChannel() {\n      var _this2 = this;\n\n      var transparency = this.image.transparency.indexed;\n      return this.image.decodePixels(function (pixels) {\n        var alphaChannel = Buffer.alloc(_this2.width * _this2.height);\n        var i = 0;\n\n        for (var j = 0, end = pixels.length; j < end; j++) {\n          alphaChannel[i++] = transparency[pixels[j]];\n        }\n\n        _this2.alphaChannel = zlib__WEBPACK_IMPORTED_MODULE_2___default().deflateSync(alphaChannel);\n        return _this2.finalize();\n      });\n    }\n  }, {\n    key: \"decodeData\",\n    value: function decodeData() {\n      var _this3 = this;\n\n      this.image.decodePixels(function (pixels) {\n        _this3.imgData = zlib__WEBPACK_IMPORTED_MODULE_2___default().deflateSync(pixels);\n\n        _this3.finalize();\n      });\n    }\n  }]);\n\n  return PNGImage;\n}();\n\nvar PDFImage = /*#__PURE__*/function () {\n  function PDFImage() {\n    _classCallCheck(this, PDFImage);\n  }\n\n  _createClass(PDFImage, null, [{\n    key: \"open\",\n    value: function open(src, label) {\n      var data;\n\n      if (Buffer.isBuffer(src)) {\n        data = src;\n      } else if (src instanceof ArrayBuffer) {\n        data = Buffer.from(new Uint8Array(src));\n      } else {\n        var match;\n\n        if (match = /^data:.+;base64,(.*)$/.exec(src)) {\n          data = Buffer.from(match[1], 'base64');\n        } else {\n          data = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(src);\n\n          if (!data) {\n            return;\n          }\n        }\n      }\n\n      if (data[0] === 0xff && data[1] === 0xd8) {\n        return new JPEG(data, label);\n      } else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {\n        return new PNGImage(data, label);\n      } else {\n        throw new Error('Unknown image format.');\n      }\n    }\n  }]);\n\n  return PDFImage;\n}();\n\nvar ImagesMixin = {\n  initImages: function initImages() {\n    this._imageRegistry = {};\n    return this._imageCount = 0;\n  },\n  image: function image(src, x, y) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var bh, bp, bw, image, ip, left, left1;\n\n    if (typeof x === 'object') {\n      options = x;\n      x = null;\n    }\n\n    x = (left = x != null ? x : options.x) != null ? left : this.x;\n    y = (left1 = y != null ? y : options.y) != null ? left1 : this.y;\n\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n\n    if (!image) {\n      if (src.width && src.height) {\n        image = src;\n      } else {\n        image = this.openImage(src);\n      }\n    }\n\n    if (!image.obj) {\n      image.embed(this);\n    }\n\n    if (this.page.xobjects[image.label] == null) {\n      this.page.xobjects[image.label] = image.obj;\n    }\n\n    var w = options.width || image.width;\n    var h = options.height || image.height;\n\n    if (options.width && !options.height) {\n      var wp = w / image.width;\n      w = image.width * wp;\n      h = image.height * wp;\n    } else if (options.height && !options.width) {\n      var hp = h / image.height;\n      w = image.width * hp;\n      h = image.height * hp;\n    } else if (options.scale) {\n      w = image.width * options.scale;\n      h = image.height * options.scale;\n    } else if (options.fit) {\n      var _options$fit = _slicedToArray(options.fit, 2);\n\n      bw = _options$fit[0];\n      bh = _options$fit[1];\n      bp = bw / bh;\n      ip = image.width / image.height;\n\n      if (ip > bp) {\n        w = bw;\n        h = bw / ip;\n      } else {\n        h = bh;\n        w = bh * ip;\n      }\n    } else if (options.cover) {\n      var _options$cover = _slicedToArray(options.cover, 2);\n\n      bw = _options$cover[0];\n      bh = _options$cover[1];\n      bp = bw / bh;\n      ip = image.width / image.height;\n\n      if (ip > bp) {\n        h = bh;\n        w = bh * ip;\n      } else {\n        w = bw;\n        h = bw / ip;\n      }\n    }\n\n    if (options.fit || options.cover) {\n      if (options.align === 'center') {\n        x = x + bw / 2 - w / 2;\n      } else if (options.align === 'right') {\n        x = x + bw - w;\n      }\n\n      if (options.valign === 'center') {\n        y = y + bh / 2 - h / 2;\n      } else if (options.valign === 'bottom') {\n        y = y + bh - h;\n      }\n    } // create link annotations if the link option is given\n\n\n    if (options.link != null) {\n      this.link(x, y, w, h, options.link);\n    }\n\n    if (options.goTo != null) {\n      this.goTo(x, y, w, h, options.goTo);\n    }\n\n    if (options.destination != null) {\n      this.addNamedDestination(options.destination, 'XYZ', x, y, null);\n    } // Set the current y position to below the image if it is in the document flow\n\n\n    if (this.y === y) {\n      this.y += h;\n    }\n\n    this.save();\n    this.transform(w, 0, 0, -h, x, y + h);\n    this.addContent(\"/\".concat(image.label, \" Do\"));\n    this.restore();\n    return this;\n  },\n  openImage: function openImage(src) {\n    var image;\n\n    if (typeof src === 'string') {\n      image = this._imageRegistry[src];\n    }\n\n    if (!image) {\n      image = PDFImage.open(src, \"I\".concat(++this._imageCount));\n\n      if (typeof src === 'string') {\n        this._imageRegistry[src] = image;\n      }\n    }\n\n    return image;\n  }\n};\n\nvar AnnotationsMixin = {\n  annotate: function annotate(x, y, w, h, options) {\n    options.Type = 'Annot';\n    options.Rect = this._convertRect(x, y, w, h);\n    options.Border = [0, 0, 0];\n\n    if (options.Subtype === 'Link' && typeof options.F === 'undefined') {\n      options.F = 1 << 2; // Print Annotation Flag\n    }\n\n    if (options.Subtype !== 'Link') {\n      if (options.C == null) {\n        options.C = this._normalizeColor(options.color || [0, 0, 0]);\n      }\n    } // convert colors\n\n\n    delete options.color;\n\n    if (typeof options.Dest === 'string') {\n      options.Dest = new String(options.Dest);\n    } // Capitalize keys\n\n\n    for (var key in options) {\n      var val = options[key];\n      options[key[0].toUpperCase() + key.slice(1)] = val;\n    }\n\n    var ref = this.ref(options);\n    this.page.annotations.push(ref);\n    ref.end();\n    return this;\n  },\n  note: function note(x, y, w, h, contents) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Text';\n    options.Contents = new String(contents);\n    options.Name = 'Comment';\n\n    if (options.color == null) {\n      options.color = [243, 223, 92];\n    }\n\n    return this.annotate(x, y, w, h, options);\n  },\n  goTo: function goTo(x, y, w, h, name) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n    options.A = this.ref({\n      S: 'GoTo',\n      D: new String(name)\n    });\n    options.A.end();\n    return this.annotate(x, y, w, h, options);\n  },\n  link: function link(x, y, w, h, url) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'Link';\n\n    if (typeof url === 'number') {\n      // Link to a page in the document (the page must already exist)\n      var pages = this._root.data.Pages.data;\n\n      if (url >= 0 && url < pages.Kids.length) {\n        options.A = this.ref({\n          S: 'GoTo',\n          D: [pages.Kids[url], 'XYZ', null, null, null]\n        });\n        options.A.end();\n      } else {\n        throw new Error(\"The document has no page \".concat(url));\n      }\n    } else {\n      // Link to an external url\n      options.A = this.ref({\n        S: 'URI',\n        URI: new String(url)\n      });\n      options.A.end();\n    }\n\n    return this.annotate(x, y, w, h, options);\n  },\n  _markup: function _markup(x, y, w, h) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    var _this$_convertRect = this._convertRect(x, y, w, h),\n        _this$_convertRect2 = _slicedToArray(_this$_convertRect, 4),\n        x1 = _this$_convertRect2[0],\n        y1 = _this$_convertRect2[1],\n        x2 = _this$_convertRect2[2],\n        y2 = _this$_convertRect2[3];\n\n    options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  highlight: function highlight(x, y, w, h) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Highlight';\n\n    if (options.color == null) {\n      options.color = [241, 238, 148];\n    }\n\n    return this._markup(x, y, w, h, options);\n  },\n  underline: function underline(x, y, w, h) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Underline';\n    return this._markup(x, y, w, h, options);\n  },\n  strike: function strike(x, y, w, h) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'StrikeOut';\n    return this._markup(x, y, w, h, options);\n  },\n  lineAnnotation: function lineAnnotation(x1, y1, x2, y2) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Line';\n    options.Contents = new String();\n    options.L = [x1, this.page.height - y1, x2, this.page.height - y2];\n    return this.annotate(x1, y1, x2, y2, options);\n  },\n  rectAnnotation: function rectAnnotation(x, y, w, h) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Square';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  ellipseAnnotation: function ellipseAnnotation(x, y, w, h) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    options.Subtype = 'Circle';\n    options.Contents = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  textAnnotation: function textAnnotation(x, y, w, h, text) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    options.Subtype = 'FreeText';\n    options.Contents = new String(text);\n    options.DA = new String();\n    return this.annotate(x, y, w, h, options);\n  },\n  fileAnnotation: function fileAnnotation(x, y, w, h) {\n    var file = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    // create hidden file\n    var filespec = this.file(file.src, Object.assign({\n      hidden: true\n    }, file));\n    options.Subtype = 'FileAttachment';\n    options.FS = filespec; // add description from filespec unless description (Contents) has already been set\n\n    if (options.Contents) {\n      options.Contents = new String(options.Contents);\n    } else if (filespec.data.Desc) {\n      options.Contents = filespec.data.Desc;\n    }\n\n    return this.annotate(x, y, w, h, options);\n  },\n  _convertRect: function _convertRect(x1, y1, w, h) {\n    // flip y1 and y2\n    var y2 = y1;\n    y1 += h; // make x2\n\n    var x2 = x1 + w; // apply current transformation matrix to points\n\n    var _this$_ctm = _slicedToArray(this._ctm, 6),\n        m0 = _this$_ctm[0],\n        m1 = _this$_ctm[1],\n        m2 = _this$_ctm[2],\n        m3 = _this$_ctm[3],\n        m4 = _this$_ctm[4],\n        m5 = _this$_ctm[5];\n\n    x1 = m0 * x1 + m2 * y1 + m4;\n    y1 = m1 * x1 + m3 * y1 + m5;\n    x2 = m0 * x2 + m2 * y2 + m4;\n    y2 = m1 * x2 + m3 * y2 + m5;\n    return [x1, y1, x2, y2];\n  }\n};\n\nvar PDFOutline = /*#__PURE__*/function () {\n  function PDFOutline(document, parent, title, dest) {\n    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      expanded: false\n    };\n\n    _classCallCheck(this, PDFOutline);\n\n    this.document = document;\n    this.options = options;\n    this.outlineData = {};\n\n    if (dest !== null) {\n      this.outlineData['Dest'] = [dest.dictionary, 'Fit'];\n    }\n\n    if (parent !== null) {\n      this.outlineData['Parent'] = parent;\n    }\n\n    if (title !== null) {\n      this.outlineData['Title'] = new String(title);\n    }\n\n    this.dictionary = this.document.ref(this.outlineData);\n    this.children = [];\n  }\n\n  _createClass(PDFOutline, [{\n    key: \"addItem\",\n    value: function addItem(title) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        expanded: false\n      };\n      var result = new PDFOutline(this.document, this.dictionary, title, this.document.page, options);\n      this.children.push(result);\n      return result;\n    }\n  }, {\n    key: \"endOutline\",\n    value: function endOutline() {\n      if (this.children.length > 0) {\n        if (this.options.expanded) {\n          this.outlineData.Count = this.children.length;\n        }\n\n        var first = this.children[0],\n            last = this.children[this.children.length - 1];\n        this.outlineData.First = first.dictionary;\n        this.outlineData.Last = last.dictionary;\n\n        for (var i = 0, len = this.children.length; i < len; i++) {\n          var child = this.children[i];\n\n          if (i > 0) {\n            child.outlineData.Prev = this.children[i - 1].dictionary;\n          }\n\n          if (i < this.children.length - 1) {\n            child.outlineData.Next = this.children[i + 1].dictionary;\n          }\n\n          child.endOutline();\n        }\n      }\n\n      return this.dictionary.end();\n    }\n  }]);\n\n  return PDFOutline;\n}();\n\nvar OutlineMixin = {\n  initOutline: function initOutline() {\n    return this.outline = new PDFOutline(this, null, null, null);\n  },\n  endOutline: function endOutline() {\n    this.outline.endOutline();\n\n    if (this.outline.children.length > 0) {\n      this._root.data.Outlines = this.outline.dictionary;\n      return this._root.data.PageMode = 'UseOutlines';\n    }\n  }\n};\n\n/*\r\nPDFStructureContent - a reference to a marked structure content\r\nBy Ben Schmidt\r\n*/\nvar PDFStructureContent = /*#__PURE__*/function () {\n  function PDFStructureContent(pageRef, mcid) {\n    _classCallCheck(this, PDFStructureContent);\n\n    this.refs = [{\n      pageRef: pageRef,\n      mcid: mcid\n    }];\n  }\n\n  _createClass(PDFStructureContent, [{\n    key: \"push\",\n    value: function push(structContent) {\n      var _this = this;\n\n      structContent.refs.forEach(function (ref) {\n        return _this.refs.push(ref);\n      });\n    }\n  }]);\n\n  return PDFStructureContent;\n}();\n\nvar PDFStructureElement = /*#__PURE__*/function () {\n  function PDFStructureElement(document, type) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, PDFStructureElement);\n\n    this.document = document;\n    this._attached = false;\n    this._ended = false;\n    this._flushed = false;\n    this.dictionary = document.ref({\n      // Type: \"StructElem\",\n      S: type\n    });\n    var data = this.dictionary.data;\n\n    if (Array.isArray(options) || this._isValidChild(options)) {\n      children = options;\n      options = {};\n    }\n\n    if (typeof options.title !== 'undefined') {\n      data.T = new String(options.title);\n    }\n\n    if (typeof options.lang !== 'undefined') {\n      data.Lang = new String(options.lang);\n    }\n\n    if (typeof options.alt !== 'undefined') {\n      data.Alt = new String(options.alt);\n    }\n\n    if (typeof options.expanded !== 'undefined') {\n      data.E = new String(options.expanded);\n    }\n\n    if (typeof options.actual !== 'undefined') {\n      data.ActualText = new String(options.actual);\n    }\n\n    this._children = [];\n\n    if (children) {\n      if (!Array.isArray(children)) {\n        children = [children];\n      }\n\n      children.forEach(function (child) {\n        return _this.add(child);\n      });\n      this.end();\n    }\n  }\n\n  _createClass(PDFStructureElement, [{\n    key: \"add\",\n    value: function add(child) {\n      if (this._ended) {\n        throw new Error(\"Cannot add child to already-ended structure element\");\n      }\n\n      if (!this._isValidChild(child)) {\n        throw new Error(\"Invalid structure element child\");\n      }\n\n      if (child instanceof PDFStructureElement) {\n        child.setParent(this.dictionary);\n\n        if (this._attached) {\n          child.setAttached();\n        }\n      }\n\n      if (child instanceof PDFStructureContent) {\n        this._addContentToParentTree(child);\n      }\n\n      if (typeof child === 'function' && this._attached) {\n        // _contentForClosure() adds the content to the parent tree\n        child = this._contentForClosure(child);\n      }\n\n      this._children.push(child);\n\n      return this;\n    }\n  }, {\n    key: \"_addContentToParentTree\",\n    value: function _addContentToParentTree(content) {\n      var _this2 = this;\n\n      content.refs.forEach(function (_ref) {\n        var pageRef = _ref.pageRef,\n            mcid = _ref.mcid;\n\n        var pageStructParents = _this2.document.getStructParentTree().get(pageRef.data.StructParents);\n\n        pageStructParents[mcid] = _this2.dictionary;\n      });\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(parentRef) {\n      if (this.dictionary.data.P) {\n        throw new Error(\"Structure element added to more than one parent\");\n      }\n\n      this.dictionary.data.P = parentRef;\n\n      this._flush();\n    }\n  }, {\n    key: \"setAttached\",\n    value: function setAttached() {\n      var _this3 = this;\n\n      if (this._attached) {\n        return;\n      }\n\n      this._children.forEach(function (child, index) {\n        if (child instanceof PDFStructureElement) {\n          child.setAttached();\n        }\n\n        if (typeof child === 'function') {\n          _this3._children[index] = _this3._contentForClosure(child);\n        }\n      });\n\n      this._attached = true;\n\n      this._flush();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this._ended) {\n        return;\n      }\n\n      this._children.filter(function (child) {\n        return child instanceof PDFStructureElement;\n      }).forEach(function (child) {\n        return child.end();\n      });\n\n      this._ended = true;\n\n      this._flush();\n    }\n  }, {\n    key: \"_isValidChild\",\n    value: function _isValidChild(child) {\n      return child instanceof PDFStructureElement || child instanceof PDFStructureContent || typeof child === 'function';\n    }\n  }, {\n    key: \"_contentForClosure\",\n    value: function _contentForClosure(closure) {\n      var content = this.document.markStructureContent(this.dictionary.data.S);\n      closure();\n      this.document.endMarkedContent();\n\n      this._addContentToParentTree(content);\n\n      return content;\n    }\n  }, {\n    key: \"_isFlushable\",\n    value: function _isFlushable() {\n      if (!this.dictionary.data.P || !this._ended) {\n        return false;\n      }\n\n      return this._children.every(function (child) {\n        if (typeof child === 'function') {\n          return false;\n        }\n\n        if (child instanceof PDFStructureElement) {\n          return child._isFlushable();\n        }\n\n        return true;\n      });\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      var _this4 = this;\n\n      if (this._flushed || !this._isFlushable()) {\n        return;\n      }\n\n      this.dictionary.data.K = [];\n\n      this._children.forEach(function (child) {\n        return _this4._flushChild(child);\n      });\n\n      this.dictionary.end(); // free memory used by children; the dictionary itself may still be\n      // referenced by a parent structure element or root, but we can\n      // at least trim the tree here\n\n      this._children = [];\n      this.dictionary.data.K = null;\n      this._flushed = true;\n    }\n  }, {\n    key: \"_flushChild\",\n    value: function _flushChild(child) {\n      var _this5 = this;\n\n      if (child instanceof PDFStructureElement) {\n        this.dictionary.data.K.push(child.dictionary);\n      }\n\n      if (child instanceof PDFStructureContent) {\n        child.refs.forEach(function (_ref2) {\n          var pageRef = _ref2.pageRef,\n              mcid = _ref2.mcid;\n\n          if (!_this5.dictionary.data.Pg) {\n            _this5.dictionary.data.Pg = pageRef;\n          }\n\n          if (_this5.dictionary.data.Pg === pageRef) {\n            _this5.dictionary.data.K.push(mcid);\n          } else {\n            _this5.dictionary.data.K.push({\n              Type: \"MCR\",\n              Pg: pageRef,\n              MCID: mcid\n            });\n          }\n        });\n      }\n    }\n  }]);\n\n  return PDFStructureElement;\n}();\n\nvar PDFNumberTree = /*#__PURE__*/function (_PDFTree) {\n  _inherits(PDFNumberTree, _PDFTree);\n\n  var _super = _createSuper(PDFNumberTree);\n\n  function PDFNumberTree() {\n    _classCallCheck(this, PDFNumberTree);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PDFNumberTree, [{\n    key: \"_compareKeys\",\n    value: function _compareKeys(a, b) {\n      return parseInt(a) - parseInt(b);\n    }\n  }, {\n    key: \"_keysName\",\n    value: function _keysName() {\n      return \"Nums\";\n    }\n  }, {\n    key: \"_dataForKey\",\n    value: function _dataForKey(k) {\n      return parseInt(k);\n    }\n  }]);\n\n  return PDFNumberTree;\n}(PDFTree);\n\nvar MarkingsMixin = {\n  initMarkings: function initMarkings(options) {\n    this.structChildren = [];\n\n    if (options.tagged) {\n      this.getMarkInfoDictionary().data.Marked = true;\n      this.getStructTreeRoot();\n    }\n  },\n  markContent: function markContent(tag) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    if (tag === 'Artifact' || options && options.mcid) {\n      var toClose = 0;\n      this.page.markings.forEach(function (marking) {\n        if (toClose || marking.structContent || marking.tag === 'Artifact') {\n          toClose++;\n        }\n      });\n\n      while (toClose--) {\n        this.endMarkedContent();\n      }\n    }\n\n    if (!options) {\n      this.page.markings.push({\n        tag: tag\n      });\n      this.addContent(\"/\".concat(tag, \" BMC\"));\n      return this;\n    }\n\n    this.page.markings.push({\n      tag: tag,\n      options: options\n    });\n    var dictionary = {};\n\n    if (typeof options.mcid !== 'undefined') {\n      dictionary.MCID = options.mcid;\n    }\n\n    if (tag === 'Artifact') {\n      if (typeof options.type === 'string') {\n        dictionary.Type = options.type;\n      }\n\n      if (Array.isArray(options.bbox)) {\n        dictionary.BBox = [options.bbox[0], this.page.height - options.bbox[3], options.bbox[2], this.page.height - options.bbox[1]];\n      }\n\n      if (Array.isArray(options.attached) && options.attached.every(function (val) {\n        return typeof val === 'string';\n      })) {\n        dictionary.Attached = options.attached;\n      }\n    }\n\n    if (tag === 'Span') {\n      if (options.lang) {\n        dictionary.Lang = new String(options.lang);\n      }\n\n      if (options.alt) {\n        dictionary.Alt = new String(options.alt);\n      }\n\n      if (options.expanded) {\n        dictionary.E = new String(options.expanded);\n      }\n\n      if (options.actual) {\n        dictionary.ActualText = new String(options.actual);\n      }\n    }\n\n    this.addContent(\"/\".concat(tag, \" \").concat(PDFObject.convert(dictionary), \" BDC\"));\n    return this;\n  },\n  markStructureContent: function markStructureContent(tag) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var pageStructParents = this.getStructParentTree().get(this.page.structParentTreeKey);\n    var mcid = pageStructParents.length;\n    pageStructParents.push(null);\n    this.markContent(tag, _objectSpread2(_objectSpread2({}, options), {}, {\n      mcid: mcid\n    }));\n    var structContent = new PDFStructureContent(this.page.dictionary, mcid);\n    this.page.markings.slice(-1)[0].structContent = structContent;\n    return structContent;\n  },\n  endMarkedContent: function endMarkedContent() {\n    this.page.markings.pop();\n    this.addContent('EMC');\n    return this;\n  },\n  struct: function struct(type) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    return new PDFStructureElement(this, type, options, children);\n  },\n  addStructure: function addStructure(structElem) {\n    var structTreeRoot = this.getStructTreeRoot();\n    structElem.setParent(structTreeRoot);\n    structElem.setAttached();\n    this.structChildren.push(structElem);\n\n    if (!structTreeRoot.data.K) {\n      structTreeRoot.data.K = [];\n    }\n\n    structTreeRoot.data.K.push(structElem.dictionary);\n    return this;\n  },\n  initPageMarkings: function initPageMarkings(pageMarkings) {\n    var _this = this;\n\n    pageMarkings.forEach(function (marking) {\n      if (marking.structContent) {\n        var structContent = marking.structContent;\n\n        var newStructContent = _this.markStructureContent(marking.tag, marking.options);\n\n        structContent.push(newStructContent);\n        _this.page.markings.slice(-1)[0].structContent = structContent;\n      } else {\n        _this.markContent(marking.tag, marking.options);\n      }\n    });\n  },\n  endPageMarkings: function endPageMarkings(page) {\n    var pageMarkings = page.markings;\n    pageMarkings.forEach(function () {\n      return page.write('EMC');\n    });\n    page.markings = [];\n    return pageMarkings;\n  },\n  getMarkInfoDictionary: function getMarkInfoDictionary() {\n    if (!this._root.data.MarkInfo) {\n      this._root.data.MarkInfo = this.ref({});\n    }\n\n    return this._root.data.MarkInfo;\n  },\n  getStructTreeRoot: function getStructTreeRoot() {\n    if (!this._root.data.StructTreeRoot) {\n      this._root.data.StructTreeRoot = this.ref({\n        Type: 'StructTreeRoot',\n        ParentTree: new PDFNumberTree(),\n        ParentTreeNextKey: 0\n      });\n    }\n\n    return this._root.data.StructTreeRoot;\n  },\n  getStructParentTree: function getStructParentTree() {\n    return this.getStructTreeRoot().data.ParentTree;\n  },\n  createStructParentTreeNextKey: function createStructParentTreeNextKey() {\n    // initialise the MarkInfo dictionary\n    this.getMarkInfoDictionary();\n    var structTreeRoot = this.getStructTreeRoot();\n    var key = structTreeRoot.data.ParentTreeNextKey++;\n    structTreeRoot.data.ParentTree.add(key, []);\n    return key;\n  },\n  endMarkings: function endMarkings() {\n    var structTreeRoot = this._root.data.StructTreeRoot;\n\n    if (structTreeRoot) {\n      structTreeRoot.end();\n      this.structChildren.forEach(function (structElem) {\n        return structElem.end();\n      });\n    }\n\n    if (this._root.data.MarkInfo) {\n      this._root.data.MarkInfo.end();\n    }\n  }\n};\n\nvar FIELD_FLAGS = {\n  readOnly: 1,\n  required: 2,\n  noExport: 4,\n  multiline: 0x1000,\n  password: 0x2000,\n  toggleToOffButton: 0x4000,\n  radioButton: 0x8000,\n  pushButton: 0x10000,\n  combo: 0x20000,\n  edit: 0x40000,\n  sort: 0x80000,\n  multiSelect: 0x200000,\n  noSpell: 0x400000\n};\nvar FIELD_JUSTIFY = {\n  left: 0,\n  center: 1,\n  right: 2\n};\nvar VALUE_MAP = {\n  value: 'V',\n  defaultValue: 'DV'\n};\nvar FORMAT_SPECIAL = {\n  zip: '0',\n  zipPlus4: '1',\n  zip4: '1',\n  phone: '2',\n  ssn: '3'\n};\nvar FORMAT_DEFAULT = {\n  number: {\n    nDec: 0,\n    sepComma: false,\n    negStyle: 'MinusBlack',\n    currency: '',\n    currencyPrepend: true\n  },\n  percent: {\n    nDec: 0,\n    sepComma: false\n  }\n};\nvar AcroFormMixin = {\n  /**\r\n   * Must call if adding AcroForms to a document. Must also call font() before\r\n   * this method to set the default font.\r\n   */\n  initForm: function initForm() {\n    if (!this._font) {\n      throw new Error('Must set a font before calling initForm method');\n    }\n\n    this._acroform = {\n      fonts: {},\n      defaultFont: this._font.name\n    };\n    this._acroform.fonts[this._font.id] = this._font.ref();\n    var data = {\n      Fields: [],\n      NeedAppearances: true,\n      DA: new String(\"/\".concat(this._font.id, \" 0 Tf 0 g\")),\n      DR: {\n        Font: {}\n      }\n    };\n    data.DR.Font[this._font.id] = this._font.ref();\n    var AcroForm = this.ref(data);\n    this._root.data.AcroForm = AcroForm;\n    return this;\n  },\n\n  /**\r\n   * Called automatically by document.js\r\n   */\n  endAcroForm: function endAcroForm() {\n    var _this = this;\n\n    if (this._root.data.AcroForm) {\n      if (!Object.keys(this._acroform.fonts).length && !this._acroform.defaultFont) {\n        throw new Error('No fonts specified for PDF form');\n      }\n\n      var fontDict = this._root.data.AcroForm.data.DR.Font;\n      Object.keys(this._acroform.fonts).forEach(function (name) {\n        fontDict[name] = _this._acroform.fonts[name];\n      });\n\n      this._root.data.AcroForm.data.Fields.forEach(function (fieldRef) {\n        _this._endChild(fieldRef);\n      });\n\n      this._root.data.AcroForm.end();\n    }\n\n    return this;\n  },\n  _endChild: function _endChild(ref) {\n    var _this2 = this;\n\n    if (Array.isArray(ref.data.Kids)) {\n      ref.data.Kids.forEach(function (childRef) {\n        _this2._endChild(childRef);\n      });\n      ref.end();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Creates and adds a form field to the document. Form fields are intermediate\r\n   * nodes in a PDF form that are used to specify form name heirarchy and form\r\n   * value defaults.\r\n   * @param {string} name - field name (T attribute in field dictionary)\r\n   * @param {object} options  - other attributes to include in field dictionary\r\n   */\n  formField: function formField(name) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var fieldDict = this._fieldDict(name, null, options);\n\n    var fieldRef = this.ref(fieldDict);\n\n    this._addToParent(fieldRef);\n\n    return fieldRef;\n  },\n\n  /**\r\n   * Creates and adds a Form Annotation to the document. Form annotations are\r\n   * called Widget annotations internally within a PDF file.\r\n   * @param {string} name - form field name (T attribute of widget annotation\r\n   * dictionary)\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} w\r\n   * @param {number} h\r\n   * @param {object} options\r\n   */\n  formAnnotation: function formAnnotation(name, type, x, y, w, h) {\n    var options = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n    var fieldDict = this._fieldDict(name, type, options);\n\n    fieldDict.Subtype = 'Widget';\n\n    if (fieldDict.F === undefined) {\n      fieldDict.F = 4; // print the annotation\n    } // Add Field annot to page, and get it's ref\n\n\n    this.annotate(x, y, w, h, fieldDict);\n    var annotRef = this.page.annotations[this.page.annotations.length - 1];\n    return this._addToParent(annotRef);\n  },\n  formText: function formText(name, x, y, w, h) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'text', x, y, w, h, options);\n  },\n  formPushButton: function formPushButton(name, x, y, w, h) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'pushButton', x, y, w, h, options);\n  },\n  formCombo: function formCombo(name, x, y, w, h) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'combo', x, y, w, h, options);\n  },\n  formList: function formList(name, x, y, w, h) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'list', x, y, w, h, options);\n  },\n  formRadioButton: function formRadioButton(name, x, y, w, h) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'radioButton', x, y, w, h, options);\n  },\n  formCheckbox: function formCheckbox(name, x, y, w, h) {\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    return this.formAnnotation(name, 'checkbox', x, y, w, h, options);\n  },\n  _addToParent: function _addToParent(fieldRef) {\n    var parent = fieldRef.data.Parent;\n\n    if (parent) {\n      if (!parent.data.Kids) {\n        parent.data.Kids = [];\n      }\n\n      parent.data.Kids.push(fieldRef);\n    } else {\n      this._root.data.AcroForm.data.Fields.push(fieldRef);\n    }\n\n    return this;\n  },\n  _fieldDict: function _fieldDict(name, type) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!this._acroform) {\n      throw new Error('Call document.initForms() method before adding form elements to document');\n    }\n\n    var opts = Object.assign({}, options);\n\n    if (type !== null) {\n      opts = this._resolveType(type, options);\n    }\n\n    opts = this._resolveFlags(opts);\n    opts = this._resolveJustify(opts);\n    opts = this._resolveFont(opts);\n    opts = this._resolveStrings(opts);\n    opts = this._resolveColors(opts);\n    opts = this._resolveFormat(opts);\n    opts.T = new String(name);\n\n    if (opts.parent) {\n      opts.Parent = opts.parent;\n      delete opts.parent;\n    }\n\n    return opts;\n  },\n  _resolveType: function _resolveType(type, opts) {\n    if (type === 'text') {\n      opts.FT = 'Tx';\n    } else if (type === 'pushButton') {\n      opts.FT = 'Btn';\n      opts.pushButton = true;\n    } else if (type === 'radioButton') {\n      opts.FT = 'Btn';\n      opts.radioButton = true;\n    } else if (type === 'checkbox') {\n      opts.FT = 'Btn';\n    } else if (type === 'combo') {\n      opts.FT = 'Ch';\n      opts.combo = true;\n    } else if (type === 'list') {\n      opts.FT = 'Ch';\n    } else {\n      throw new Error(\"Invalid form annotation type '\".concat(type, \"'\"));\n    }\n\n    return opts;\n  },\n  _resolveFormat: function _resolveFormat(opts) {\n    var f = opts.format;\n\n    if (f && f.type) {\n      var fnKeystroke;\n      var fnFormat;\n      var params = '';\n\n      if (FORMAT_SPECIAL[f.type] !== undefined) {\n        fnKeystroke = \"AFSpecial_Keystroke\";\n        fnFormat = \"AFSpecial_Format\";\n        params = FORMAT_SPECIAL[f.type];\n      } else {\n        var format = f.type.charAt(0).toUpperCase() + f.type.slice(1);\n        fnKeystroke = \"AF\".concat(format, \"_Keystroke\");\n        fnFormat = \"AF\".concat(format, \"_Format\");\n\n        if (f.type === 'date') {\n          fnKeystroke += 'Ex';\n          params = String(f.param);\n        } else if (f.type === 'time') {\n          params = String(f.param);\n        } else if (f.type === 'number') {\n          var p = Object.assign({}, FORMAT_DEFAULT.number, f);\n          params = String([String(p.nDec), p.sepComma ? '0' : '1', '\"' + p.negStyle + '\"', 'null', '\"' + p.currency + '\"', String(p.currencyPrepend)].join(','));\n        } else if (f.type === 'percent') {\n          var _p = Object.assign({}, FORMAT_DEFAULT.percent, f);\n\n          params = String([String(_p.nDec), _p.sepComma ? '0' : '1'].join(','));\n        }\n      }\n\n      opts.AA = opts.AA ? opts.AA : {};\n      opts.AA.K = {\n        S: 'JavaScript',\n        JS: new String(\"\".concat(fnKeystroke, \"(\").concat(params, \");\"))\n      };\n      opts.AA.F = {\n        S: 'JavaScript',\n        JS: new String(\"\".concat(fnFormat, \"(\").concat(params, \");\"))\n      };\n    }\n\n    delete opts.format;\n    return opts;\n  },\n  _resolveColors: function _resolveColors(opts) {\n    var color = this._normalizeColor(opts.backgroundColor);\n\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n\n      opts.MK.BG = color;\n    }\n\n    color = this._normalizeColor(opts.borderColor);\n\n    if (color) {\n      if (!opts.MK) {\n        opts.MK = {};\n      }\n\n      opts.MK.BC = color;\n    }\n\n    delete opts.backgroundColor;\n    delete opts.borderColor;\n    return opts;\n  },\n  _resolveFlags: function _resolveFlags(options) {\n    var result = 0;\n    Object.keys(options).forEach(function (key) {\n      if (FIELD_FLAGS[key]) {\n        result |= FIELD_FLAGS[key];\n        delete options[key];\n      }\n    });\n\n    if (result !== 0) {\n      options.Ff = options.Ff ? options.Ff : 0;\n      options.Ff |= result;\n    }\n\n    return options;\n  },\n  _resolveJustify: function _resolveJustify(options) {\n    var result = 0;\n\n    if (options.align !== undefined) {\n      if (typeof FIELD_JUSTIFY[options.align] === 'number') {\n        result = FIELD_JUSTIFY[options.align];\n      }\n\n      delete options.align;\n    }\n\n    if (result !== 0) {\n      options.Q = result; // default\n    }\n\n    return options;\n  },\n  _resolveFont: function _resolveFont(options) {\n    // add current font to document-level AcroForm dict if necessary\n    if (this._acroform.fonts[this._font.id] === null) {\n      this._acroform.fonts[this._font.id] = this._font.ref();\n    } // add current font to field's resource dict (RD) if not the default acroform font\n\n\n    if (this._acroform.defaultFont !== this._font.name) {\n      options.DR = {\n        Font: {}\n      }; // Get the fontSize option. If not set use auto sizing\n\n      var fontSize = options.fontSize || 0;\n      options.DR.Font[this._font.id] = this._font.ref();\n      options.DA = new String(\"/\".concat(this._font.id, \" \").concat(fontSize, \" Tf 0 g\"));\n    }\n\n    return options;\n  },\n  _resolveStrings: function _resolveStrings(options) {\n    var select = [];\n\n    function appendChoices(a) {\n      if (Array.isArray(a)) {\n        for (var idx = 0; idx < a.length; idx++) {\n          if (typeof a[idx] === 'string') {\n            select.push(new String(a[idx]));\n          } else {\n            select.push(a[idx]);\n          }\n        }\n      }\n    }\n\n    appendChoices(options.Opt);\n\n    if (options.select) {\n      appendChoices(options.select);\n      delete options.select;\n    }\n\n    if (select.length) {\n      options.Opt = select;\n    }\n\n    Object.keys(VALUE_MAP).forEach(function (key) {\n      if (options[key] !== undefined) {\n        options[VALUE_MAP[key]] = options[key];\n        delete options[key];\n      }\n    });\n    ['V', 'DV'].forEach(function (key) {\n      if (typeof options[key] === 'string') {\n        options[key] = new String(options[key]);\n      }\n    });\n\n    if (options.MK && options.MK.CA) {\n      options.MK.CA = new String(options.MK.CA);\n    }\n\n    if (options.label) {\n      options.MK = options.MK ? options.MK : {};\n      options.MK.CA = new String(options.label);\n      delete options.label;\n    }\n\n    return options;\n  }\n};\n\nvar AttachmentsMixin = {\n  /**\r\n   * Embed contents of `src` in PDF\r\n   * @param {Buffer | ArrayBuffer | string} src input Buffer, ArrayBuffer, base64 encoded string or path to file\r\n   * @param {object} options\r\n   *  * options.name: filename to be shown in PDF, will use `src` if none set\r\n   *  * options.type: filetype to be shown in PDF\r\n   *  * options.description: description to be shown in PDF\r\n   *  * options.hidden: if true, do not add attachment to EmbeddedFiles dictionary. Useful for file attachment annotations\r\n   *  * options.creationDate: override creation date\r\n   *  * options.modifiedDate: override modified date\r\n   * @returns filespec reference\r\n   */\n  file: function file(src) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.name = options.name || src;\n    var refBody = {\n      Type: 'EmbeddedFile',\n      Params: {}\n    };\n    var data;\n\n    if (!src) {\n      throw new Error('No src specified');\n    }\n\n    if (Buffer.isBuffer(src)) {\n      data = src;\n    } else if (src instanceof ArrayBuffer) {\n      data = Buffer.from(new Uint8Array(src));\n    } else {\n      var match;\n\n      if (match = /^data:(.*);base64,(.*)$/.exec(src)) {\n        if (match[1]) {\n          refBody.Subtype = match[1].replace('/', '#2F');\n        }\n\n        data = Buffer.from(match[2], 'base64');\n      } else {\n        data = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(src);\n\n        if (!data) {\n          throw new Error(\"Could not read contents of file at filepath \".concat(src));\n        } // update CreationDate and ModDate\n\n\n        var _fs$statSync = fs__WEBPACK_IMPORTED_MODULE_1___default().statSync(src),\n            birthtime = _fs$statSync.birthtime,\n            ctime = _fs$statSync.ctime;\n\n        refBody.Params.CreationDate = birthtime;\n        refBody.Params.ModDate = ctime;\n      }\n    } // override creation date and modified date\n\n\n    if (options.creationDate instanceof Date) {\n      refBody.Params.CreationDate = options.creationDate;\n    }\n\n    if (options.modifiedDate instanceof Date) {\n      refBody.Params.ModDate = options.modifiedDate;\n    } // add optional subtype\n\n\n    if (options.type) {\n      refBody.Subtype = options.type.replace('/', '#2F');\n    } // add checksum and size information\n\n\n    var checksum = crypto_js__WEBPACK_IMPORTED_MODULE_3___default().MD5(crypto_js__WEBPACK_IMPORTED_MODULE_3___default().lib.WordArray.create(new Uint8Array(data)));\n    refBody.Params.CheckSum = new String(checksum);\n    refBody.Params.Size = data.byteLength; // save some space when embedding the same file again\n    // if a file with the same name and metadata exists, reuse its reference\n\n    var ref;\n    if (!this._fileRegistry) this._fileRegistry = {};\n    var file = this._fileRegistry[options.name];\n\n    if (file && isEqual(refBody, file)) {\n      ref = file.ref;\n    } else {\n      ref = this.ref(refBody);\n      ref.end(data);\n      this._fileRegistry[options.name] = _objectSpread2(_objectSpread2({}, refBody), {}, {\n        ref: ref\n      });\n    } // add filespec for embedded file\n\n\n    var fileSpecBody = {\n      Type: 'Filespec',\n      F: new String(options.name),\n      EF: {\n        F: ref\n      },\n      UF: new String(options.name)\n    };\n\n    if (options.description) {\n      fileSpecBody.Desc = new String(options.description);\n    }\n\n    var filespec = this.ref(fileSpecBody);\n    filespec.end();\n\n    if (!options.hidden) {\n      this.addNamedEmbeddedFile(options.name, filespec);\n    }\n\n    return filespec;\n  }\n};\n/** check two embedded file metadata objects for equality */\n\nfunction isEqual(a, b) {\n  return a.Subtype === b.Subtype && a.Params.CheckSum.toString() === b.Params.CheckSum.toString() && a.Params.Size === b.Params.Size && a.Params.CreationDate === b.Params.CreationDate && a.Params.ModDate === b.Params.ModDate;\n}\n\nvar PDFA = {\n  initPDFA: function initPDFA(pSubset) {\n    if (pSubset.charAt(pSubset.length - 3) === '-') {\n      this.subset_conformance = pSubset.charAt(pSubset.length - 1).toUpperCase();\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 2));\n    } else {\n      // Default to Basic conformance when user doesn't specify\n      this.subset_conformance = 'B';\n      this.subset = parseInt(pSubset.charAt(pSubset.length - 1));\n    }\n  },\n  endSubset: function endSubset() {\n    this._addPdfaMetadata();\n\n    var jsPath = \"\".concat(__dirname, \"/data/sRGB_IEC61966_2_1.icc\");\n    var jestPath = \"\".concat(__dirname, \"/../color_profiles/sRGB_IEC61966_2_1.icc\");\n\n    this._addColorOutputIntent(fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(jsPath) ? jsPath : jestPath);\n  },\n  _addColorOutputIntent: function _addColorOutputIntent(pICCPath) {\n    var iccProfile = fs__WEBPACK_IMPORTED_MODULE_1___default().readFileSync(pICCPath);\n    var colorProfileRef = this.ref({\n      Length: iccProfile.length,\n      N: 3\n    });\n    colorProfileRef.write(iccProfile);\n    colorProfileRef.end();\n    var intentRef = this.ref({\n      Type: 'OutputIntent',\n      S: 'GTS_PDFA1',\n      Info: new String('sRGB IEC61966-2.1'),\n      OutputConditionIdentifier: new String('sRGB IEC61966-2.1'),\n      DestOutputProfile: colorProfileRef\n    });\n    intentRef.end();\n    this._root.data.OutputIntents = [intentRef];\n  },\n  _getPdfaid: function _getPdfaid() {\n    return \"\\n        <rdf:Description xmlns:pdfaid=\\\"http://www.aiim.org/pdfa/ns/id/\\\" rdf:about=\\\"\\\">\\n            <pdfaid:part>\".concat(this.subset, \"</pdfaid:part>\\n            <pdfaid:conformance>\").concat(this.subset_conformance, \"</pdfaid:conformance>\\n        </rdf:Description>\\n        \");\n  },\n  _addPdfaMetadata: function _addPdfaMetadata() {\n    this.appendXML(this._getPdfaid());\n  }\n};\n\nvar SubsetMixin = {\n  _importSubset: function _importSubset(subset) {\n    Object.assign(this, subset);\n  },\n  initSubset: function initSubset(options) {\n    switch (options.subset) {\n      case 'PDF/A-1':\n      case 'PDF/A-1a':\n      case 'PDF/A-1b':\n      case 'PDF/A-2':\n      case 'PDF/A-2a':\n      case 'PDF/A-2b':\n      case 'PDF/A-3':\n      case 'PDF/A-3a':\n      case 'PDF/A-3b':\n        this._importSubset(PDFA);\n\n        this.initPDFA(options.subset);\n        break;\n    }\n  }\n};\n\nvar PDFMetadata = /*#__PURE__*/function () {\n  function PDFMetadata() {\n    _classCallCheck(this, PDFMetadata);\n\n    this._metadata = \"\\n        <?xpacket begin=\\\"\\uFEFF\\\" id=\\\"W5M0MpCehiHzreSzNTczkc9d\\\"?>\\n            <x:xmpmeta xmlns:x=\\\"adobe:ns:meta/\\\">\\n                <rdf:RDF xmlns:rdf=\\\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\\\">\\n        \";\n  }\n\n  _createClass(PDFMetadata, [{\n    key: \"_closeTags\",\n    value: function _closeTags() {\n      this._metadata = this._metadata.concat(\"\\n                </rdf:RDF>\\n            </x:xmpmeta>\\n        <?xpacket end=\\\"w\\\"?>\\n        \");\n    }\n  }, {\n    key: \"append\",\n    value: function append(xml) {\n      var newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this._metadata = this._metadata.concat(xml);\n      if (newline) this._metadata = this._metadata.concat('\\n');\n    }\n  }, {\n    key: \"getXML\",\n    value: function getXML() {\n      return this._metadata;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return this._metadata.length;\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this._closeTags();\n\n      this._metadata = this._metadata.trim();\n    }\n  }]);\n\n  return PDFMetadata;\n}();\n\nvar MetadataMixin = {\n  initMetadata: function initMetadata() {\n    this.metadata = new PDFMetadata();\n  },\n  appendXML: function appendXML(xml) {\n    var newline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.metadata.append(xml, newline);\n  },\n  _addInfo: function _addInfo() {\n    this.appendXML(\"\\n        <rdf:Description rdf:about=\\\"\\\" xmlns:xmp=\\\"http://ns.adobe.com/xap/1.0/\\\">\\n            <xmp:CreateDate>\".concat(this.info.CreationDate.toISOString().split('.')[0] + \"Z\", \"</xmp:CreateDate>\\n            <xmp:CreatorTool>\").concat(this.info.Creator, \"</xmp:CreatorTool>\\n        </rdf:Description>\\n        \"));\n\n    if (this.info.Title || this.info.Author || this.info.Subject) {\n      this.appendXML(\"\\n            <rdf:Description rdf:about=\\\"\\\" xmlns:dc=\\\"http://purl.org/dc/elements/1.1/\\\">\\n            \");\n\n      if (this.info.Title) {\n        this.appendXML(\"\\n                <dc:title>\\n                    <rdf:Alt>\\n                        <rdf:li xml:lang=\\\"x-default\\\">\".concat(this.info.Title, \"</rdf:li>\\n                    </rdf:Alt>\\n                </dc:title>\\n                \"));\n      }\n\n      if (this.info.Author) {\n        this.appendXML(\"\\n                <dc:creator>\\n                    <rdf:Seq>\\n                        <rdf:li>\".concat(this.info.Author, \"</rdf:li>\\n                    </rdf:Seq>\\n                </dc:creator>\\n                \"));\n      }\n\n      if (this.info.Subject) {\n        this.appendXML(\"\\n                <dc:description>\\n                    <rdf:Alt>\\n                        <rdf:li xml:lang=\\\"x-default\\\">\".concat(this.info.Subject, \"</rdf:li>\\n                    </rdf:Alt>\\n                </dc:description>\\n                \"));\n      }\n\n      this.appendXML(\"\\n            </rdf:Description>\\n            \");\n    }\n\n    this.appendXML(\"\\n        <rdf:Description rdf:about=\\\"\\\" xmlns:pdf=\\\"http://ns.adobe.com/pdf/1.3/\\\">\\n            <pdf:Producer>\".concat(this.info.Creator, \"</pdf:Producer>\"), false);\n\n    if (this.info.Keywords) {\n      this.appendXML(\"\\n            <pdf:Keywords>\".concat(this.info.Keywords, \"</pdf:Keywords>\"), false);\n    }\n\n    this.appendXML(\"\\n        </rdf:Description>\\n        \");\n  },\n  endMetadata: function endMetadata() {\n    this._addInfo();\n\n    this.metadata.end();\n    /*\r\n    Metadata was introduced in PDF 1.4, so adding it to 1.3 \r\n    will likely only take up more space.\r\n    */\n\n    if (this.version != 1.3) {\n      this.metadataRef = this.ref({\n        length: this.metadata.getLength(),\n        Type: 'Metadata',\n        Subtype: 'XML'\n      });\n      this.metadataRef.compress = false;\n      this.metadataRef.write(Buffer.from(this.metadata.getXML(), 'utf-8'));\n      this.metadataRef.end();\n      this._root.data.Metadata = this.metadataRef;\n    }\n  }\n};\n\nvar PDFDocument = /*#__PURE__*/function (_stream$Readable) {\n  _inherits(PDFDocument, _stream$Readable);\n\n  var _super = _createSuper(PDFDocument);\n\n  function PDFDocument() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PDFDocument);\n\n    _this = _super.call(this, options);\n    _this.options = options; // PDF version\n\n    switch (options.pdfVersion) {\n      case '1.4':\n        _this.version = 1.4;\n        break;\n\n      case '1.5':\n        _this.version = 1.5;\n        break;\n\n      case '1.6':\n        _this.version = 1.6;\n        break;\n\n      case '1.7':\n      case '1.7ext3':\n        _this.version = 1.7;\n        break;\n\n      default:\n        _this.version = 1.3;\n        break;\n    } // Whether streams should be compressed\n\n\n    _this.compress = _this.options.compress != null ? _this.options.compress : true;\n    _this._pageBuffer = [];\n    _this._pageBufferStart = 0; // The PDF object store\n\n    _this._offsets = [];\n    _this._waiting = 0;\n    _this._ended = false;\n    _this._offset = 0;\n\n    var Pages = _this.ref({\n      Type: 'Pages',\n      Count: 0,\n      Kids: []\n    });\n\n    var Names = _this.ref({\n      Dests: new PDFNameTree()\n    });\n\n    _this._root = _this.ref({\n      Type: 'Catalog',\n      Pages: Pages,\n      Names: Names\n    });\n\n    if (_this.options.lang) {\n      _this._root.data.Lang = new String(_this.options.lang);\n    } // The current page\n\n\n    _this.page = null; // Initialize mixins\n\n    _this.initMetadata();\n\n    _this.initColor();\n\n    _this.initVector();\n\n    _this.initFonts(options.font);\n\n    _this.initText();\n\n    _this.initImages();\n\n    _this.initOutline();\n\n    _this.initMarkings(options);\n\n    _this.initSubset(options); // Initialize the metadata\n\n\n    _this.info = {\n      Producer: 'PDFKit',\n      Creator: 'PDFKit',\n      CreationDate: new Date()\n    };\n\n    if (_this.options.info) {\n      for (var key in _this.options.info) {\n        var val = _this.options.info[key];\n        _this.info[key] = val;\n      }\n    }\n\n    if (_this.options.displayTitle) {\n      _this._root.data.ViewerPreferences = _this.ref({\n        DisplayDocTitle: true\n      });\n    } // Generate file ID\n\n\n    _this._id = PDFSecurity.generateFileID(_this.info); // Initialize security settings\n\n    _this._security = PDFSecurity.create(_assertThisInitialized(_this), options); // Write the header\n    // PDF version\n\n    _this._write(\"%PDF-\".concat(_this.version)); // 4 binary chars, as recommended by the spec\n\n\n    _this._write('%\\xFF\\xFF\\xFF\\xFF'); // Add the first page\n\n\n    if (_this.options.autoFirstPage !== false) {\n      _this.addPage();\n    }\n\n    return _this;\n  }\n\n  _createClass(PDFDocument, [{\n    key: \"addPage\",\n    value: function addPage(options) {\n      if (options == null) {\n        options = this.options;\n      } // end the current page if needed\n\n\n      if (!this.options.bufferPages) {\n        this.flushPages();\n      } // create a page object\n\n\n      this.page = new PDFPage(this, options);\n\n      this._pageBuffer.push(this.page); // add the page to the object store\n\n\n      var pages = this._root.data.Pages.data;\n      pages.Kids.push(this.page.dictionary);\n      pages.Count++; // reset x and y coordinates\n\n      this.x = this.page.margins.left;\n      this.y = this.page.margins.top; // flip PDF coordinate system so that the origin is in\n      // the top left rather than the bottom left\n\n      this._ctm = [1, 0, 0, 1, 0, 0];\n      this.transform(1, 0, 0, -1, 0, this.page.height);\n      this.emit('pageAdded');\n      return this;\n    }\n  }, {\n    key: \"continueOnNewPage\",\n    value: function continueOnNewPage(options) {\n      var pageMarkings = this.endPageMarkings(this.page);\n      this.addPage(options);\n      this.initPageMarkings(pageMarkings);\n      return this;\n    }\n  }, {\n    key: \"bufferedPageRange\",\n    value: function bufferedPageRange() {\n      return {\n        start: this._pageBufferStart,\n        count: this._pageBuffer.length\n      };\n    }\n  }, {\n    key: \"switchToPage\",\n    value: function switchToPage(n) {\n      var page;\n\n      if (!(page = this._pageBuffer[n - this._pageBufferStart])) {\n        throw new Error(\"switchToPage(\".concat(n, \") out of bounds, current buffer covers pages \").concat(this._pageBufferStart, \" to \").concat(this._pageBufferStart + this._pageBuffer.length - 1));\n      }\n\n      return this.page = page;\n    }\n  }, {\n    key: \"flushPages\",\n    value: function flushPages() {\n      // this local variable exists so we're future-proof against\n      // reentrant calls to flushPages.\n      var pages = this._pageBuffer;\n      this._pageBuffer = [];\n      this._pageBufferStart += pages.length;\n\n      var _iterator = _createForOfIteratorHelper(pages),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var page = _step.value;\n          this.endPageMarkings(page);\n          page.end();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"addNamedDestination\",\n    value: function addNamedDestination(name) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (args.length === 0) {\n        args = ['XYZ', null, null, null];\n      }\n\n      if (args[0] === 'XYZ' && args[2] !== null) {\n        args[2] = this.page.height - args[2];\n      }\n\n      args.unshift(this.page.dictionary);\n\n      this._root.data.Names.data.Dests.add(name, args);\n    }\n  }, {\n    key: \"addNamedEmbeddedFile\",\n    value: function addNamedEmbeddedFile(name, ref) {\n      if (!this._root.data.Names.data.EmbeddedFiles) {\n        // disabling /Limits for this tree fixes attachments not showing in Adobe Reader\n        this._root.data.Names.data.EmbeddedFiles = new PDFNameTree({\n          limits: false\n        });\n      } // add filespec to EmbeddedFiles\n\n\n      this._root.data.Names.data.EmbeddedFiles.add(name, ref);\n    }\n  }, {\n    key: \"addNamedJavaScript\",\n    value: function addNamedJavaScript(name, js) {\n      if (!this._root.data.Names.data.JavaScript) {\n        this._root.data.Names.data.JavaScript = new PDFNameTree();\n      }\n\n      var data = {\n        JS: new String(js),\n        S: 'JavaScript'\n      };\n\n      this._root.data.Names.data.JavaScript.add(name, data);\n    }\n  }, {\n    key: \"ref\",\n    value: function ref(data) {\n      var ref = new PDFReference(this, this._offsets.length + 1, data);\n\n      this._offsets.push(null); // placeholder for this object's offset once it is finalized\n\n\n      this._waiting++;\n      return ref;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {} // do nothing, but this method is required by node\n\n  }, {\n    key: \"_write\",\n    value: function _write(data) {\n      if (!Buffer.isBuffer(data)) {\n        data = Buffer.from(data + '\\n', 'binary');\n      }\n\n      this.push(data);\n      return this._offset += data.length;\n    }\n  }, {\n    key: \"addContent\",\n    value: function addContent(data) {\n      this.page.write(data);\n      return this;\n    }\n  }, {\n    key: \"_refEnd\",\n    value: function _refEnd(ref) {\n      this._offsets[ref.id - 1] = ref.offset;\n\n      if (--this._waiting === 0 && this._ended) {\n        this._finalize();\n\n        return this._ended = false;\n      }\n    }\n  }, {\n    key: \"write\",\n    value: function write(filename, fn) {\n      // print a deprecation warning with a stacktrace\n      var err = new Error(\"PDFDocument#write is deprecated, and will be removed in a future version of PDFKit. Please pipe the document into a Node stream.\");\n      console.warn(err.stack);\n      this.pipe(fs__WEBPACK_IMPORTED_MODULE_1___default().createWriteStream(filename));\n      this.end();\n      return this.once('end', fn);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this.flushPages();\n      this._info = this.ref();\n\n      for (var key in this.info) {\n        var val = this.info[key];\n\n        if (typeof val === 'string') {\n          val = new String(val);\n        }\n\n        var entry = this.ref(val);\n        entry.end();\n        this._info.data[key] = entry;\n      }\n\n      this._info.end();\n\n      for (var name in this._fontFamilies) {\n        var font = this._fontFamilies[name];\n        font.finalize();\n      }\n\n      this.endOutline();\n      this.endMarkings();\n\n      if (this.subset) {\n        this.endSubset();\n      }\n\n      this.endMetadata();\n\n      this._root.end();\n\n      this._root.data.Pages.end();\n\n      this._root.data.Names.end();\n\n      this.endAcroForm();\n\n      if (this._root.data.ViewerPreferences) {\n        this._root.data.ViewerPreferences.end();\n      }\n\n      if (this._security) {\n        this._security.end();\n      }\n\n      if (this._waiting === 0) {\n        return this._finalize();\n      } else {\n        return this._ended = true;\n      }\n    }\n  }, {\n    key: \"_finalize\",\n    value: function _finalize() {\n      // generate xref\n      var xRefOffset = this._offset;\n\n      this._write('xref');\n\n      this._write(\"0 \".concat(this._offsets.length + 1));\n\n      this._write('0000000000 65535 f ');\n\n      var _iterator2 = _createForOfIteratorHelper(this._offsets),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var offset = _step2.value;\n          offset = \"0000000000\".concat(offset).slice(-10);\n\n          this._write(offset + ' 00000 n ');\n        } // trailer\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var trailer = {\n        Size: this._offsets.length + 1,\n        Root: this._root,\n        Info: this._info,\n        ID: [this._id, this._id]\n      };\n\n      if (this._security) {\n        trailer.Encrypt = this._security.dictionary;\n      }\n\n      this._write('trailer');\n\n      this._write(PDFObject.convert(trailer));\n\n      this._write('startxref');\n\n      this._write(\"\".concat(xRefOffset));\n\n      this._write('%%EOF'); // end the stream\n\n\n      return this.push(null);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return '[object PDFDocument]';\n    }\n  }]);\n\n  return PDFDocument;\n}((stream__WEBPACK_IMPORTED_MODULE_0___default().Readable));\n\nvar mixin = function mixin(methods) {\n  Object.assign(PDFDocument.prototype, methods);\n};\n\nmixin(MetadataMixin);\nmixin(ColorMixin);\nmixin(VectorMixin);\nmixin(FontsMixin);\nmixin(TextMixin);\nmixin(ImagesMixin);\nmixin(AnnotationsMixin);\nmixin(OutlineMixin);\nmixin(MarkingsMixin);\nmixin(AcroFormMixin);\nmixin(AttachmentsMixin);\nmixin(SubsetMixin);\nPDFDocument.LineWrapper = LineWrapper;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PDFDocument);\n//# sourceMappingURL=pdfkit.es5.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGRma2l0L2pzL3BkZmtpdC5lczUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRCO0FBQ1I7QUFDSTtBQUNTO0FBQ0g7QUFDUTtBQUNGO0FBQ1g7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QywrQkFBK0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qiw4QkFBOEI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFFBQVE7QUFDUiw2QkFBNkI7O0FBRTdCOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7O0FBR1Y7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsU0FBUztBQUNULHdDQUF3QztBQUN4QyxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsNE9BQTRPOzs7QUFHNU87QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVEsV0FBVztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHVEQUFnQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQjs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0Q7O0FBRS9ELHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZ6TUFBNnpNOztBQUU3ek07QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLG1kQUFtZDs7QUFFbmQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNHQUFzRzs7QUFFdEc7O0FBRUEsNkNBQTZDOzs7QUFHN0M7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWixRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw4QkFBOEI7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkMsa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFlO0FBQ3hDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRCxzQkFBc0IsMEJBQTBCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7O0FBRXZCO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLGtCQUFrQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixpQ0FBaUMsWUFBWTs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNO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QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvREFBb0QsU0FBUztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGtDQUFrQztBQUNsQztBQUNBLFVBQVU7QUFDVixtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUixlQUFlLHNEQUFlOztBQUU5QjtBQUNBO0FBQ0EsVUFBVTs7O0FBR1YsMkJBQTJCLGtEQUFXO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTs7O0FBR04sbUJBQW1CLG9EQUFZLENBQUMsb0RBQVk7QUFDNUM7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHlFQUF5RSxjQUFjO0FBQ3ZGO0FBQ0EsT0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQixvREFBYTtBQUM1QyxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsc0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTix1QkFBdUI7O0FBRXZCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLCtCQUErQjs7O0FBRy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTix3REFBd0Q7O0FBRXhELGtGQUFrRjtBQUNsRjs7QUFFQSxpREFBaUQ7OztBQUdqRCx1Q0FBdUM7OztBQUd2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBLHdDQUF3Qzs7O0FBR3hDO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7OztBQUdoQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwrQkFBK0I7O0FBRS9CLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJEQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGdDQUFnQztBQUM3RDtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVixRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDRCQUE0Qjs7O0FBRzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxDQUFDLHdEQUFlOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsV0FBVyxFQUFDO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaHJtcy1iYWNrZW5kLy4vbm9kZV9tb2R1bGVzL3BkZmtpdC9qcy9wZGZraXQuZXM1LmpzPzRkMGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0cmVhbSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCB6bGliIGZyb20gJ3psaWInO1xuaW1wb3J0IENyeXB0b0pTIGZyb20gJ2NyeXB0by1qcyc7XG5pbXBvcnQgZm9udGtpdCBmcm9tICdmb250a2l0JztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgTGluZUJyZWFrZXIgZnJvbSAnbGluZWJyZWFrJztcbmltcG9ydCBQTkcgZnJvbSAncG5nLWpzJztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcblxuICByZXR1cm4gYXJyMjtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgdmFyIGl0O1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xuICB9XG5cbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxuICAgICAgZGlkRXJyID0gZmFsc2UsXG4gICAgICBlcnI7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xuICAgICAgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTtcbiAgICAgIHJldHVybiBzdGVwO1xuICAgIH0sXG4gICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRpZEVyciA9IHRydWU7XG4gICAgICBlcnIgPSBlO1xuICAgIH0sXG4gICAgZjogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbi8qXHJcblBERkFic3RyYWN0UmVmZXJlbmNlIC0gYWJzdHJhY3QgY2xhc3MgZm9yIFBERiByZWZlcmVuY2VcclxuKi9cbnZhciBQREZBYnN0cmFjdFJlZmVyZW5jZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkFic3RyYWN0UmVmZXJlbmNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZBYnN0cmFjdFJlZmVyZW5jZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGQWJzdHJhY3RSZWZlcmVuY2UsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGQWJzdHJhY3RSZWZlcmVuY2U7XG59KCk7XG5cbnZhciBQREZUcmVlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGVHJlZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGVHJlZSk7XG5cbiAgICB0aGlzLl9pdGVtcyA9IHt9OyAvLyBkaXNhYmxlIC9MaW1pdHMgb3V0cHV0IGZvciB0aGlzIHRyZWVcblxuICAgIHRoaXMubGltaXRzID0gdHlwZW9mIG9wdGlvbnMubGltaXRzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmxpbWl0cyA6IHRydWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGVHJlZSwgW3tcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXksIHZhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW2tleV0gPSB2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXRlbXNba2V5XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAvLyBOZWVkcyB0byBiZSBzb3J0ZWQgYnkga2V5XG4gICAgICB2YXIgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2l0ZW1zKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fY29tcGFyZUtleXMoYSwgYik7XG4gICAgICB9KTtcbiAgICAgIHZhciBvdXQgPSBbJzw8J107XG5cbiAgICAgIGlmICh0aGlzLmxpbWl0cyAmJiBzb3J0ZWRLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gc29ydGVkS2V5c1swXSxcbiAgICAgICAgICAgIGxhc3QgPSBzb3J0ZWRLZXlzW3NvcnRlZEtleXMubGVuZ3RoIC0gMV07XG4gICAgICAgIG91dC5wdXNoKFwiICAvTGltaXRzIFwiLmNvbmNhdChQREZPYmplY3QuY29udmVydChbdGhpcy5fZGF0YUZvcktleShmaXJzdCksIHRoaXMuX2RhdGFGb3JLZXkobGFzdCldKSkpO1xuICAgICAgfVxuXG4gICAgICBvdXQucHVzaChcIiAgL1wiLmNvbmNhdCh0aGlzLl9rZXlzTmFtZSgpLCBcIiBbXCIpKTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHNvcnRlZEtleXMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBvdXQucHVzaChcIiAgICBcIi5jb25jYXQoUERGT2JqZWN0LmNvbnZlcnQodGhpcy5fZGF0YUZvcktleShrZXkpKSwgXCIgXCIpLmNvbmNhdChQREZPYmplY3QuY29udmVydCh0aGlzLl9pdGVtc1trZXldKSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIG91dC5wdXNoKCddJyk7XG4gICAgICBvdXQucHVzaCgnPj4nKTtcbiAgICAgIHJldHVybiBvdXQuam9pbignXFxuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb21wYXJlS2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGFyZUtleXMoKVxuICAgIC8qYSwgYiovXG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2tleXNOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXlzTmFtZSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kYXRhRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kYXRhRm9yS2V5KClcbiAgICAvKmsqL1xuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERlRyZWU7XG59KCk7XG5cbnZhciBwYWQgPSBmdW5jdGlvbiBwYWQoc3RyLCBsZW5ndGgpIHtcbiAgcmV0dXJuIChBcnJheShsZW5ndGggKyAxKS5qb2luKCcwJykgKyBzdHIpLnNsaWNlKC1sZW5ndGgpO1xufTtcblxudmFyIGVzY2FwYWJsZVJlID0gL1tcXG5cXHJcXHRcXGJcXGYoKVxcXFxdL2c7XG52YXIgZXNjYXBhYmxlID0ge1xuICAnXFxuJzogJ1xcXFxuJyxcbiAgJ1xccic6ICdcXFxccicsXG4gICdcXHQnOiAnXFxcXHQnLFxuICAnXFxiJzogJ1xcXFxiJyxcbiAgJ1xcZic6ICdcXFxcZicsXG4gICdcXFxcJzogJ1xcXFxcXFxcJyxcbiAgJygnOiAnXFxcXCgnLFxuICAnKSc6ICdcXFxcKSdcbn07IC8vIENvbnZlcnQgbGl0dGxlIGVuZGlhbiBVVEYtMTYgdG8gYmlnIGVuZGlhblxuXG52YXIgc3dhcEJ5dGVzID0gZnVuY3Rpb24gc3dhcEJ5dGVzKGJ1ZmYpIHtcbiAgdmFyIGwgPSBidWZmLmxlbmd0aDtcblxuICBpZiAobCAmIDB4MDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlciBsZW5ndGggbXVzdCBiZSBldmVuJyk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGVuZCA9IGwgLSAxOyBpIDwgZW5kOyBpICs9IDIpIHtcbiAgICAgIHZhciBhID0gYnVmZltpXTtcbiAgICAgIGJ1ZmZbaV0gPSBidWZmW2kgKyAxXTtcbiAgICAgIGJ1ZmZbaSArIDFdID0gYTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmZjtcbn07XG5cbnZhciBQREZPYmplY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZPYmplY3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERk9iamVjdCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGT2JqZWN0LCBudWxsLCBbe1xuICAgIGtleTogXCJjb252ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnQob2JqZWN0KSB7XG4gICAgICB2YXIgZW5jcnlwdEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICAvLyBTdHJpbmcgbGl0ZXJhbHMgYXJlIGNvbnZlcnRlZCB0byB0aGUgUERGIG5hbWUgdHlwZVxuICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBcIi9cIi5jb25jYXQob2JqZWN0KTsgLy8gU3RyaW5nIG9iamVjdHMgYXJlIGNvbnZlcnRlZCB0byBQREYgc3RyaW5ncyAoVVRGLTE2KVxuICAgICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IG9iamVjdDsgLy8gRGV0ZWN0IGlmIHRoaXMgaXMgYSB1bmljb2RlIHN0cmluZ1xuXG4gICAgICAgIHZhciBpc1VuaWNvZGUgPSBmYWxzZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgZW5kID0gc3RyaW5nLmxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID4gMHg3Zikge1xuICAgICAgICAgICAgaXNVbmljb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiBzbywgZW5jb2RlIGl0IGFzIGJpZyBlbmRpYW4gVVRGLTE2XG5cblxuICAgICAgICB2YXIgc3RyaW5nQnVmZmVyO1xuXG4gICAgICAgIGlmIChpc1VuaWNvZGUpIHtcbiAgICAgICAgICBzdHJpbmdCdWZmZXIgPSBzd2FwQnl0ZXMoQnVmZmVyLmZyb20oXCJcXHVGRUZGXCIuY29uY2F0KHN0cmluZyksICd1dGYxNmxlJykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmluZ0J1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0cmluZy52YWx1ZU9mKCksICdhc2NpaScpO1xuICAgICAgICB9IC8vIEVuY3J5cHQgdGhlIHN0cmluZyB3aGVuIG5lY2Vzc2FyeVxuXG5cbiAgICAgICAgaWYgKGVuY3J5cHRGbikge1xuICAgICAgICAgIHN0cmluZyA9IGVuY3J5cHRGbihzdHJpbmdCdWZmZXIpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmdCdWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICB9IC8vIEVzY2FwZSBjaGFyYWN0ZXJzIGFzIHJlcXVpcmVkIGJ5IHRoZSBzcGVjXG5cblxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShlc2NhcGFibGVSZSwgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICByZXR1cm4gZXNjYXBhYmxlW2NdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFwiKFwiLmNvbmNhdChzdHJpbmcsIFwiKVwiKTsgLy8gQnVmZmVycyBhcmUgY29udmVydGVkIHRvIFBERiBoZXggc3RyaW5nc1xuICAgICAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gXCI8XCIuY29uY2F0KG9iamVjdC50b1N0cmluZygnaGV4JyksIFwiPlwiKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUERGQWJzdHJhY3RSZWZlcmVuY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgUERGVHJlZSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgdmFyIF9zdHJpbmcgPSBcIkQ6XCIuY29uY2F0KHBhZChvYmplY3QuZ2V0VVRDRnVsbFllYXIoKSwgNCkpICsgcGFkKG9iamVjdC5nZXRVVENNb250aCgpICsgMSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0RhdGUoKSwgMikgKyBwYWQob2JqZWN0LmdldFVUQ0hvdXJzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENNaW51dGVzKCksIDIpICsgcGFkKG9iamVjdC5nZXRVVENTZWNvbmRzKCksIDIpICsgJ1onOyAvLyBFbmNyeXB0IHRoZSBzdHJpbmcgd2hlbiBuZWNlc3NhcnlcblxuXG4gICAgICAgIGlmIChlbmNyeXB0Rm4pIHtcbiAgICAgICAgICBfc3RyaW5nID0gZW5jcnlwdEZuKEJ1ZmZlci5mcm9tKF9zdHJpbmcsICdhc2NpaScpKS50b1N0cmluZygnYmluYXJ5Jyk7IC8vIEVzY2FwZSBjaGFyYWN0ZXJzIGFzIHJlcXVpcmVkIGJ5IHRoZSBzcGVjXG5cbiAgICAgICAgICBfc3RyaW5nID0gX3N0cmluZy5yZXBsYWNlKGVzY2FwYWJsZVJlLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwYWJsZVtjXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIihcIi5jb25jYXQoX3N0cmluZywgXCIpXCIpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gb2JqZWN0Lm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBQREZPYmplY3QuY29udmVydChlLCBlbmNyeXB0Rm4pO1xuICAgICAgICB9KS5qb2luKCcgJyk7XG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoaXRlbXMsIFwiXVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoe30udG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgICB2YXIgb3V0ID0gWyc8PCddO1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgb3V0LnB1c2goXCIvXCIuY29uY2F0KGtleSwgXCIgXCIpLmNvbmNhdChQREZPYmplY3QuY29udmVydCh2YWwsIGVuY3J5cHRGbikpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dC5wdXNoKCc+PicpO1xuICAgICAgICByZXR1cm4gb3V0LmpvaW4oJ1xcbicpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gUERGT2JqZWN0Lm51bWJlcihvYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBudW1iZXIobikge1xuICAgICAgaWYgKG4gPiAtMWUyMSAmJiBuIDwgMWUyMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChuICogMWU2KSAvIDFlNjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgbnVtYmVyOiBcIi5jb25jYXQobikpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZPYmplY3Q7XG59KCk7XG5cbnZhciBQREZSZWZlcmVuY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QREZBYnN0cmFjdFJlZmVyZW5jZSkge1xuICBfaW5oZXJpdHMoUERGUmVmZXJlbmNlLCBfUERGQWJzdHJhY3RSZWZlcmVuY2UpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUERGUmVmZXJlbmNlKTtcblxuICBmdW5jdGlvbiBQREZSZWZlcmVuY2UoZG9jdW1lbnQsIGlkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERlJlZmVyZW5jZSk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgX3RoaXMuaWQgPSBpZDtcbiAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICBfdGhpcy5nZW4gPSAwO1xuICAgIF90aGlzLmNvbXByZXNzID0gX3RoaXMuZG9jdW1lbnQuY29tcHJlc3MgJiYgIV90aGlzLmRhdGEuRmlsdGVyO1xuICAgIF90aGlzLnVuY29tcHJlc3NlZExlbmd0aCA9IDA7XG4gICAgX3RoaXMuYnVmZmVyID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERlJlZmVyZW5jZSwgW3tcbiAgICBrZXk6IFwid3JpdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JpdGUoY2h1bmspIHtcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rICsgJ1xcbicsICdiaW5hcnknKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51bmNvbXByZXNzZWRMZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLkxlbmd0aCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGF0YS5MZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHRoaXMuZGF0YS5MZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICBpZiAodGhpcy5jb21wcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLkZpbHRlciA9ICdGbGF0ZURlY29kZSc7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoY2h1bmspIHtcbiAgICAgIGlmIChjaHVuaykge1xuICAgICAgICB0aGlzLndyaXRlKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZmluYWxpemUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICB0aGlzLm9mZnNldCA9IHRoaXMuZG9jdW1lbnQuX29mZnNldDtcbiAgICAgIHZhciBlbmNyeXB0Rm4gPSB0aGlzLmRvY3VtZW50Ll9zZWN1cml0eSA/IHRoaXMuZG9jdW1lbnQuX3NlY3VyaXR5LmdldEVuY3J5cHRGbih0aGlzLmlkLCB0aGlzLmdlbikgOiBudWxsO1xuXG4gICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKHRoaXMuY29tcHJlc3MpIHtcbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHpsaWIuZGVmbGF0ZVN5bmModGhpcy5idWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuY3J5cHRGbikge1xuICAgICAgICAgIHRoaXMuYnVmZmVyID0gZW5jcnlwdEZuKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YS5MZW5ndGggPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiIFwiKS5jb25jYXQodGhpcy5nZW4sIFwiIG9ialwiKSk7XG5cbiAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKFBERk9iamVjdC5jb252ZXJ0KHRoaXMuZGF0YSwgZW5jcnlwdEZuKSk7XG5cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudC5fd3JpdGUoJ3N0cmVhbScpO1xuXG4gICAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKHRoaXMuYnVmZmVyKTtcblxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdOyAvLyBmcmVlIHVwIG1lbW9yeVxuXG4gICAgICAgIHRoaXMuZG9jdW1lbnQuX3dyaXRlKCdcXG5lbmRzdHJlYW0nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb2N1bWVudC5fd3JpdGUoJ2VuZG9iaicpO1xuXG4gICAgICB0aGlzLmRvY3VtZW50Ll9yZWZFbmQodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuaWQsIFwiIFwiKS5jb25jYXQodGhpcy5nZW4sIFwiIFJcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERlJlZmVyZW5jZTtcbn0oUERGQWJzdHJhY3RSZWZlcmVuY2UpO1xuXG4vKlxyXG5QREZQYWdlIC0gcmVwcmVzZW50cyBhIHNpbmdsZSBwYWdlIGluIHRoZSBQREYgZG9jdW1lbnRcclxuQnkgRGV2b24gR292ZXR0XHJcbiovXG52YXIgREVGQVVMVF9NQVJHSU5TID0ge1xuICB0b3A6IDcyLFxuICBsZWZ0OiA3MixcbiAgYm90dG9tOiA3MixcbiAgcmlnaHQ6IDcyXG59O1xudmFyIFNJWkVTID0ge1xuICAnNEEwJzogWzQ3NjcuODcsIDY3NDAuNzldLFxuICAnMkEwJzogWzMzNzAuMzksIDQ3NjcuODddLFxuICBBMDogWzIzODMuOTQsIDMzNzAuMzldLFxuICBBMTogWzE2ODMuNzgsIDIzODMuOTRdLFxuICBBMjogWzExOTAuNTUsIDE2ODMuNzhdLFxuICBBMzogWzg0MS44OSwgMTE5MC41NV0sXG4gIEE0OiBbNTk1LjI4LCA4NDEuODldLFxuICBBNTogWzQxOS41MywgNTk1LjI4XSxcbiAgQTY6IFsyOTcuNjQsIDQxOS41M10sXG4gIEE3OiBbMjA5Ljc2LCAyOTcuNjRdLFxuICBBODogWzE0Ny40LCAyMDkuNzZdLFxuICBBOTogWzEwNC44OCwgMTQ3LjRdLFxuICBBMTA6IFs3My43LCAxMDQuODhdLFxuICBCMDogWzI4MzQuNjUsIDQwMDguMTldLFxuICBCMTogWzIwMDQuMDksIDI4MzQuNjVdLFxuICBCMjogWzE0MTcuMzIsIDIwMDQuMDldLFxuICBCMzogWzEwMDAuNjMsIDE0MTcuMzJdLFxuICBCNDogWzcwOC42NiwgMTAwMC42M10sXG4gIEI1OiBbNDk4LjksIDcwOC42Nl0sXG4gIEI2OiBbMzU0LjMzLCA0OTguOV0sXG4gIEI3OiBbMjQ5LjQ1LCAzNTQuMzNdLFxuICBCODogWzE3NS43NSwgMjQ5LjQ1XSxcbiAgQjk6IFsxMjQuNzIsIDE3NS43NV0sXG4gIEIxMDogWzg3Ljg3LCAxMjQuNzJdLFxuICBDMDogWzI1OTkuMzcsIDM2NzYuNTRdLFxuICBDMTogWzE4MzYuODUsIDI1OTkuMzddLFxuICBDMjogWzEyOTguMjcsIDE4MzYuODVdLFxuICBDMzogWzkxOC40MywgMTI5OC4yN10sXG4gIEM0OiBbNjQ5LjEzLCA5MTguNDNdLFxuICBDNTogWzQ1OS4yMSwgNjQ5LjEzXSxcbiAgQzY6IFszMjMuMTUsIDQ1OS4yMV0sXG4gIEM3OiBbMjI5LjYxLCAzMjMuMTVdLFxuICBDODogWzE2MS41NywgMjI5LjYxXSxcbiAgQzk6IFsxMTMuMzksIDE2MS41N10sXG4gIEMxMDogWzc5LjM3LCAxMTMuMzldLFxuICBSQTA6IFsyNDM3LjgsIDM0NTguMjddLFxuICBSQTE6IFsxNzI5LjEzLCAyNDM3LjhdLFxuICBSQTI6IFsxMjE4LjksIDE3MjkuMTNdLFxuICBSQTM6IFs4NjQuNTcsIDEyMTguOV0sXG4gIFJBNDogWzYwOS40NSwgODY0LjU3XSxcbiAgU1JBMDogWzI1NTEuMTgsIDM2MjguMzVdLFxuICBTUkExOiBbMTgxNC4xNywgMjU1MS4xOF0sXG4gIFNSQTI6IFsxMjc1LjU5LCAxODE0LjE3XSxcbiAgU1JBMzogWzkwNy4wOSwgMTI3NS41OV0sXG4gIFNSQTQ6IFs2MzcuOCwgOTA3LjA5XSxcbiAgRVhFQ1VUSVZFOiBbNTIxLjg2LCA3NTYuMF0sXG4gIEZPTElPOiBbNjEyLjAsIDkzNi4wXSxcbiAgTEVHQUw6IFs2MTIuMCwgMTAwOC4wXSxcbiAgTEVUVEVSOiBbNjEyLjAsIDc5Mi4wXSxcbiAgVEFCTE9JRDogWzc5Mi4wLCAxMjI0LjBdXG59O1xuXG52YXIgUERGUGFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERlBhZ2UoZG9jdW1lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGUGFnZSk7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5zaXplID0gb3B0aW9ucy5zaXplIHx8ICdsZXR0ZXInO1xuICAgIHRoaXMubGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQgfHwgJ3BvcnRyYWl0JzsgLy8gcHJvY2VzcyBtYXJnaW5zXG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWFyZ2luID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5tYXJnaW5zID0ge1xuICAgICAgICB0b3A6IG9wdGlvbnMubWFyZ2luLFxuICAgICAgICBsZWZ0OiBvcHRpb25zLm1hcmdpbixcbiAgICAgICAgYm90dG9tOiBvcHRpb25zLm1hcmdpbixcbiAgICAgICAgcmlnaHQ6IG9wdGlvbnMubWFyZ2luXG4gICAgICB9OyAvLyBkZWZhdWx0IHRvIDEgaW5jaCBtYXJnaW5zXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubWFyZ2lucyA9IG9wdGlvbnMubWFyZ2lucyB8fCBERUZBVUxUX01BUkdJTlM7XG4gICAgfSAvLyBjYWxjdWxhdGUgcGFnZSBkaW1lbnNpb25zXG5cblxuICAgIHZhciBkaW1lbnNpb25zID0gQXJyYXkuaXNBcnJheSh0aGlzLnNpemUpID8gdGhpcy5zaXplIDogU0laRVNbdGhpcy5zaXplLnRvVXBwZXJDYXNlKCldO1xuICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zW3RoaXMubGF5b3V0ID09PSAncG9ydHJhaXQnID8gMCA6IDFdO1xuICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9uc1t0aGlzLmxheW91dCA9PT0gJ3BvcnRyYWl0JyA/IDEgOiAwXTtcbiAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmRvY3VtZW50LnJlZigpOyAvLyBJbml0aWFsaXplIHRoZSBGb250LCBYT2JqZWN0LCBhbmQgRXh0R1N0YXRlIGRpY3Rpb25hcmllc1xuXG4gICAgdGhpcy5yZXNvdXJjZXMgPSB0aGlzLmRvY3VtZW50LnJlZih7XG4gICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ11cbiAgICB9KTsgLy8gVGhlIHBhZ2UgZGljdGlvbmFyeVxuXG4gICAgdGhpcy5kaWN0aW9uYXJ5ID0gdGhpcy5kb2N1bWVudC5yZWYoe1xuICAgICAgVHlwZTogJ1BhZ2UnLFxuICAgICAgUGFyZW50OiB0aGlzLmRvY3VtZW50Ll9yb290LmRhdGEuUGFnZXMsXG4gICAgICBNZWRpYUJveDogWzAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSxcbiAgICAgIENvbnRlbnRzOiB0aGlzLmNvbnRlbnQsXG4gICAgICBSZXNvdXJjZXM6IHRoaXMucmVzb3VyY2VzXG4gICAgfSk7XG4gICAgdGhpcy5tYXJraW5ncyA9IFtdO1xuICB9IC8vIExhemlseSBjcmVhdGUgdGhlc2Ugb2JqZWN0c1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFBERlBhZ2UsIFt7XG4gICAga2V5OiBcIm1heFlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4WSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodCAtIHRoaXMubWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKGNodW5rKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50LndyaXRlKGNodW5rKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIHRoaXMuZGljdGlvbmFyeS5lbmQoKTtcbiAgICAgIHRoaXMucmVzb3VyY2VzLmVuZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lbmQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9udHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICAgIHJldHVybiBkYXRhLkZvbnQgIT0gbnVsbCA/IGRhdGEuRm9udCA6IGRhdGEuRm9udCA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ4b2JqZWN0c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgICAgcmV0dXJuIGRhdGEuWE9iamVjdCAhPSBudWxsID8gZGF0YS5YT2JqZWN0IDogZGF0YS5YT2JqZWN0ID0ge307XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dF9nc3RhdGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMucmVzb3VyY2VzLmRhdGE7XG4gICAgICByZXR1cm4gZGF0YS5FeHRHU3RhdGUgIT0gbnVsbCA/IGRhdGEuRXh0R1N0YXRlIDogZGF0YS5FeHRHU3RhdGUgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGF0dGVybnNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5yZXNvdXJjZXMuZGF0YTtcbiAgICAgIHJldHVybiBkYXRhLlBhdHRlcm4gIT0gbnVsbCA/IGRhdGEuUGF0dGVybiA6IGRhdGEuUGF0dGVybiA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb2xvclNwYWNlc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLnJlc291cmNlcy5kYXRhO1xuICAgICAgcmV0dXJuIGRhdGEuQ29sb3JTcGFjZSB8fCAoZGF0YS5Db2xvclNwYWNlID0ge30pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbm5vdGF0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRpY3Rpb25hcnkuZGF0YTtcbiAgICAgIHJldHVybiBkYXRhLkFubm90cyAhPSBudWxsID8gZGF0YS5Bbm5vdHMgOiBkYXRhLkFubm90cyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJ1Y3RQYXJlbnRUcmVlS2V5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGljdGlvbmFyeS5kYXRhO1xuICAgICAgcmV0dXJuIGRhdGEuU3RydWN0UGFyZW50cyAhPSBudWxsID8gZGF0YS5TdHJ1Y3RQYXJlbnRzIDogZGF0YS5TdHJ1Y3RQYXJlbnRzID0gdGhpcy5kb2N1bWVudC5jcmVhdGVTdHJ1Y3RQYXJlbnRUcmVlTmV4dEtleSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZQYWdlO1xufSgpO1xuXG52YXIgUERGTmFtZVRyZWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QREZUcmVlKSB7XG4gIF9pbmhlcml0cyhQREZOYW1lVHJlZSwgX1BERlRyZWUpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUERGTmFtZVRyZWUpO1xuXG4gIGZ1bmN0aW9uIFBERk5hbWVUcmVlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOYW1lVHJlZSk7XG5cbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGTmFtZVRyZWUsIFt7XG4gICAga2V5OiBcIl9jb21wYXJlS2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGFyZUtleXMoYSwgYikge1xuICAgICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2tleXNOYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9rZXlzTmFtZSgpIHtcbiAgICAgIHJldHVybiBcIk5hbWVzXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kYXRhRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kYXRhRm9yS2V5KGspIHtcbiAgICAgIHJldHVybiBuZXcgU3RyaW5nKGspO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZOYW1lVHJlZTtcbn0oUERGVHJlZSk7XG5cbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBpbiBhIHJhbmdlIGdyb3VwLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtudW1iZXJbXX0gcmFuZ2VHcm91cFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5mdW5jdGlvbiBpblJhbmdlKHZhbHVlLCByYW5nZUdyb3VwKSB7XG4gIGlmICh2YWx1ZSA8IHJhbmdlR3JvdXBbMF0pIHJldHVybiBmYWxzZTtcbiAgdmFyIHN0YXJ0UmFuZ2UgPSAwO1xuICB2YXIgZW5kUmFuZ2UgPSByYW5nZUdyb3VwLmxlbmd0aCAvIDI7XG5cbiAgd2hpbGUgKHN0YXJ0UmFuZ2UgPD0gZW5kUmFuZ2UpIHtcbiAgICB2YXIgbWlkZGxlUmFuZ2UgPSBNYXRoLmZsb29yKChzdGFydFJhbmdlICsgZW5kUmFuZ2UpIC8gMik7IC8vIGFjdHVhbCBhcnJheSBpbmRleFxuXG4gICAgdmFyIGFycmF5SW5kZXggPSBtaWRkbGVSYW5nZSAqIDI7IC8vIENoZWNrIGlmIHZhbHVlIGlzIGluIHJhbmdlIHBvaW50ZWQgYnkgYWN0dWFsIGluZGV4XG5cbiAgICBpZiAodmFsdWUgPj0gcmFuZ2VHcm91cFthcnJheUluZGV4XSAmJiB2YWx1ZSA8PSByYW5nZUdyb3VwW2FycmF5SW5kZXggKyAxXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID4gcmFuZ2VHcm91cFthcnJheUluZGV4ICsgMV0pIHtcbiAgICAgIC8vIFNlYXJjaCBSaWdodCBTaWRlIE9mIEFycmF5XG4gICAgICBzdGFydFJhbmdlID0gbWlkZGxlUmFuZ2UgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZWFyY2ggTGVmdCBTaWRlIE9mIEFycmF5XG4gICAgICBlbmRSYW5nZSA9IG1pZGRsZVJhbmdlIC0gMTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxyXG4gKiBBLjEgVW5hc3NpZ25lZCBjb2RlIHBvaW50cyBpbiBVbmljb2RlIDMuMlxyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1BLjFcclxuICovXG5cbnZhciB1bmFzc2lnbmVkX2NvZGVfcG9pbnRzID0gWzB4MDIyMSwgMHgwMjIxLCAweDAyMzQsIDB4MDI0ZiwgMHgwMmFlLCAweDAyYWYsIDB4MDJlZiwgMHgwMmZmLCAweDAzNTAsIDB4MDM1ZiwgMHgwMzcwLCAweDAzNzMsIDB4MDM3NiwgMHgwMzc5LCAweDAzN2IsIDB4MDM3ZCwgMHgwMzdmLCAweDAzODMsIDB4MDM4YiwgMHgwMzhiLCAweDAzOGQsIDB4MDM4ZCwgMHgwM2EyLCAweDAzYTIsIDB4MDNjZiwgMHgwM2NmLCAweDAzZjcsIDB4MDNmZiwgMHgwNDg3LCAweDA0ODcsIDB4MDRjZiwgMHgwNGNmLCAweDA0ZjYsIDB4MDRmNywgMHgwNGZhLCAweDA0ZmYsIDB4MDUxMCwgMHgwNTMwLCAweDA1NTcsIDB4MDU1OCwgMHgwNTYwLCAweDA1NjAsIDB4MDU4OCwgMHgwNTg4LCAweDA1OGIsIDB4MDU5MCwgMHgwNWEyLCAweDA1YTIsIDB4MDViYSwgMHgwNWJhLCAweDA1YzUsIDB4MDVjZiwgMHgwNWViLCAweDA1ZWYsIDB4MDVmNSwgMHgwNjBiLCAweDA2MGQsIDB4MDYxYSwgMHgwNjFjLCAweDA2MWUsIDB4MDYyMCwgMHgwNjIwLCAweDA2M2IsIDB4MDYzZiwgMHgwNjU2LCAweDA2NWYsIDB4MDZlZSwgMHgwNmVmLCAweDA2ZmYsIDB4MDZmZiwgMHgwNzBlLCAweDA3MGUsIDB4MDcyZCwgMHgwNzJmLCAweDA3NGIsIDB4MDc3ZiwgMHgwN2IyLCAweDA5MDAsIDB4MDkwNCwgMHgwOTA0LCAweDA5M2EsIDB4MDkzYiwgMHgwOTRlLCAweDA5NGYsIDB4MDk1NSwgMHgwOTU3LCAweDA5NzEsIDB4MDk4MCwgMHgwOTg0LCAweDA5ODQsIDB4MDk4ZCwgMHgwOThlLCAweDA5OTEsIDB4MDk5MiwgMHgwOWE5LCAweDA5YTksIDB4MDliMSwgMHgwOWIxLCAweDA5YjMsIDB4MDliNSwgMHgwOWJhLCAweDA5YmIsIDB4MDliZCwgMHgwOWJkLCAweDA5YzUsIDB4MDljNiwgMHgwOWM5LCAweDA5Y2EsIDB4MDljZSwgMHgwOWQ2LCAweDA5ZDgsIDB4MDlkYiwgMHgwOWRlLCAweDA5ZGUsIDB4MDllNCwgMHgwOWU1LCAweDA5ZmIsIDB4MGEwMSwgMHgwYTAzLCAweDBhMDQsIDB4MGEwYiwgMHgwYTBlLCAweDBhMTEsIDB4MGExMiwgMHgwYTI5LCAweDBhMjksIDB4MGEzMSwgMHgwYTMxLCAweDBhMzQsIDB4MGEzNCwgMHgwYTM3LCAweDBhMzcsIDB4MGEzYSwgMHgwYTNiLCAweDBhM2QsIDB4MGEzZCwgMHgwYTQzLCAweDBhNDYsIDB4MGE0OSwgMHgwYTRhLCAweDBhNGUsIDB4MGE1OCwgMHgwYTVkLCAweDBhNWQsIDB4MGE1ZiwgMHgwYTY1LCAweDBhNzUsIDB4MGE4MCwgMHgwYTg0LCAweDBhODQsIDB4MGE4YywgMHgwYThjLCAweDBhOGUsIDB4MGE4ZSwgMHgwYTkyLCAweDBhOTIsIDB4MGFhOSwgMHgwYWE5LCAweDBhYjEsIDB4MGFiMSwgMHgwYWI0LCAweDBhYjQsIDB4MGFiYSwgMHgwYWJiLCAweDBhYzYsIDB4MGFjNiwgMHgwYWNhLCAweDBhY2EsIDB4MGFjZSwgMHgwYWNmLCAweDBhZDEsIDB4MGFkZiwgMHgwYWUxLCAweDBhZTUsIDB4MGFmMCwgMHgwYjAwLCAweDBiMDQsIDB4MGIwNCwgMHgwYjBkLCAweDBiMGUsIDB4MGIxMSwgMHgwYjEyLCAweDBiMjksIDB4MGIyOSwgMHgwYjMxLCAweDBiMzEsIDB4MGIzNCwgMHgwYjM1LCAweDBiM2EsIDB4MGIzYiwgMHgwYjQ0LCAweDBiNDYsIDB4MGI0OSwgMHgwYjRhLCAweDBiNGUsIDB4MGI1NSwgMHgwYjU4LCAweDBiNWIsIDB4MGI1ZSwgMHgwYjVlLCAweDBiNjIsIDB4MGI2NSwgMHgwYjcxLCAweDBiODEsIDB4MGI4NCwgMHgwYjg0LCAweDBiOGIsIDB4MGI4ZCwgMHgwYjkxLCAweDBiOTEsIDB4MGI5NiwgMHgwYjk4LCAweDBiOWIsIDB4MGI5YiwgMHgwYjlkLCAweDBiOWQsIDB4MGJhMCwgMHgwYmEyLCAweDBiYTUsIDB4MGJhNywgMHgwYmFiLCAweDBiYWQsIDB4MGJiNiwgMHgwYmI2LCAweDBiYmEsIDB4MGJiZCwgMHgwYmMzLCAweDBiYzUsIDB4MGJjOSwgMHgwYmM5LCAweDBiY2UsIDB4MGJkNiwgMHgwYmQ4LCAweDBiZTYsIDB4MGJmMywgMHgwYzAwLCAweDBjMDQsIDB4MGMwNCwgMHgwYzBkLCAweDBjMGQsIDB4MGMxMSwgMHgwYzExLCAweDBjMjksIDB4MGMyOSwgMHgwYzM0LCAweDBjMzQsIDB4MGMzYSwgMHgwYzNkLCAweDBjNDUsIDB4MGM0NSwgMHgwYzQ5LCAweDBjNDksIDB4MGM0ZSwgMHgwYzU0LCAweDBjNTcsIDB4MGM1ZiwgMHgwYzYyLCAweDBjNjUsIDB4MGM3MCwgMHgwYzgxLCAweDBjODQsIDB4MGM4NCwgMHgwYzhkLCAweDBjOGQsIDB4MGM5MSwgMHgwYzkxLCAweDBjYTksIDB4MGNhOSwgMHgwY2I0LCAweDBjYjQsIDB4MGNiYSwgMHgwY2JkLCAweDBjYzUsIDB4MGNjNSwgMHgwY2M5LCAweDBjYzksIDB4MGNjZSwgMHgwY2Q0LCAweDBjZDcsIDB4MGNkZCwgMHgwY2RmLCAweDBjZGYsIDB4MGNlMiwgMHgwY2U1LCAweDBjZjAsIDB4MGQwMSwgMHgwZDA0LCAweDBkMDQsIDB4MGQwZCwgMHgwZDBkLCAweDBkMTEsIDB4MGQxMSwgMHgwZDI5LCAweDBkMjksIDB4MGQzYSwgMHgwZDNkLCAweDBkNDQsIDB4MGQ0NSwgMHgwZDQ5LCAweDBkNDksIDB4MGQ0ZSwgMHgwZDU2LCAweDBkNTgsIDB4MGQ1ZiwgMHgwZDYyLCAweDBkNjUsIDB4MGQ3MCwgMHgwZDgxLCAweDBkODQsIDB4MGQ4NCwgMHgwZDk3LCAweDBkOTksIDB4MGRiMiwgMHgwZGIyLCAweDBkYmMsIDB4MGRiYywgMHgwZGJlLCAweDBkYmYsIDB4MGRjNywgMHgwZGM5LCAweDBkY2IsIDB4MGRjZSwgMHgwZGQ1LCAweDBkZDUsIDB4MGRkNywgMHgwZGQ3LCAweDBkZTAsIDB4MGRmMSwgMHgwZGY1LCAweDBlMDAsIDB4MGUzYiwgMHgwZTNlLCAweDBlNWMsIDB4MGU4MCwgMHgwZTgzLCAweDBlODMsIDB4MGU4NSwgMHgwZTg2LCAweDBlODksIDB4MGU4OSwgMHgwZThiLCAweDBlOGMsIDB4MGU4ZSwgMHgwZTkzLCAweDBlOTgsIDB4MGU5OCwgMHgwZWEwLCAweDBlYTAsIDB4MGVhNCwgMHgwZWE0LCAweDBlYTYsIDB4MGVhNiwgMHgwZWE4LCAweDBlYTksIDB4MGVhYywgMHgwZWFjLCAweDBlYmEsIDB4MGViYSwgMHgwZWJlLCAweDBlYmYsIDB4MGVjNSwgMHgwZWM1LCAweDBlYzcsIDB4MGVjNywgMHgwZWNlLCAweDBlY2YsIDB4MGVkYSwgMHgwZWRiLCAweDBlZGUsIDB4MGVmZiwgMHgwZjQ4LCAweDBmNDgsIDB4MGY2YiwgMHgwZjcwLCAweDBmOGMsIDB4MGY4ZiwgMHgwZjk4LCAweDBmOTgsIDB4MGZiZCwgMHgwZmJkLCAweDBmY2QsIDB4MGZjZSwgMHgwZmQwLCAweDBmZmYsIDB4MTAyMiwgMHgxMDIyLCAweDEwMjgsIDB4MTAyOCwgMHgxMDJiLCAweDEwMmIsIDB4MTAzMywgMHgxMDM1LCAweDEwM2EsIDB4MTAzZiwgMHgxMDVhLCAweDEwOWYsIDB4MTBjNiwgMHgxMGNmLCAweDEwZjksIDB4MTBmYSwgMHgxMGZjLCAweDEwZmYsIDB4MTE1YSwgMHgxMTVlLCAweDExYTMsIDB4MTFhNywgMHgxMWZhLCAweDExZmYsIDB4MTIwNywgMHgxMjA3LCAweDEyNDcsIDB4MTI0NywgMHgxMjQ5LCAweDEyNDksIDB4MTI0ZSwgMHgxMjRmLCAweDEyNTcsIDB4MTI1NywgMHgxMjU5LCAweDEyNTksIDB4MTI1ZSwgMHgxMjVmLCAweDEyODcsIDB4MTI4NywgMHgxMjg5LCAweDEyODksIDB4MTI4ZSwgMHgxMjhmLCAweDEyYWYsIDB4MTJhZiwgMHgxMmIxLCAweDEyYjEsIDB4MTJiNiwgMHgxMmI3LCAweDEyYmYsIDB4MTJiZiwgMHgxMmMxLCAweDEyYzEsIDB4MTJjNiwgMHgxMmM3LCAweDEyY2YsIDB4MTJjZiwgMHgxMmQ3LCAweDEyZDcsIDB4MTJlZiwgMHgxMmVmLCAweDEzMGYsIDB4MTMwZiwgMHgxMzExLCAweDEzMTEsIDB4MTMxNiwgMHgxMzE3LCAweDEzMWYsIDB4MTMxZiwgMHgxMzQ3LCAweDEzNDcsIDB4MTM1YiwgMHgxMzYwLCAweDEzN2QsIDB4MTM5ZiwgMHgxM2Y1LCAweDE0MDAsIDB4MTY3NywgMHgxNjdmLCAweDE2OWQsIDB4MTY5ZiwgMHgxNmYxLCAweDE2ZmYsIDB4MTcwZCwgMHgxNzBkLCAweDE3MTUsIDB4MTcxZiwgMHgxNzM3LCAweDE3M2YsIDB4MTc1NCwgMHgxNzVmLCAweDE3NmQsIDB4MTc2ZCwgMHgxNzcxLCAweDE3NzEsIDB4MTc3NCwgMHgxNzdmLCAweDE3ZGQsIDB4MTdkZiwgMHgxN2VhLCAweDE3ZmYsIDB4MTgwZiwgMHgxODBmLCAweDE4MWEsIDB4MTgxZiwgMHgxODc4LCAweDE4N2YsIDB4MThhYSwgMHgxZGZmLCAweDFlOWMsIDB4MWU5ZiwgMHgxZWZhLCAweDFlZmYsIDB4MWYxNiwgMHgxZjE3LCAweDFmMWUsIDB4MWYxZiwgMHgxZjQ2LCAweDFmNDcsIDB4MWY0ZSwgMHgxZjRmLCAweDFmNTgsIDB4MWY1OCwgMHgxZjVhLCAweDFmNWEsIDB4MWY1YywgMHgxZjVjLCAweDFmNWUsIDB4MWY1ZSwgMHgxZjdlLCAweDFmN2YsIDB4MWZiNSwgMHgxZmI1LCAweDFmYzUsIDB4MWZjNSwgMHgxZmQ0LCAweDFmZDUsIDB4MWZkYywgMHgxZmRjLCAweDFmZjAsIDB4MWZmMSwgMHgxZmY1LCAweDFmZjUsIDB4MWZmZiwgMHgxZmZmLCAweDIwNTMsIDB4MjA1NiwgMHgyMDU4LCAweDIwNWUsIDB4MjA2NCwgMHgyMDY5LCAweDIwNzIsIDB4MjA3MywgMHgyMDhmLCAweDIwOWYsIDB4MjBiMiwgMHgyMGNmLCAweDIwZWIsIDB4MjBmZiwgMHgyMTNiLCAweDIxM2MsIDB4MjE0YywgMHgyMTUyLCAweDIxODQsIDB4MjE4ZiwgMHgyM2NmLCAweDIzZmYsIDB4MjQyNywgMHgyNDNmLCAweDI0NGIsIDB4MjQ1ZiwgMHgyNGZmLCAweDI0ZmYsIDB4MjYxNCwgMHgyNjE1LCAweDI2MTgsIDB4MjYxOCwgMHgyNjdlLCAweDI2N2YsIDB4MjY4YSwgMHgyNzAwLCAweDI3MDUsIDB4MjcwNSwgMHgyNzBhLCAweDI3MGIsIDB4MjcyOCwgMHgyNzI4LCAweDI3NGMsIDB4Mjc0YywgMHgyNzRlLCAweDI3NGUsIDB4Mjc1MywgMHgyNzU1LCAweDI3NTcsIDB4Mjc1NywgMHgyNzVmLCAweDI3NjAsIDB4Mjc5NSwgMHgyNzk3LCAweDI3YjAsIDB4MjdiMCwgMHgyN2JmLCAweDI3Y2YsIDB4MjdlYywgMHgyN2VmLCAweDJiMDAsIDB4MmU3ZiwgMHgyZTlhLCAweDJlOWEsIDB4MmVmNCwgMHgyZWZmLCAweDJmZDYsIDB4MmZlZiwgMHgyZmZjLCAweDJmZmYsIDB4MzA0MCwgMHgzMDQwLCAweDMwOTcsIDB4MzA5OCwgMHgzMTAwLCAweDMxMDQsIDB4MzEyZCwgMHgzMTMwLCAweDMxOGYsIDB4MzE4ZiwgMHgzMWI4LCAweDMxZWYsIDB4MzIxZCwgMHgzMjFmLCAweDMyNDQsIDB4MzI1MCwgMHgzMjdjLCAweDMyN2UsIDB4MzJjYywgMHgzMmNmLCAweDMyZmYsIDB4MzJmZiwgMHgzMzc3LCAweDMzN2EsIDB4MzNkZSwgMHgzM2RmLCAweDMzZmYsIDB4MzNmZiwgMHg0ZGI2LCAweDRkZmYsIDB4OWZhNiwgMHg5ZmZmLCAweGE0OGQsIDB4YTQ4ZiwgMHhhNGM3LCAweGFiZmYsIDB4ZDdhNCwgMHhkN2ZmLCAweGZhMmUsIDB4ZmEyZiwgMHhmYTZiLCAweGZhZmYsIDB4ZmIwNywgMHhmYjEyLCAweGZiMTgsIDB4ZmIxYywgMHhmYjM3LCAweGZiMzcsIDB4ZmIzZCwgMHhmYjNkLCAweGZiM2YsIDB4ZmIzZiwgMHhmYjQyLCAweGZiNDIsIDB4ZmI0NSwgMHhmYjQ1LCAweGZiYjIsIDB4ZmJkMiwgMHhmZDQwLCAweGZkNGYsIDB4ZmQ5MCwgMHhmZDkxLCAweGZkYzgsIDB4ZmRjZiwgMHhmZGZkLCAweGZkZmYsIDB4ZmUxMCwgMHhmZTFmLCAweGZlMjQsIDB4ZmUyZiwgMHhmZTQ3LCAweGZlNDgsIDB4ZmU1MywgMHhmZTUzLCAweGZlNjcsIDB4ZmU2NywgMHhmZTZjLCAweGZlNmYsIDB4ZmU3NSwgMHhmZTc1LCAweGZlZmQsIDB4ZmVmZSwgMHhmZjAwLCAweGZmMDAsIDB4ZmZiZiwgMHhmZmMxLCAweGZmYzgsIDB4ZmZjOSwgMHhmZmQwLCAweGZmZDEsIDB4ZmZkOCwgMHhmZmQ5LCAweGZmZGQsIDB4ZmZkZiwgMHhmZmU3LCAweGZmZTcsIDB4ZmZlZiwgMHhmZmY4LCAweDEwMDAwLCAweDEwMmZmLCAweDEwMzFmLCAweDEwMzFmLCAweDEwMzI0LCAweDEwMzJmLCAweDEwMzRiLCAweDEwM2ZmLCAweDEwNDI2LCAweDEwNDI3LCAweDEwNDRlLCAweDFjZmZmLCAweDFkMGY2LCAweDFkMGZmLCAweDFkMTI3LCAweDFkMTI5LCAweDFkMWRlLCAweDFkM2ZmLCAweDFkNDU1LCAweDFkNDU1LCAweDFkNDlkLCAweDFkNDlkLCAweDFkNGEwLCAweDFkNGExLCAweDFkNGEzLCAweDFkNGE0LCAweDFkNGE3LCAweDFkNGE4LCAweDFkNGFkLCAweDFkNGFkLCAweDFkNGJhLCAweDFkNGJhLCAweDFkNGJjLCAweDFkNGJjLCAweDFkNGMxLCAweDFkNGMxLCAweDFkNGM0LCAweDFkNGM0LCAweDFkNTA2LCAweDFkNTA2LCAweDFkNTBiLCAweDFkNTBjLCAweDFkNTE1LCAweDFkNTE1LCAweDFkNTFkLCAweDFkNTFkLCAweDFkNTNhLCAweDFkNTNhLCAweDFkNTNmLCAweDFkNTNmLCAweDFkNTQ1LCAweDFkNTQ1LCAweDFkNTQ3LCAweDFkNTQ5LCAweDFkNTUxLCAweDFkNTUxLCAweDFkNmE0LCAweDFkNmE3LCAweDFkN2NhLCAweDFkN2NkLCAweDFkODAwLCAweDFmZmZkLCAweDJhNmQ3LCAweDJmN2ZmLCAweDJmYTFlLCAweDJmZmZkLCAweDMwMDAwLCAweDNmZmZkLCAweDQwMDAwLCAweDRmZmZkLCAweDUwMDAwLCAweDVmZmZkLCAweDYwMDAwLCAweDZmZmZkLCAweDcwMDAwLCAweDdmZmZkLCAweDgwMDAwLCAweDhmZmZkLCAweDkwMDAwLCAweDlmZmZkLCAweGEwMDAwLCAweGFmZmZkLCAweGIwMDAwLCAweGJmZmZkLCAweGMwMDAwLCAweGNmZmZkLCAweGQwMDAwLCAweGRmZmZkLCAweGUwMDAwLCAweGUwMDAwLCAweGUwMDAyLCAweGUwMDFmLCAweGUwMDgwLCAweGVmZmZkXTsgLy8gcHJldHRpZXItaWdub3JlLWVuZFxuXG52YXIgaXNVbmFzc2lnbmVkQ29kZVBvaW50ID0gZnVuY3Rpb24gaXNVbmFzc2lnbmVkQ29kZVBvaW50KGNoYXJhY3Rlcikge1xuICByZXR1cm4gaW5SYW5nZShjaGFyYWN0ZXIsIHVuYXNzaWduZWRfY29kZV9wb2ludHMpO1xufTsgLy8gcHJldHRpZXItaWdub3JlLXN0YXJ0XG5cbi8qKlxyXG4gKiBCLjEgQ29tbW9ubHkgbWFwcGVkIHRvIG5vdGhpbmdcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQi4xXHJcbiAqL1xuXG5cbnZhciBjb21tb25seV9tYXBwZWRfdG9fbm90aGluZyA9IFsweDAwYWQsIDB4MDBhZCwgMHgwMzRmLCAweDAzNGYsIDB4MTgwNiwgMHgxODA2LCAweDE4MGIsIDB4MTgwYiwgMHgxODBjLCAweDE4MGMsIDB4MTgwZCwgMHgxODBkLCAweDIwMGIsIDB4MjAwYiwgMHgyMDBjLCAweDIwMGMsIDB4MjAwZCwgMHgyMDBkLCAweDIwNjAsIDB4MjA2MCwgMHhmZTAwLCAweGZlMDAsIDB4ZmUwMSwgMHhmZTAxLCAweGZlMDIsIDB4ZmUwMiwgMHhmZTAzLCAweGZlMDMsIDB4ZmUwNCwgMHhmZTA0LCAweGZlMDUsIDB4ZmUwNSwgMHhmZTA2LCAweGZlMDYsIDB4ZmUwNywgMHhmZTA3LCAweGZlMDgsIDB4ZmUwOCwgMHhmZTA5LCAweGZlMDksIDB4ZmUwYSwgMHhmZTBhLCAweGZlMGIsIDB4ZmUwYiwgMHhmZTBjLCAweGZlMGMsIDB4ZmUwZCwgMHhmZTBkLCAweGZlMGUsIDB4ZmUwZSwgMHhmZTBmLCAweGZlMGYsIDB4ZmVmZiwgMHhmZWZmXTsgLy8gcHJldHRpZXItaWdub3JlLWVuZFxuXG52YXIgaXNDb21tb25seU1hcHBlZFRvTm90aGluZyA9IGZ1bmN0aW9uIGlzQ29tbW9ubHlNYXBwZWRUb05vdGhpbmcoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBpblJhbmdlKGNoYXJhY3RlciwgY29tbW9ubHlfbWFwcGVkX3RvX25vdGhpbmcpO1xufTsgLy8gcHJldHRpZXItaWdub3JlLXN0YXJ0XG5cbi8qKlxyXG4gKiBDLjEuMiBOb24tQVNDSUkgc3BhY2UgY2hhcmFjdGVyc1xyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjEuMlxyXG4gKi9cblxuXG52YXIgbm9uX0FTQ0lJX3NwYWNlX2NoYXJhY3RlcnMgPSBbMHgwMGEwLCAweDAwYTBcbi8qIE5PLUJSRUFLIFNQQUNFICovXG4sIDB4MTY4MCwgMHgxNjgwXG4vKiBPR0hBTSBTUEFDRSBNQVJLICovXG4sIDB4MjAwMCwgMHgyMDAwXG4vKiBFTiBRVUFEICovXG4sIDB4MjAwMSwgMHgyMDAxXG4vKiBFTSBRVUFEICovXG4sIDB4MjAwMiwgMHgyMDAyXG4vKiBFTiBTUEFDRSAqL1xuLCAweDIwMDMsIDB4MjAwM1xuLyogRU0gU1BBQ0UgKi9cbiwgMHgyMDA0LCAweDIwMDRcbi8qIFRIUkVFLVBFUi1FTSBTUEFDRSAqL1xuLCAweDIwMDUsIDB4MjAwNVxuLyogRk9VUi1QRVItRU0gU1BBQ0UgKi9cbiwgMHgyMDA2LCAweDIwMDZcbi8qIFNJWC1QRVItRU0gU1BBQ0UgKi9cbiwgMHgyMDA3LCAweDIwMDdcbi8qIEZJR1VSRSBTUEFDRSAqL1xuLCAweDIwMDgsIDB4MjAwOFxuLyogUFVOQ1RVQVRJT04gU1BBQ0UgKi9cbiwgMHgyMDA5LCAweDIwMDlcbi8qIFRISU4gU1BBQ0UgKi9cbiwgMHgyMDBhLCAweDIwMGFcbi8qIEhBSVIgU1BBQ0UgKi9cbiwgMHgyMDBiLCAweDIwMGJcbi8qIFpFUk8gV0lEVEggU1BBQ0UgKi9cbiwgMHgyMDJmLCAweDIwMmZcbi8qIE5BUlJPVyBOTy1CUkVBSyBTUEFDRSAqL1xuLCAweDIwNWYsIDB4MjA1ZlxuLyogTUVESVVNIE1BVEhFTUFUSUNBTCBTUEFDRSAqL1xuLCAweDMwMDAsIDB4MzAwMFxuLyogSURFT0dSQVBISUMgU1BBQ0UgKi9cbl07IC8vIHByZXR0aWVyLWlnbm9yZS1lbmRcblxudmFyIGlzTm9uQVNDSUlTcGFjZUNoYXJhY3RlciA9IGZ1bmN0aW9uIGlzTm9uQVNDSUlTcGFjZUNoYXJhY3RlcihjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIGluUmFuZ2UoY2hhcmFjdGVyLCBub25fQVNDSUlfc3BhY2VfY2hhcmFjdGVycyk7XG59OyAvLyBwcmV0dGllci1pZ25vcmUtc3RhcnRcblxuXG52YXIgbm9uX0FTQ0lJX2NvbnRyb2xzX2NoYXJhY3RlcnMgPSBbXG4vKipcclxuICogQy4yLjIgTm9uLUFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyc1xyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjIuMlxyXG4gKi9cbjB4MDA4MCwgMHgwMDlmXG4vKiBbQ09OVFJPTCBDSEFSQUNURVJTXSAqL1xuLCAweDA2ZGQsIDB4MDZkZFxuLyogQVJBQklDIEVORCBPRiBBWUFIICovXG4sIDB4MDcwZiwgMHgwNzBmXG4vKiBTWVJJQUMgQUJCUkVWSUFUSU9OIE1BUksgKi9cbiwgMHgxODBlLCAweDE4MGVcbi8qIE1PTkdPTElBTiBWT1dFTCBTRVBBUkFUT1IgKi9cbiwgMHgyMDBjLCAweDIwMGNcbi8qIFpFUk8gV0lEVEggTk9OLUpPSU5FUiAqL1xuLCAweDIwMGQsIDB4MjAwZFxuLyogWkVSTyBXSURUSCBKT0lORVIgKi9cbiwgMHgyMDI4LCAweDIwMjhcbi8qIExJTkUgU0VQQVJBVE9SICovXG4sIDB4MjAyOSwgMHgyMDI5XG4vKiBQQVJBR1JBUEggU0VQQVJBVE9SICovXG4sIDB4MjA2MCwgMHgyMDYwXG4vKiBXT1JEIEpPSU5FUiAqL1xuLCAweDIwNjEsIDB4MjA2MVxuLyogRlVOQ1RJT04gQVBQTElDQVRJT04gKi9cbiwgMHgyMDYyLCAweDIwNjJcbi8qIElOVklTSUJMRSBUSU1FUyAqL1xuLCAweDIwNjMsIDB4MjA2M1xuLyogSU5WSVNJQkxFIFNFUEFSQVRPUiAqL1xuLCAweDIwNmEsIDB4MjA2ZlxuLyogW0NPTlRST0wgQ0hBUkFDVEVSU10gKi9cbiwgMHhmZWZmLCAweGZlZmZcbi8qIFpFUk8gV0lEVEggTk8tQlJFQUsgU1BBQ0UgKi9cbiwgMHhmZmY5LCAweGZmZmNcbi8qIFtDT05UUk9MIENIQVJBQ1RFUlNdICovXG4sIDB4MWQxNzMsIDB4MWQxN2Fcbi8qIFtNVVNJQ0FMIENPTlRST0wgQ0hBUkFDVEVSU10gKi9cbl07XG52YXIgbm9uX2NoYXJhY3Rlcl9jb2RlcG9pbnRzID0gW1xuLyoqXHJcbiAqIEMuNCBOb24tY2hhcmFjdGVyIGNvZGUgcG9pbnRzXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUMuNFxyXG4gKi9cbjB4ZmRkMCwgMHhmZGVmXG4vKiBbTk9OQ0hBUkFDVEVSIENPREUgUE9JTlRTXSAqL1xuLCAweGZmZmUsIDB4ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHgxZmZmZSwgMHgxZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHgyZmZmZSwgMHgyZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHgzZmZmZSwgMHgzZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHg0ZmZmZSwgMHg0ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHg1ZmZmZSwgMHg1ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHg2ZmZmZSwgMHg2ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHg3ZmZmZSwgMHg3ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHg4ZmZmZSwgMHg4ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHg5ZmZmZSwgMHg5ZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHhhZmZmZSwgMHhhZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHhiZmZmZSwgMHhiZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHhjZmZmZSwgMHhjZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHhkZmZmZSwgMHhkZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHhlZmZmZSwgMHhlZmZmZlxuLyogW05PTkNIQVJBQ1RFUiBDT0RFIFBPSU5UU10gKi9cbiwgMHgxMGZmZmUsIDB4MTBmZmZmXG4vKiBbTk9OQ0hBUkFDVEVSIENPREUgUE9JTlRTXSAqL1xuXTtcbi8qKlxyXG4gKiAyLjMuICBQcm9oaWJpdGVkIE91dHB1dFxyXG4gKi9cblxudmFyIHByb2hpYml0ZWRfY2hhcmFjdGVycyA9IFtcbi8qKlxyXG4gKiBDLjIuMSBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnNcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy4yLjFcclxuICovXG4wLCAweDAwMWZcbi8qIFtDT05UUk9MIENIQVJBQ1RFUlNdICovXG4sIDB4MDA3ZiwgMHgwMDdmXG4vKiBERUxFVEUgKi9cbixcbi8qKlxyXG4gKiBDLjggQ2hhbmdlIGRpc3BsYXkgcHJvcGVydGllcyBvciBhcmUgZGVwcmVjYXRlZFxyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjhcclxuICovXG4weDAzNDAsIDB4MDM0MFxuLyogQ09NQklOSU5HIEdSQVZFIFRPTkUgTUFSSyAqL1xuLCAweDAzNDEsIDB4MDM0MVxuLyogQ09NQklOSU5HIEFDVVRFIFRPTkUgTUFSSyAqL1xuLCAweDIwMGUsIDB4MjAwZVxuLyogTEVGVC1UTy1SSUdIVCBNQVJLICovXG4sIDB4MjAwZiwgMHgyMDBmXG4vKiBSSUdIVC1UTy1MRUZUIE1BUksgKi9cbiwgMHgyMDJhLCAweDIwMmFcbi8qIExFRlQtVE8tUklHSFQgRU1CRURESU5HICovXG4sIDB4MjAyYiwgMHgyMDJiXG4vKiBSSUdIVC1UTy1MRUZUIEVNQkVERElORyAqL1xuLCAweDIwMmMsIDB4MjAyY1xuLyogUE9QIERJUkVDVElPTkFMIEZPUk1BVFRJTkcgKi9cbiwgMHgyMDJkLCAweDIwMmRcbi8qIExFRlQtVE8tUklHSFQgT1ZFUlJJREUgKi9cbiwgMHgyMDJlLCAweDIwMmVcbi8qIFJJR0hULVRPLUxFRlQgT1ZFUlJJREUgKi9cbiwgMHgyMDZhLCAweDIwNmFcbi8qIElOSElCSVQgU1lNTUVUUklDIFNXQVBQSU5HICovXG4sIDB4MjA2YiwgMHgyMDZiXG4vKiBBQ1RJVkFURSBTWU1NRVRSSUMgU1dBUFBJTkcgKi9cbiwgMHgyMDZjLCAweDIwNmNcbi8qIElOSElCSVQgQVJBQklDIEZPUk0gU0hBUElORyAqL1xuLCAweDIwNmQsIDB4MjA2ZFxuLyogQUNUSVZBVEUgQVJBQklDIEZPUk0gU0hBUElORyAqL1xuLCAweDIwNmUsIDB4MjA2ZVxuLyogTkFUSU9OQUwgRElHSVQgU0hBUEVTICovXG4sIDB4MjA2ZiwgMHgyMDZmXG4vKiBOT01JTkFMIERJR0lUIFNIQVBFUyAqL1xuLFxuLyoqXHJcbiAqIEMuNyBJbmFwcHJvcHJpYXRlIGZvciBjYW5vbmljYWwgcmVwcmVzZW50YXRpb25cclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy43XHJcbiAqL1xuMHgyZmYwLCAweDJmZmJcbi8qIFtJREVPR1JBUEhJQyBERVNDUklQVElPTiBDSEFSQUNURVJTXSAqL1xuLFxuLyoqXHJcbiAqIEMuNSBTdXJyb2dhdGUgY29kZXNcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy41XHJcbiAqL1xuMHhkODAwLCAweGRmZmYsXG4vKipcclxuICogQy4zIFByaXZhdGUgdXNlXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUMuM1xyXG4gKi9cbjB4ZTAwMCwgMHhmOGZmXG4vKiBbUFJJVkFURSBVU0UsIFBMQU5FIDBdICovXG4sXG4vKipcclxuICogQy42IEluYXBwcm9wcmlhdGUgZm9yIHBsYWluIHRleHRcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtQy42XHJcbiAqL1xuMHhmZmY5LCAweGZmZjlcbi8qIElOVEVSTElORUFSIEFOTk9UQVRJT04gQU5DSE9SICovXG4sIDB4ZmZmYSwgMHhmZmZhXG4vKiBJTlRFUkxJTkVBUiBBTk5PVEFUSU9OIFNFUEFSQVRPUiAqL1xuLCAweGZmZmIsIDB4ZmZmYlxuLyogSU5URVJMSU5FQVIgQU5OT1RBVElPTiBURVJNSU5BVE9SICovXG4sIDB4ZmZmYywgMHhmZmZjXG4vKiBPQkpFQ1QgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSICovXG4sIDB4ZmZmZCwgMHhmZmZkXG4vKiBSRVBMQUNFTUVOVCBDSEFSQUNURVIgKi9cbixcbi8qKlxyXG4gKiBDLjkgVGFnZ2luZyBjaGFyYWN0ZXJzXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUMuOVxyXG4gKi9cbjB4ZTAwMDEsIDB4ZTAwMDFcbi8qIExBTkdVQUdFIFRBRyAqL1xuLCAweGUwMDIwLCAweGUwMDdmXG4vKiBbVEFHR0lORyBDSEFSQUNURVJTXSAqL1xuLFxuLyoqXHJcbiAqIEMuMyBQcml2YXRlIHVzZVxyXG4gKiBAbGluayBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNhcHBlbmRpeC1DLjNcclxuICovXG4weGYwMDAwLCAweGZmZmZkXG4vKiBbUFJJVkFURSBVU0UsIFBMQU5FIDE1XSAqL1xuLCAweDEwMDAwMCwgMHgxMGZmZmRcbi8qIFtQUklWQVRFIFVTRSwgUExBTkUgMTZdICovXG5dOyAvLyBwcmV0dGllci1pZ25vcmUtZW5kXG5cbnZhciBpc1Byb2hpYml0ZWRDaGFyYWN0ZXIgPSBmdW5jdGlvbiBpc1Byb2hpYml0ZWRDaGFyYWN0ZXIoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBpblJhbmdlKGNoYXJhY3Rlciwgbm9uX0FTQ0lJX3NwYWNlX2NoYXJhY3RlcnMpIHx8IGluUmFuZ2UoY2hhcmFjdGVyLCBwcm9oaWJpdGVkX2NoYXJhY3RlcnMpIHx8IGluUmFuZ2UoY2hhcmFjdGVyLCBub25fQVNDSUlfY29udHJvbHNfY2hhcmFjdGVycykgfHwgaW5SYW5nZShjaGFyYWN0ZXIsIG5vbl9jaGFyYWN0ZXJfY29kZXBvaW50cyk7XG59OyAvLyBwcmV0dGllci1pZ25vcmUtc3RhcnRcblxuLyoqXHJcbiAqIEQuMSBDaGFyYWN0ZXJzIHdpdGggYmlkaXJlY3Rpb25hbCBwcm9wZXJ0eSBcIlJcIiBvciBcIkFMXCJcclxuICogQGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0NTQjYXBwZW5kaXgtRC4xXHJcbiAqL1xuXG5cbnZhciBiaWRpcmVjdGlvbmFsX3JfYWwgPSBbMHgwNWJlLCAweDA1YmUsIDB4MDVjMCwgMHgwNWMwLCAweDA1YzMsIDB4MDVjMywgMHgwNWQwLCAweDA1ZWEsIDB4MDVmMCwgMHgwNWY0LCAweDA2MWIsIDB4MDYxYiwgMHgwNjFmLCAweDA2MWYsIDB4MDYyMSwgMHgwNjNhLCAweDA2NDAsIDB4MDY0YSwgMHgwNjZkLCAweDA2NmYsIDB4MDY3MSwgMHgwNmQ1LCAweDA2ZGQsIDB4MDZkZCwgMHgwNmU1LCAweDA2ZTYsIDB4MDZmYSwgMHgwNmZlLCAweDA3MDAsIDB4MDcwZCwgMHgwNzEwLCAweDA3MTAsIDB4MDcxMiwgMHgwNzJjLCAweDA3ODAsIDB4MDdhNSwgMHgwN2IxLCAweDA3YjEsIDB4MjAwZiwgMHgyMDBmLCAweGZiMWQsIDB4ZmIxZCwgMHhmYjFmLCAweGZiMjgsIDB4ZmIyYSwgMHhmYjM2LCAweGZiMzgsIDB4ZmIzYywgMHhmYjNlLCAweGZiM2UsIDB4ZmI0MCwgMHhmYjQxLCAweGZiNDMsIDB4ZmI0NCwgMHhmYjQ2LCAweGZiYjEsIDB4ZmJkMywgMHhmZDNkLCAweGZkNTAsIDB4ZmQ4ZiwgMHhmZDkyLCAweGZkYzcsIDB4ZmRmMCwgMHhmZGZjLCAweGZlNzAsIDB4ZmU3NCwgMHhmZTc2LCAweGZlZmNdOyAvLyBwcmV0dGllci1pZ25vcmUtZW5kXG5cbnZhciBpc0JpZGlyZWN0aW9uYWxSQUwgPSBmdW5jdGlvbiBpc0JpZGlyZWN0aW9uYWxSQUwoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBpblJhbmdlKGNoYXJhY3RlciwgYmlkaXJlY3Rpb25hbF9yX2FsKTtcbn07IC8vIHByZXR0aWVyLWlnbm9yZS1zdGFydFxuXG4vKipcclxuICogRC4yIENoYXJhY3RlcnMgd2l0aCBiaWRpcmVjdGlvbmFsIHByb3BlcnR5IFwiTFwiXHJcbiAqIEBsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDU0I2FwcGVuZGl4LUQuMlxyXG4gKi9cblxuXG52YXIgYmlkaXJlY3Rpb25hbF9sID0gWzB4MDA0MSwgMHgwMDVhLCAweDAwNjEsIDB4MDA3YSwgMHgwMGFhLCAweDAwYWEsIDB4MDBiNSwgMHgwMGI1LCAweDAwYmEsIDB4MDBiYSwgMHgwMGMwLCAweDAwZDYsIDB4MDBkOCwgMHgwMGY2LCAweDAwZjgsIDB4MDIyMCwgMHgwMjIyLCAweDAyMzMsIDB4MDI1MCwgMHgwMmFkLCAweDAyYjAsIDB4MDJiOCwgMHgwMmJiLCAweDAyYzEsIDB4MDJkMCwgMHgwMmQxLCAweDAyZTAsIDB4MDJlNCwgMHgwMmVlLCAweDAyZWUsIDB4MDM3YSwgMHgwMzdhLCAweDAzODYsIDB4MDM4NiwgMHgwMzg4LCAweDAzOGEsIDB4MDM4YywgMHgwMzhjLCAweDAzOGUsIDB4MDNhMSwgMHgwM2EzLCAweDAzY2UsIDB4MDNkMCwgMHgwM2Y1LCAweDA0MDAsIDB4MDQ4MiwgMHgwNDhhLCAweDA0Y2UsIDB4MDRkMCwgMHgwNGY1LCAweDA0ZjgsIDB4MDRmOSwgMHgwNTAwLCAweDA1MGYsIDB4MDUzMSwgMHgwNTU2LCAweDA1NTksIDB4MDU1ZiwgMHgwNTYxLCAweDA1ODcsIDB4MDU4OSwgMHgwNTg5LCAweDA5MDMsIDB4MDkwMywgMHgwOTA1LCAweDA5MzksIDB4MDkzZCwgMHgwOTQwLCAweDA5NDksIDB4MDk0YywgMHgwOTUwLCAweDA5NTAsIDB4MDk1OCwgMHgwOTYxLCAweDA5NjQsIDB4MDk3MCwgMHgwOTgyLCAweDA5ODMsIDB4MDk4NSwgMHgwOThjLCAweDA5OGYsIDB4MDk5MCwgMHgwOTkzLCAweDA5YTgsIDB4MDlhYSwgMHgwOWIwLCAweDA5YjIsIDB4MDliMiwgMHgwOWI2LCAweDA5YjksIDB4MDliZSwgMHgwOWMwLCAweDA5YzcsIDB4MDljOCwgMHgwOWNiLCAweDA5Y2MsIDB4MDlkNywgMHgwOWQ3LCAweDA5ZGMsIDB4MDlkZCwgMHgwOWRmLCAweDA5ZTEsIDB4MDllNiwgMHgwOWYxLCAweDA5ZjQsIDB4MDlmYSwgMHgwYTA1LCAweDBhMGEsIDB4MGEwZiwgMHgwYTEwLCAweDBhMTMsIDB4MGEyOCwgMHgwYTJhLCAweDBhMzAsIDB4MGEzMiwgMHgwYTMzLCAweDBhMzUsIDB4MGEzNiwgMHgwYTM4LCAweDBhMzksIDB4MGEzZSwgMHgwYTQwLCAweDBhNTksIDB4MGE1YywgMHgwYTVlLCAweDBhNWUsIDB4MGE2NiwgMHgwYTZmLCAweDBhNzIsIDB4MGE3NCwgMHgwYTgzLCAweDBhODMsIDB4MGE4NSwgMHgwYThiLCAweDBhOGQsIDB4MGE4ZCwgMHgwYThmLCAweDBhOTEsIDB4MGE5MywgMHgwYWE4LCAweDBhYWEsIDB4MGFiMCwgMHgwYWIyLCAweDBhYjMsIDB4MGFiNSwgMHgwYWI5LCAweDBhYmQsIDB4MGFjMCwgMHgwYWM5LCAweDBhYzksIDB4MGFjYiwgMHgwYWNjLCAweDBhZDAsIDB4MGFkMCwgMHgwYWUwLCAweDBhZTAsIDB4MGFlNiwgMHgwYWVmLCAweDBiMDIsIDB4MGIwMywgMHgwYjA1LCAweDBiMGMsIDB4MGIwZiwgMHgwYjEwLCAweDBiMTMsIDB4MGIyOCwgMHgwYjJhLCAweDBiMzAsIDB4MGIzMiwgMHgwYjMzLCAweDBiMzYsIDB4MGIzOSwgMHgwYjNkLCAweDBiM2UsIDB4MGI0MCwgMHgwYjQwLCAweDBiNDcsIDB4MGI0OCwgMHgwYjRiLCAweDBiNGMsIDB4MGI1NywgMHgwYjU3LCAweDBiNWMsIDB4MGI1ZCwgMHgwYjVmLCAweDBiNjEsIDB4MGI2NiwgMHgwYjcwLCAweDBiODMsIDB4MGI4MywgMHgwYjg1LCAweDBiOGEsIDB4MGI4ZSwgMHgwYjkwLCAweDBiOTIsIDB4MGI5NSwgMHgwYjk5LCAweDBiOWEsIDB4MGI5YywgMHgwYjljLCAweDBiOWUsIDB4MGI5ZiwgMHgwYmEzLCAweDBiYTQsIDB4MGJhOCwgMHgwYmFhLCAweDBiYWUsIDB4MGJiNSwgMHgwYmI3LCAweDBiYjksIDB4MGJiZSwgMHgwYmJmLCAweDBiYzEsIDB4MGJjMiwgMHgwYmM2LCAweDBiYzgsIDB4MGJjYSwgMHgwYmNjLCAweDBiZDcsIDB4MGJkNywgMHgwYmU3LCAweDBiZjIsIDB4MGMwMSwgMHgwYzAzLCAweDBjMDUsIDB4MGMwYywgMHgwYzBlLCAweDBjMTAsIDB4MGMxMiwgMHgwYzI4LCAweDBjMmEsIDB4MGMzMywgMHgwYzM1LCAweDBjMzksIDB4MGM0MSwgMHgwYzQ0LCAweDBjNjAsIDB4MGM2MSwgMHgwYzY2LCAweDBjNmYsIDB4MGM4MiwgMHgwYzgzLCAweDBjODUsIDB4MGM4YywgMHgwYzhlLCAweDBjOTAsIDB4MGM5MiwgMHgwY2E4LCAweDBjYWEsIDB4MGNiMywgMHgwY2I1LCAweDBjYjksIDB4MGNiZSwgMHgwY2JlLCAweDBjYzAsIDB4MGNjNCwgMHgwY2M3LCAweDBjYzgsIDB4MGNjYSwgMHgwY2NiLCAweDBjZDUsIDB4MGNkNiwgMHgwY2RlLCAweDBjZGUsIDB4MGNlMCwgMHgwY2UxLCAweDBjZTYsIDB4MGNlZiwgMHgwZDAyLCAweDBkMDMsIDB4MGQwNSwgMHgwZDBjLCAweDBkMGUsIDB4MGQxMCwgMHgwZDEyLCAweDBkMjgsIDB4MGQyYSwgMHgwZDM5LCAweDBkM2UsIDB4MGQ0MCwgMHgwZDQ2LCAweDBkNDgsIDB4MGQ0YSwgMHgwZDRjLCAweDBkNTcsIDB4MGQ1NywgMHgwZDYwLCAweDBkNjEsIDB4MGQ2NiwgMHgwZDZmLCAweDBkODIsIDB4MGQ4MywgMHgwZDg1LCAweDBkOTYsIDB4MGQ5YSwgMHgwZGIxLCAweDBkYjMsIDB4MGRiYiwgMHgwZGJkLCAweDBkYmQsIDB4MGRjMCwgMHgwZGM2LCAweDBkY2YsIDB4MGRkMSwgMHgwZGQ4LCAweDBkZGYsIDB4MGRmMiwgMHgwZGY0LCAweDBlMDEsIDB4MGUzMCwgMHgwZTMyLCAweDBlMzMsIDB4MGU0MCwgMHgwZTQ2LCAweDBlNGYsIDB4MGU1YiwgMHgwZTgxLCAweDBlODIsIDB4MGU4NCwgMHgwZTg0LCAweDBlODcsIDB4MGU4OCwgMHgwZThhLCAweDBlOGEsIDB4MGU4ZCwgMHgwZThkLCAweDBlOTQsIDB4MGU5NywgMHgwZTk5LCAweDBlOWYsIDB4MGVhMSwgMHgwZWEzLCAweDBlYTUsIDB4MGVhNSwgMHgwZWE3LCAweDBlYTcsIDB4MGVhYSwgMHgwZWFiLCAweDBlYWQsIDB4MGViMCwgMHgwZWIyLCAweDBlYjMsIDB4MGViZCwgMHgwZWJkLCAweDBlYzAsIDB4MGVjNCwgMHgwZWM2LCAweDBlYzYsIDB4MGVkMCwgMHgwZWQ5LCAweDBlZGMsIDB4MGVkZCwgMHgwZjAwLCAweDBmMTcsIDB4MGYxYSwgMHgwZjM0LCAweDBmMzYsIDB4MGYzNiwgMHgwZjM4LCAweDBmMzgsIDB4MGYzZSwgMHgwZjQ3LCAweDBmNDksIDB4MGY2YSwgMHgwZjdmLCAweDBmN2YsIDB4MGY4NSwgMHgwZjg1LCAweDBmODgsIDB4MGY4YiwgMHgwZmJlLCAweDBmYzUsIDB4MGZjNywgMHgwZmNjLCAweDBmY2YsIDB4MGZjZiwgMHgxMDAwLCAweDEwMjEsIDB4MTAyMywgMHgxMDI3LCAweDEwMjksIDB4MTAyYSwgMHgxMDJjLCAweDEwMmMsIDB4MTAzMSwgMHgxMDMxLCAweDEwMzgsIDB4MTAzOCwgMHgxMDQwLCAweDEwNTcsIDB4MTBhMCwgMHgxMGM1LCAweDEwZDAsIDB4MTBmOCwgMHgxMGZiLCAweDEwZmIsIDB4MTEwMCwgMHgxMTU5LCAweDExNWYsIDB4MTFhMiwgMHgxMWE4LCAweDExZjksIDB4MTIwMCwgMHgxMjA2LCAweDEyMDgsIDB4MTI0NiwgMHgxMjQ4LCAweDEyNDgsIDB4MTI0YSwgMHgxMjRkLCAweDEyNTAsIDB4MTI1NiwgMHgxMjU4LCAweDEyNTgsIDB4MTI1YSwgMHgxMjVkLCAweDEyNjAsIDB4MTI4NiwgMHgxMjg4LCAweDEyODgsIDB4MTI4YSwgMHgxMjhkLCAweDEyOTAsIDB4MTJhZSwgMHgxMmIwLCAweDEyYjAsIDB4MTJiMiwgMHgxMmI1LCAweDEyYjgsIDB4MTJiZSwgMHgxMmMwLCAweDEyYzAsIDB4MTJjMiwgMHgxMmM1LCAweDEyYzgsIDB4MTJjZSwgMHgxMmQwLCAweDEyZDYsIDB4MTJkOCwgMHgxMmVlLCAweDEyZjAsIDB4MTMwZSwgMHgxMzEwLCAweDEzMTAsIDB4MTMxMiwgMHgxMzE1LCAweDEzMTgsIDB4MTMxZSwgMHgxMzIwLCAweDEzNDYsIDB4MTM0OCwgMHgxMzVhLCAweDEzNjEsIDB4MTM3YywgMHgxM2EwLCAweDEzZjQsIDB4MTQwMSwgMHgxNjc2LCAweDE2ODEsIDB4MTY5YSwgMHgxNmEwLCAweDE2ZjAsIDB4MTcwMCwgMHgxNzBjLCAweDE3MGUsIDB4MTcxMSwgMHgxNzIwLCAweDE3MzEsIDB4MTczNSwgMHgxNzM2LCAweDE3NDAsIDB4MTc1MSwgMHgxNzYwLCAweDE3NmMsIDB4MTc2ZSwgMHgxNzcwLCAweDE3ODAsIDB4MTdiNiwgMHgxN2JlLCAweDE3YzUsIDB4MTdjNywgMHgxN2M4LCAweDE3ZDQsIDB4MTdkYSwgMHgxN2RjLCAweDE3ZGMsIDB4MTdlMCwgMHgxN2U5LCAweDE4MTAsIDB4MTgxOSwgMHgxODIwLCAweDE4NzcsIDB4MTg4MCwgMHgxOGE4LCAweDFlMDAsIDB4MWU5YiwgMHgxZWEwLCAweDFlZjksIDB4MWYwMCwgMHgxZjE1LCAweDFmMTgsIDB4MWYxZCwgMHgxZjIwLCAweDFmNDUsIDB4MWY0OCwgMHgxZjRkLCAweDFmNTAsIDB4MWY1NywgMHgxZjU5LCAweDFmNTksIDB4MWY1YiwgMHgxZjViLCAweDFmNWQsIDB4MWY1ZCwgMHgxZjVmLCAweDFmN2QsIDB4MWY4MCwgMHgxZmI0LCAweDFmYjYsIDB4MWZiYywgMHgxZmJlLCAweDFmYmUsIDB4MWZjMiwgMHgxZmM0LCAweDFmYzYsIDB4MWZjYywgMHgxZmQwLCAweDFmZDMsIDB4MWZkNiwgMHgxZmRiLCAweDFmZTAsIDB4MWZlYywgMHgxZmYyLCAweDFmZjQsIDB4MWZmNiwgMHgxZmZjLCAweDIwMGUsIDB4MjAwZSwgMHgyMDcxLCAweDIwNzEsIDB4MjA3ZiwgMHgyMDdmLCAweDIxMDIsIDB4MjEwMiwgMHgyMTA3LCAweDIxMDcsIDB4MjEwYSwgMHgyMTEzLCAweDIxMTUsIDB4MjExNSwgMHgyMTE5LCAweDIxMWQsIDB4MjEyNCwgMHgyMTI0LCAweDIxMjYsIDB4MjEyNiwgMHgyMTI4LCAweDIxMjgsIDB4MjEyYSwgMHgyMTJkLCAweDIxMmYsIDB4MjEzMSwgMHgyMTMzLCAweDIxMzksIDB4MjEzZCwgMHgyMTNmLCAweDIxNDUsIDB4MjE0OSwgMHgyMTYwLCAweDIxODMsIDB4MjMzNiwgMHgyMzdhLCAweDIzOTUsIDB4MjM5NSwgMHgyNDljLCAweDI0ZTksIDB4MzAwNSwgMHgzMDA3LCAweDMwMjEsIDB4MzAyOSwgMHgzMDMxLCAweDMwMzUsIDB4MzAzOCwgMHgzMDNjLCAweDMwNDEsIDB4MzA5NiwgMHgzMDlkLCAweDMwOWYsIDB4MzBhMSwgMHgzMGZhLCAweDMwZmMsIDB4MzBmZiwgMHgzMTA1LCAweDMxMmMsIDB4MzEzMSwgMHgzMThlLCAweDMxOTAsIDB4MzFiNywgMHgzMWYwLCAweDMyMWMsIDB4MzIyMCwgMHgzMjQzLCAweDMyNjAsIDB4MzI3YiwgMHgzMjdmLCAweDMyYjAsIDB4MzJjMCwgMHgzMmNiLCAweDMyZDAsIDB4MzJmZSwgMHgzMzAwLCAweDMzNzYsIDB4MzM3YiwgMHgzM2RkLCAweDMzZTAsIDB4MzNmZSwgMHgzNDAwLCAweDRkYjUsIDB4NGUwMCwgMHg5ZmE1LCAweGEwMDAsIDB4YTQ4YywgMHhhYzAwLCAweGQ3YTMsIDB4ZDgwMCwgMHhmYTJkLCAweGZhMzAsIDB4ZmE2YSwgMHhmYjAwLCAweGZiMDYsIDB4ZmIxMywgMHhmYjE3LCAweGZmMjEsIDB4ZmYzYSwgMHhmZjQxLCAweGZmNWEsIDB4ZmY2NiwgMHhmZmJlLCAweGZmYzIsIDB4ZmZjNywgMHhmZmNhLCAweGZmY2YsIDB4ZmZkMiwgMHhmZmQ3LCAweGZmZGEsIDB4ZmZkYywgMHgxMDMwMCwgMHgxMDMxZSwgMHgxMDMyMCwgMHgxMDMyMywgMHgxMDMzMCwgMHgxMDM0YSwgMHgxMDQwMCwgMHgxMDQyNSwgMHgxMDQyOCwgMHgxMDQ0ZCwgMHgxZDAwMCwgMHgxZDBmNSwgMHgxZDEwMCwgMHgxZDEyNiwgMHgxZDEyYSwgMHgxZDE2NiwgMHgxZDE2YSwgMHgxZDE3MiwgMHgxZDE4MywgMHgxZDE4NCwgMHgxZDE4YywgMHgxZDFhOSwgMHgxZDFhZSwgMHgxZDFkZCwgMHgxZDQwMCwgMHgxZDQ1NCwgMHgxZDQ1NiwgMHgxZDQ5YywgMHgxZDQ5ZSwgMHgxZDQ5ZiwgMHgxZDRhMiwgMHgxZDRhMiwgMHgxZDRhNSwgMHgxZDRhNiwgMHgxZDRhOSwgMHgxZDRhYywgMHgxZDRhZSwgMHgxZDRiOSwgMHgxZDRiYiwgMHgxZDRiYiwgMHgxZDRiZCwgMHgxZDRjMCwgMHgxZDRjMiwgMHgxZDRjMywgMHgxZDRjNSwgMHgxZDUwNSwgMHgxZDUwNywgMHgxZDUwYSwgMHgxZDUwZCwgMHgxZDUxNCwgMHgxZDUxNiwgMHgxZDUxYywgMHgxZDUxZSwgMHgxZDUzOSwgMHgxZDUzYiwgMHgxZDUzZSwgMHgxZDU0MCwgMHgxZDU0NCwgMHgxZDU0NiwgMHgxZDU0NiwgMHgxZDU0YSwgMHgxZDU1MCwgMHgxZDU1MiwgMHgxZDZhMywgMHgxZDZhOCwgMHgxZDdjOSwgMHgyMDAwMCwgMHgyYTZkNiwgMHgyZjgwMCwgMHgyZmExZCwgMHhmMDAwMCwgMHhmZmZmZCwgMHgxMDAwMDAsIDB4MTBmZmZkXTsgLy8gcHJldHRpZXItaWdub3JlLWVuZFxuXG52YXIgaXNCaWRpcmVjdGlvbmFsTCA9IGZ1bmN0aW9uIGlzQmlkaXJlY3Rpb25hbEwoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBpblJhbmdlKGNoYXJhY3RlciwgYmlkaXJlY3Rpb25hbF9sKTtcbn07XG5cbi8qKlxyXG4gKiBub24tQVNDSUkgc3BhY2UgY2hhcmFjdGVycyBbU3RyaW5nUHJlcCwgQy4xLjJdIHRoYXQgY2FuIGJlXHJcbiAqIG1hcHBlZCB0byBTUEFDRSAoVSswMDIwKVxyXG4gKi9cblxudmFyIG1hcHBpbmcyc3BhY2UgPSBpc05vbkFTQ0lJU3BhY2VDaGFyYWN0ZXI7XG4vKipcclxuICogdGhlIFwiY29tbW9ubHkgbWFwcGVkIHRvIG5vdGhpbmdcIiBjaGFyYWN0ZXJzIFtTdHJpbmdQcmVwLCBCLjFdXHJcbiAqIHRoYXQgY2FuIGJlIG1hcHBlZCB0byBub3RoaW5nLlxyXG4gKi9cblxudmFyIG1hcHBpbmcybm90aGluZyA9IGlzQ29tbW9ubHlNYXBwZWRUb05vdGhpbmc7IC8vIHV0aWxzXG5cbnZhciBnZXRDb2RlUG9pbnQgPSBmdW5jdGlvbiBnZXRDb2RlUG9pbnQoY2hhcmFjdGVyKSB7XG4gIHJldHVybiBjaGFyYWN0ZXIuY29kZVBvaW50QXQoMCk7XG59O1xuXG52YXIgZmlyc3QgPSBmdW5jdGlvbiBmaXJzdCh4KSB7XG4gIHJldHVybiB4WzBdO1xufTtcblxudmFyIGxhc3QgPSBmdW5jdGlvbiBsYXN0KHgpIHtcbiAgcmV0dXJuIHhbeC5sZW5ndGggLSAxXTtcbn07XG4vKipcclxuICogQ29udmVydCBwcm92aWRlZCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBVbmljb2RlIENvZGUgUG9pbnRzLlxyXG4gKiBCYXNlZCBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjE0MDkxNjUvMTU1NjI0OVxyXG4gKiBhbmQgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY29kZS1wb2ludC1hdC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJbXX1cclxuICovXG5cblxuZnVuY3Rpb24gdG9Db2RlUG9pbnRzKGlucHV0KSB7XG4gIHZhciBjb2RlcG9pbnRzID0gW107XG4gIHZhciBzaXplID0gaW5wdXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSAxKSB7XG4gICAgdmFyIGJlZm9yZSA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoYmVmb3JlID49IDB4ZDgwMCAmJiBiZWZvcmUgPD0gMHhkYmZmICYmIHNpemUgPiBpICsgMSkge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgaWYgKG5leHQgPj0gMHhkYzAwICYmIG5leHQgPD0gMHhkZmZmKSB7XG4gICAgICAgIGNvZGVwb2ludHMucHVzaCgoYmVmb3JlIC0gMHhkODAwKSAqIDB4NDAwICsgbmV4dCAtIDB4ZGMwMCArIDB4MTAwMDApO1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvZGVwb2ludHMucHVzaChiZWZvcmUpO1xuICB9XG5cbiAgcmV0dXJuIGNvZGVwb2ludHM7XG59XG4vKipcclxuICogU0FTTHByZXAuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMuYWxsb3dVbmFzc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhc2xwcmVwKGlucHV0KSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHN0cmluZy4nKTtcbiAgfVxuXG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gMS4gTWFwXG5cblxuICB2YXIgbWFwcGVkX2lucHV0ID0gdG9Db2RlUG9pbnRzKGlucHV0KSAvLyAxLjEgbWFwcGluZyB0byBzcGFjZVxuICAubWFwKGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gbWFwcGluZzJzcGFjZShjaGFyYWN0ZXIpID8gMHgyMCA6IGNoYXJhY3RlcjtcbiAgfSkgLy8gMS4yIG1hcHBpbmcgdG8gbm90aGluZ1xuICAuZmlsdGVyKGZ1bmN0aW9uIChjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gIW1hcHBpbmcybm90aGluZyhjaGFyYWN0ZXIpO1xuICB9KTsgLy8gMi4gTm9ybWFsaXplXG5cbiAgdmFyIG5vcm1hbGl6ZWRfaW5wdXQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCBtYXBwZWRfaW5wdXQpLm5vcm1hbGl6ZSgnTkZLQycpO1xuICB2YXIgbm9ybWFsaXplZF9tYXAgPSB0b0NvZGVQb2ludHMobm9ybWFsaXplZF9pbnB1dCk7IC8vIDMuIFByb2hpYml0XG5cbiAgdmFyIGhhc1Byb2hpYml0ZWQgPSBub3JtYWxpemVkX21hcC5zb21lKGlzUHJvaGliaXRlZENoYXJhY3Rlcik7XG5cbiAgaWYgKGhhc1Byb2hpYml0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2hpYml0ZWQgY2hhcmFjdGVyLCBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQwMTMjc2VjdGlvbi0yLjMnKTtcbiAgfSAvLyBVbmFzc2lnbmVkIENvZGUgUG9pbnRzXG5cblxuICBpZiAob3B0cy5hbGxvd1VuYXNzaWduZWQgIT09IHRydWUpIHtcbiAgICB2YXIgaGFzVW5hc3NpZ25lZCA9IG5vcm1hbGl6ZWRfbWFwLnNvbWUoaXNVbmFzc2lnbmVkQ29kZVBvaW50KTtcblxuICAgIGlmIChoYXNVbmFzc2lnbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYXNzaWduZWQgY29kZSBwb2ludCwgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MDEzI3NlY3Rpb24tMi41Jyk7XG4gICAgfVxuICB9IC8vIDQuIGNoZWNrIGJpZGlcblxuXG4gIHZhciBoYXNCaWRpUkFMID0gbm9ybWFsaXplZF9tYXAuc29tZShpc0JpZGlyZWN0aW9uYWxSQUwpO1xuICB2YXIgaGFzQmlkaUwgPSBub3JtYWxpemVkX21hcC5zb21lKGlzQmlkaXJlY3Rpb25hbEwpOyAvLyA0LjEgSWYgYSBzdHJpbmcgY29udGFpbnMgYW55IFJhbmRBTENhdCBjaGFyYWN0ZXIsIHRoZSBzdHJpbmcgTVVTVCBOT1RcbiAgLy8gY29udGFpbiBhbnkgTENhdCBjaGFyYWN0ZXIuXG5cbiAgaWYgKGhhc0JpZGlSQUwgJiYgaGFzQmlkaUwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmluZyBtdXN0IG5vdCBjb250YWluIFJhbmRBTENhdCBhbmQgTENhdCBhdCB0aGUgc2FtZSB0aW1lLCcgKyAnIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNzZWN0aW9uLTYnKTtcbiAgfVxuICAvKipcclxuICAgKiA0LjIgSWYgYSBzdHJpbmcgY29udGFpbnMgYW55IFJhbmRBTENhdCBjaGFyYWN0ZXIsIGEgUmFuZEFMQ2F0XHJcbiAgICogY2hhcmFjdGVyIE1VU1QgYmUgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc3RyaW5nLCBhbmQgYVxyXG4gICAqIFJhbmRBTENhdCBjaGFyYWN0ZXIgTVVTVCBiZSB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIHN0cmluZy5cclxuICAgKi9cblxuXG4gIHZhciBpc0ZpcnN0QmlkaVJBTCA9IGlzQmlkaXJlY3Rpb25hbFJBTChnZXRDb2RlUG9pbnQoZmlyc3Qobm9ybWFsaXplZF9pbnB1dCkpKTtcbiAgdmFyIGlzTGFzdEJpZGlSQUwgPSBpc0JpZGlyZWN0aW9uYWxSQUwoZ2V0Q29kZVBvaW50KGxhc3Qobm9ybWFsaXplZF9pbnB1dCkpKTtcblxuICBpZiAoaGFzQmlkaVJBTCAmJiAhKGlzRmlyc3RCaWRpUkFMICYmIGlzTGFzdEJpZGlSQUwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCaWRpcmVjdGlvbmFsIFJhbmRBTENhdCBjaGFyYWN0ZXIgbXVzdCBiZSB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0JyArICcgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcsIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ1NCNzZWN0aW9uLTYnKTtcbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkX2lucHV0O1xufVxuXG52YXIgUERGU2VjdXJpdHkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoUERGU2VjdXJpdHksIG51bGwsIFt7XG4gICAga2V5OiBcImdlbmVyYXRlRmlsZUlEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlRmlsZUlEKCkge1xuICAgICAgdmFyIGluZm8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIGluZm9TdHIgPSBcIlwiLmNvbmNhdChpbmZvLkNyZWF0aW9uRGF0ZS5nZXRUaW1lKCksIFwiXFxuXCIpO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gaW5mbykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIGlmICghaW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvU3RyICs9IFwiXCIuY29uY2F0KGtleSwgXCI6IFwiKS5jb25jYXQoaW5mb1trZXldLnZhbHVlT2YoKSwgXCJcXG5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3b3JkQXJyYXlUb0J1ZmZlcihDcnlwdG9KUy5NRDUoaW5mb1N0cikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheShieXRlcykge1xuICAgICAgcmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKGJ5dGVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShkb2N1bWVudCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICBpZiAoIW9wdGlvbnMub3duZXJQYXNzd29yZCAmJiAhb3B0aW9ucy51c2VyUGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUERGU2VjdXJpdHkoZG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFBERlNlY3VyaXR5KGRvY3VtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERlNlY3VyaXR5KTtcblxuICAgIGlmICghb3B0aW9ucy5vd25lclBhc3N3b3JkICYmICFvcHRpb25zLnVzZXJQYXNzd29yZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIG93bmVyIHBhc3N3b3JkIGFuZCB1c2VyIHBhc3N3b3JkIGlzIGRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgdGhpcy5fc2V0dXBFbmNyeXB0aW9uKG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERlNlY3VyaXR5LCBbe1xuICAgIGtleTogXCJfc2V0dXBFbmNyeXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEVuY3J5cHRpb24ob3B0aW9ucykge1xuICAgICAgc3dpdGNoIChvcHRpb25zLnBkZlZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAnMS40JzpcbiAgICAgICAgY2FzZSAnMS41JzpcbiAgICAgICAgICB0aGlzLnZlcnNpb24gPSAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzEuNic6XG4gICAgICAgIGNhc2UgJzEuNyc6XG4gICAgICAgICAgdGhpcy52ZXJzaW9uID0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcxLjdleHQzJzpcbiAgICAgICAgICB0aGlzLnZlcnNpb24gPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy52ZXJzaW9uID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGVuY0RpY3QgPSB7XG4gICAgICAgIEZpbHRlcjogJ1N0YW5kYXJkJ1xuICAgICAgfTtcblxuICAgICAgc3dpdGNoICh0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0aGlzLl9zZXR1cEVuY3J5cHRpb25WMVYyVjQodGhpcy52ZXJzaW9uLCBlbmNEaWN0LCBvcHRpb25zKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB0aGlzLl9zZXR1cEVuY3J5cHRpb25WNShlbmNEaWN0LCBvcHRpb25zKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZihlbmNEaWN0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwRW5jcnlwdGlvblYxVjJWNFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBFbmNyeXB0aW9uVjFWMlY0KHYsIGVuY0RpY3QsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByLCBwZXJtaXNzaW9ucztcblxuICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByID0gMjtcbiAgICAgICAgICB0aGlzLmtleUJpdHMgPSA0MDtcbiAgICAgICAgICBwZXJtaXNzaW9ucyA9IGdldFBlcm1pc3Npb25zUjIob3B0aW9ucy5wZXJtaXNzaW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHIgPSAzO1xuICAgICAgICAgIHRoaXMua2V5Qml0cyA9IDEyODtcbiAgICAgICAgICBwZXJtaXNzaW9ucyA9IGdldFBlcm1pc3Npb25zUjMob3B0aW9ucy5wZXJtaXNzaW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSA0O1xuICAgICAgICAgIHRoaXMua2V5Qml0cyA9IDEyODtcbiAgICAgICAgICBwZXJtaXNzaW9ucyA9IGdldFBlcm1pc3Npb25zUjMob3B0aW9ucy5wZXJtaXNzaW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWRkZWRVc2VyUGFzc3dvcmQgPSBwcm9jZXNzUGFzc3dvcmRSMlIzUjQob3B0aW9ucy51c2VyUGFzc3dvcmQpO1xuICAgICAgdmFyIHBhZGRlZE93bmVyUGFzc3dvcmQgPSBvcHRpb25zLm93bmVyUGFzc3dvcmQgPyBwcm9jZXNzUGFzc3dvcmRSMlIzUjQob3B0aW9ucy5vd25lclBhc3N3b3JkKSA6IHBhZGRlZFVzZXJQYXNzd29yZDtcbiAgICAgIHZhciBvd25lclBhc3N3b3JkRW50cnkgPSBnZXRPd25lclBhc3N3b3JkUjJSM1I0KHIsIHRoaXMua2V5Qml0cywgcGFkZGVkVXNlclBhc3N3b3JkLCBwYWRkZWRPd25lclBhc3N3b3JkKTtcbiAgICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGdldEVuY3J5cHRpb25LZXlSMlIzUjQociwgdGhpcy5rZXlCaXRzLCB0aGlzLmRvY3VtZW50Ll9pZCwgcGFkZGVkVXNlclBhc3N3b3JkLCBvd25lclBhc3N3b3JkRW50cnksIHBlcm1pc3Npb25zKTtcbiAgICAgIHZhciB1c2VyUGFzc3dvcmRFbnRyeTtcblxuICAgICAgaWYgKHIgPT09IDIpIHtcbiAgICAgICAgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSMih0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSM1I0KHRoaXMuZG9jdW1lbnQuX2lkLCB0aGlzLmVuY3J5cHRpb25LZXkpO1xuICAgICAgfVxuXG4gICAgICBlbmNEaWN0LlYgPSB2O1xuXG4gICAgICBpZiAodiA+PSAyKSB7XG4gICAgICAgIGVuY0RpY3QuTGVuZ3RoID0gdGhpcy5rZXlCaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiAodiA9PT0gNCkge1xuICAgICAgICBlbmNEaWN0LkNGID0ge1xuICAgICAgICAgIFN0ZENGOiB7XG4gICAgICAgICAgICBBdXRoRXZlbnQ6ICdEb2NPcGVuJyxcbiAgICAgICAgICAgIENGTTogJ0FFU1YyJyxcbiAgICAgICAgICAgIExlbmd0aDogdGhpcy5rZXlCaXRzIC8gOFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZW5jRGljdC5TdG1GID0gJ1N0ZENGJztcbiAgICAgICAgZW5jRGljdC5TdHJGID0gJ1N0ZENGJztcbiAgICAgIH1cblxuICAgICAgZW5jRGljdC5SID0gcjtcbiAgICAgIGVuY0RpY3QuTyA9IHdvcmRBcnJheVRvQnVmZmVyKG93bmVyUGFzc3dvcmRFbnRyeSk7XG4gICAgICBlbmNEaWN0LlUgPSB3b3JkQXJyYXlUb0J1ZmZlcih1c2VyUGFzc3dvcmRFbnRyeSk7XG4gICAgICBlbmNEaWN0LlAgPSBwZXJtaXNzaW9ucztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwRW5jcnlwdGlvblY1XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cEVuY3J5cHRpb25WNShlbmNEaWN0LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLmtleUJpdHMgPSAyNTY7XG4gICAgICB2YXIgcGVybWlzc2lvbnMgPSBnZXRQZXJtaXNzaW9uc1IzKG9wdGlvbnMucGVybWlzc2lvbnMpO1xuICAgICAgdmFyIHByb2Nlc3NlZFVzZXJQYXNzd29yZCA9IHByb2Nlc3NQYXNzd29yZFI1KG9wdGlvbnMudXNlclBhc3N3b3JkKTtcbiAgICAgIHZhciBwcm9jZXNzZWRPd25lclBhc3N3b3JkID0gb3B0aW9ucy5vd25lclBhc3N3b3JkID8gcHJvY2Vzc1Bhc3N3b3JkUjUob3B0aW9ucy5vd25lclBhc3N3b3JkKSA6IHByb2Nlc3NlZFVzZXJQYXNzd29yZDtcbiAgICAgIHRoaXMuZW5jcnlwdGlvbktleSA9IGdldEVuY3J5cHRpb25LZXlSNShQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgICB2YXIgdXNlclBhc3N3b3JkRW50cnkgPSBnZXRVc2VyUGFzc3dvcmRSNShwcm9jZXNzZWRVc2VyUGFzc3dvcmQsIFBERlNlY3VyaXR5LmdlbmVyYXRlUmFuZG9tV29yZEFycmF5KTtcbiAgICAgIHZhciB1c2VyS2V5U2FsdCA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKHVzZXJQYXNzd29yZEVudHJ5LndvcmRzLnNsaWNlKDEwLCAxMiksIDgpO1xuICAgICAgdmFyIHVzZXJFbmNyeXB0aW9uS2V5RW50cnkgPSBnZXRVc2VyRW5jcnlwdGlvbktleVI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgdXNlcktleVNhbHQsIHRoaXMuZW5jcnlwdGlvbktleSk7XG4gICAgICB2YXIgb3duZXJQYXNzd29yZEVudHJ5ID0gZ2V0T3duZXJQYXNzd29yZFI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIHVzZXJQYXNzd29yZEVudHJ5LCBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgICB2YXIgb3duZXJLZXlTYWx0ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3duZXJQYXNzd29yZEVudHJ5LndvcmRzLnNsaWNlKDEwLCAxMiksIDgpO1xuICAgICAgdmFyIG93bmVyRW5jcnlwdGlvbktleUVudHJ5ID0gZ2V0T3duZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkT3duZXJQYXNzd29yZCwgb3duZXJLZXlTYWx0LCB1c2VyUGFzc3dvcmRFbnRyeSwgdGhpcy5lbmNyeXB0aW9uS2V5KTtcbiAgICAgIHZhciBwZXJtc0VudHJ5ID0gZ2V0RW5jcnlwdGVkUGVybWlzc2lvbnNSNShwZXJtaXNzaW9ucywgdGhpcy5lbmNyeXB0aW9uS2V5LCBQREZTZWN1cml0eS5nZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSk7XG4gICAgICBlbmNEaWN0LlYgPSA1O1xuICAgICAgZW5jRGljdC5MZW5ndGggPSB0aGlzLmtleUJpdHM7XG4gICAgICBlbmNEaWN0LkNGID0ge1xuICAgICAgICBTdGRDRjoge1xuICAgICAgICAgIEF1dGhFdmVudDogJ0RvY09wZW4nLFxuICAgICAgICAgIENGTTogJ0FFU1YzJyxcbiAgICAgICAgICBMZW5ndGg6IHRoaXMua2V5Qml0cyAvIDhcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGVuY0RpY3QuU3RtRiA9ICdTdGRDRic7XG4gICAgICBlbmNEaWN0LlN0ckYgPSAnU3RkQ0YnO1xuICAgICAgZW5jRGljdC5SID0gNTtcbiAgICAgIGVuY0RpY3QuTyA9IHdvcmRBcnJheVRvQnVmZmVyKG93bmVyUGFzc3dvcmRFbnRyeSk7XG4gICAgICBlbmNEaWN0Lk9FID0gd29yZEFycmF5VG9CdWZmZXIob3duZXJFbmNyeXB0aW9uS2V5RW50cnkpO1xuICAgICAgZW5jRGljdC5VID0gd29yZEFycmF5VG9CdWZmZXIodXNlclBhc3N3b3JkRW50cnkpO1xuICAgICAgZW5jRGljdC5VRSA9IHdvcmRBcnJheVRvQnVmZmVyKHVzZXJFbmNyeXB0aW9uS2V5RW50cnkpO1xuICAgICAgZW5jRGljdC5QID0gcGVybWlzc2lvbnM7XG4gICAgICBlbmNEaWN0LlBlcm1zID0gd29yZEFycmF5VG9CdWZmZXIocGVybXNFbnRyeSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVuY3J5cHRGblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbmNyeXB0Rm4ob2JqLCBnZW4pIHtcbiAgICAgIHZhciBkaWdlc3Q7XG5cbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPCA1KSB7XG4gICAgICAgIGRpZ2VzdCA9IHRoaXMuZW5jcnlwdGlvbktleS5jbG9uZSgpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbKG9iaiAmIDB4ZmYpIDw8IDI0IHwgKG9iaiAmIDB4ZmYwMCkgPDwgOCB8IG9iaiA+PiA4ICYgMHhmZjAwIHwgZ2VuICYgMHhmZiwgKGdlbiAmIDB4ZmYwMCkgPDwgMTZdLCA1KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT09IDEgfHwgdGhpcy52ZXJzaW9uID09PSAyKSB7XG4gICAgICAgIHZhciBfa2V5ID0gQ3J5cHRvSlMuTUQ1KGRpZ2VzdCk7XG5cbiAgICAgICAgX2tleS5zaWdCeXRlcyA9IE1hdGgubWluKDE2LCB0aGlzLmtleUJpdHMgLyA4ICsgNSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHdvcmRBcnJheVRvQnVmZmVyKENyeXB0b0pTLlJDNC5lbmNyeXB0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGJ1ZmZlciksIF9rZXkpLmNpcGhlcnRleHQpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5O1xuXG4gICAgICBpZiAodGhpcy52ZXJzaW9uID09PSA0KSB7XG4gICAgICAgIGtleSA9IENyeXB0b0pTLk1ENShkaWdlc3QuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDczNDE2YzU0XSwgNCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9IHRoaXMuZW5jcnlwdGlvbktleTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl2ID0gUERGU2VjdXJpdHkuZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoMTYpO1xuICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUGtjczcsXG4gICAgICAgIGl2OiBpdlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB3b3JkQXJyYXlUb0J1ZmZlcihpdi5jbG9uZSgpLmNvbmNhdChDcnlwdG9KUy5BRVMuZW5jcnlwdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShidWZmZXIpLCBrZXksIG9wdGlvbnMpLmNpcGhlcnRleHQpKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERlNlY3VyaXR5O1xufSgpO1xuXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uc1IyKCkge1xuICB2YXIgcGVybWlzc2lvbk9iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBwZXJtaXNzaW9ucyA9IDB4ZmZmZmZmYzAgPj4gMDtcblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5wcmludGluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDQ7XG4gIH1cblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5tb2RpZnlpbmcpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSA4O1xuICB9XG5cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuY29weWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDE2O1xuICB9XG5cbiAgaWYgKHBlcm1pc3Npb25PYmplY3QuYW5ub3RhdGluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDMyO1xuICB9XG5cbiAgcmV0dXJuIHBlcm1pc3Npb25zO1xufVxuXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uc1IzKCkge1xuICB2YXIgcGVybWlzc2lvbk9iamVjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBwZXJtaXNzaW9ucyA9IDB4ZmZmZmYwYzAgPj4gMDtcblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5wcmludGluZyA9PT0gJ2xvd1Jlc29sdXRpb24nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gNDtcbiAgfVxuXG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LnByaW50aW5nID09PSAnaGlnaFJlc29sdXRpb24nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMjA1MjtcbiAgfVxuXG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0Lm1vZGlmeWluZykge1xuICAgIHBlcm1pc3Npb25zIHw9IDg7XG4gIH1cblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5jb3B5aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMTY7XG4gIH1cblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5hbm5vdGF0aW5nKSB7XG4gICAgcGVybWlzc2lvbnMgfD0gMzI7XG4gIH1cblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5maWxsaW5nRm9ybXMpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAyNTY7XG4gIH1cblxuICBpZiAocGVybWlzc2lvbk9iamVjdC5jb250ZW50QWNjZXNzaWJpbGl0eSkge1xuICAgIHBlcm1pc3Npb25zIHw9IDUxMjtcbiAgfVxuXG4gIGlmIChwZXJtaXNzaW9uT2JqZWN0LmRvY3VtZW50QXNzZW1ibHkpIHtcbiAgICBwZXJtaXNzaW9ucyB8PSAxMDI0O1xuICB9XG5cbiAgcmV0dXJuIHBlcm1pc3Npb25zO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyUGFzc3dvcmRSMihlbmNyeXB0aW9uS2V5KSB7XG4gIHJldHVybiBDcnlwdG9KUy5SQzQuZW5jcnlwdChwcm9jZXNzUGFzc3dvcmRSMlIzUjQoKSwgZW5jcnlwdGlvbktleSkuY2lwaGVydGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlclBhc3N3b3JkUjNSNChkb2N1bWVudElkLCBlbmNyeXB0aW9uS2V5KSB7XG4gIHZhciBrZXkgPSBlbmNyeXB0aW9uS2V5LmNsb25lKCk7XG4gIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5NRDUocHJvY2Vzc1Bhc3N3b3JkUjJSM1I0KCkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKGRvY3VtZW50SWQpKSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgdmFyIHhvclJvdW5kID0gTWF0aC5jZWlsKGtleS5zaWdCeXRlcyAvIDQpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4b3JSb3VuZDsgaisrKSB7XG4gICAgICBrZXkud29yZHNbal0gPSBlbmNyeXB0aW9uS2V5LndvcmRzW2pdIF4gKGkgfCBpIDw8IDggfCBpIDw8IDE2IHwgaSA8PCAyNCk7XG4gICAgfVxuXG4gICAgY2lwaGVyID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQoY2lwaGVyLCBrZXkpLmNpcGhlcnRleHQ7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShudWxsLCAxNikpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25lclBhc3N3b3JkUjJSM1I0KHIsIGtleUJpdHMsIHBhZGRlZFVzZXJQYXNzd29yZCwgcGFkZGVkT3duZXJQYXNzd29yZCkge1xuICB2YXIgZGlnZXN0ID0gcGFkZGVkT3duZXJQYXNzd29yZDtcbiAgdmFyIHJvdW5kID0gciA+PSAzID8gNTEgOiAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcm91bmQ7IGkrKykge1xuICAgIGRpZ2VzdCA9IENyeXB0b0pTLk1ENShkaWdlc3QpO1xuICB9XG5cbiAgdmFyIGtleSA9IGRpZ2VzdC5jbG9uZSgpO1xuICBrZXkuc2lnQnl0ZXMgPSBrZXlCaXRzIC8gODtcbiAgdmFyIGNpcGhlciA9IHBhZGRlZFVzZXJQYXNzd29yZDtcbiAgcm91bmQgPSByID49IDMgPyAyMCA6IDE7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHJvdW5kOyBfaSsrKSB7XG4gICAgdmFyIHhvclJvdW5kID0gTWF0aC5jZWlsKGtleS5zaWdCeXRlcyAvIDQpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4b3JSb3VuZDsgaisrKSB7XG4gICAgICBrZXkud29yZHNbal0gPSBkaWdlc3Qud29yZHNbal0gXiAoX2kgfCBfaSA8PCA4IHwgX2kgPDwgMTYgfCBfaSA8PCAyNCk7XG4gICAgfVxuXG4gICAgY2lwaGVyID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQoY2lwaGVyLCBrZXkpLmNpcGhlcnRleHQ7XG4gIH1cblxuICByZXR1cm4gY2lwaGVyO1xufVxuXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uS2V5UjJSM1I0KHIsIGtleUJpdHMsIGRvY3VtZW50SWQsIHBhZGRlZFVzZXJQYXNzd29yZCwgb3duZXJQYXNzd29yZEVudHJ5LCBwZXJtaXNzaW9ucykge1xuICB2YXIga2V5ID0gcGFkZGVkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KG93bmVyUGFzc3dvcmRFbnRyeSkuY29uY2F0KENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFtsc2JGaXJzdFdvcmQocGVybWlzc2lvbnMpXSwgNCkpLmNvbmNhdChDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShkb2N1bWVudElkKSk7XG4gIHZhciByb3VuZCA9IHIgPj0gMyA/IDUxIDogMTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdW5kOyBpKyspIHtcbiAgICBrZXkgPSBDcnlwdG9KUy5NRDUoa2V5KTtcbiAgICBrZXkuc2lnQnl0ZXMgPSBrZXlCaXRzIC8gODtcbiAgfVxuXG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJQYXNzd29yZFI1KHByb2Nlc3NlZFVzZXJQYXNzd29yZCwgZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkpIHtcbiAgdmFyIHZhbGlkYXRpb25TYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIHZhciBrZXlTYWx0ID0gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoOCk7XG4gIHJldHVybiBDcnlwdG9KUy5TSEEyNTYocHJvY2Vzc2VkVXNlclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KHZhbGlkYXRpb25TYWx0KSkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQoa2V5U2FsdCk7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkVXNlclBhc3N3b3JkLCB1c2VyS2V5U2FsdCwgZW5jcnlwdGlvbktleSkge1xuICB2YXIga2V5ID0gQ3J5cHRvSlMuU0hBMjU2KHByb2Nlc3NlZFVzZXJQYXNzd29yZC5jbG9uZSgpLmNvbmNhdCh1c2VyS2V5U2FsdCkpO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcbiAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuTm9QYWRkaW5nLFxuICAgIGl2OiBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShudWxsLCAxNilcbiAgfTtcbiAgcmV0dXJuIENyeXB0b0pTLkFFUy5lbmNyeXB0KGVuY3J5cHRpb25LZXksIGtleSwgb3B0aW9ucykuY2lwaGVydGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJQYXNzd29yZFI1KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQsIHVzZXJQYXNzd29yZEVudHJ5LCBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICB2YXIgdmFsaWRhdGlvblNhbHQgPSBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSg4KTtcbiAgdmFyIGtleVNhbHQgPSBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSg4KTtcbiAgcmV0dXJuIENyeXB0b0pTLlNIQTI1Nihwcm9jZXNzZWRPd25lclBhc3N3b3JkLmNsb25lKCkuY29uY2F0KHZhbGlkYXRpb25TYWx0KS5jb25jYXQodXNlclBhc3N3b3JkRW50cnkpKS5jb25jYXQodmFsaWRhdGlvblNhbHQpLmNvbmNhdChrZXlTYWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJFbmNyeXB0aW9uS2V5UjUocHJvY2Vzc2VkT3duZXJQYXNzd29yZCwgb3duZXJLZXlTYWx0LCB1c2VyUGFzc3dvcmRFbnRyeSwgZW5jcnlwdGlvbktleSkge1xuICB2YXIga2V5ID0gQ3J5cHRvSlMuU0hBMjU2KHByb2Nlc3NlZE93bmVyUGFzc3dvcmQuY2xvbmUoKS5jb25jYXQob3duZXJLZXlTYWx0KS5jb25jYXQodXNlclBhc3N3b3JkRW50cnkpKTtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZyxcbiAgICBpdjogQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUobnVsbCwgMTYpXG4gIH07XG4gIHJldHVybiBDcnlwdG9KUy5BRVMuZW5jcnlwdChlbmNyeXB0aW9uS2V5LCBrZXksIG9wdGlvbnMpLmNpcGhlcnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25LZXlSNShnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICByZXR1cm4gZ2VuZXJhdGVSYW5kb21Xb3JkQXJyYXkoMzIpO1xufVxuXG5mdW5jdGlvbiBnZXRFbmNyeXB0ZWRQZXJtaXNzaW9uc1I1KHBlcm1pc3Npb25zLCBlbmNyeXB0aW9uS2V5LCBnZW5lcmF0ZVJhbmRvbVdvcmRBcnJheSkge1xuICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoW2xzYkZpcnN0V29yZChwZXJtaXNzaW9ucyksIDB4ZmZmZmZmZmYsIDB4NTQ2MTY0NjJdLCAxMikuY29uY2F0KGdlbmVyYXRlUmFuZG9tV29yZEFycmF5KDQpKTtcbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgbW9kZTogQ3J5cHRvSlMubW9kZS5FQ0IsXG4gICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLk5vUGFkZGluZ1xuICB9O1xuICByZXR1cm4gQ3J5cHRvSlMuQUVTLmVuY3J5cHQoY2lwaGVyLCBlbmNyeXB0aW9uS2V5LCBvcHRpb25zKS5jaXBoZXJ0ZXh0O1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUGFzc3dvcmRSMlIzUjQoKSB7XG4gIHZhciBwYXNzd29yZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIHZhciBvdXQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICB2YXIgbGVuZ3RoID0gcGFzc3dvcmQubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCAmJiBpbmRleCA8IDMyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXNzd29yZC5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgIGlmIChjb2RlID4gMHhmZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzd29yZCBjb250YWlucyBvbmUgb3IgbW9yZSBpbnZhbGlkIGNoYXJhY3RlcnMuJyk7XG4gICAgfVxuXG4gICAgb3V0W2luZGV4XSA9IGNvZGU7XG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIHdoaWxlIChpbmRleCA8IDMyKSB7XG4gICAgb3V0W2luZGV4XSA9IFBBU1NXT1JEX1BBRERJTkdbaW5kZXggLSBsZW5ndGhdO1xuICAgIGluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3V0KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Bhc3N3b3JkUjUoKSB7XG4gIHZhciBwYXNzd29yZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIHBhc3N3b3JkID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHNhc2xwcmVwKHBhc3N3b3JkKSkpO1xuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oMTI3LCBwYXNzd29yZC5sZW5ndGgpO1xuICB2YXIgb3V0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dFtpXSA9IHBhc3N3b3JkLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUob3V0KTtcbn1cblxuZnVuY3Rpb24gbHNiRmlyc3RXb3JkKGRhdGEpIHtcbiAgcmV0dXJuIChkYXRhICYgMHhmZikgPDwgMjQgfCAoZGF0YSAmIDB4ZmYwMCkgPDwgOCB8IGRhdGEgPj4gOCAmIDB4ZmYwMCB8IGRhdGEgPj4gMjQgJiAweGZmO1xufVxuXG5mdW5jdGlvbiB3b3JkQXJyYXlUb0J1ZmZlcih3b3JkQXJyYXkpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZEFycmF5LnNpZ0J5dGVzOyBpKyspIHtcbiAgICBieXRlQXJyYXkucHVzaCh3b3JkQXJyYXkud29yZHNbTWF0aC5mbG9vcihpIC8gNCldID4+IDggKiAoMyAtIGkgJSA0KSAmIDB4ZmYpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVBcnJheSk7XG59XG5cbnZhciBQQVNTV09SRF9QQURESU5HID0gWzB4MjgsIDB4YmYsIDB4NGUsIDB4NWUsIDB4NGUsIDB4NzUsIDB4OGEsIDB4NDEsIDB4NjQsIDB4MDAsIDB4NGUsIDB4NTYsIDB4ZmYsIDB4ZmEsIDB4MDEsIDB4MDgsIDB4MmUsIDB4MmUsIDB4MDAsIDB4YjYsIDB4ZDAsIDB4NjgsIDB4M2UsIDB4ODAsIDB4MmYsIDB4MGMsIDB4YTksIDB4ZmUsIDB4NjQsIDB4NTMsIDB4NjksIDB4N2FdO1xuXG52YXIgbnVtYmVyID0gUERGT2JqZWN0Lm51bWJlcjtcblxudmFyIFBERkdyYWRpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGR3JhZGllbnQoZG9jKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkdyYWRpZW50KTtcblxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB0aGlzLmVtYmVkZGVkID0gZmFsc2U7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGR3JhZGllbnQsIFt7XG4gICAga2V5OiBcInN0b3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcChwb3MsIGNvbG9yLCBvcGFjaXR5KSB7XG4gICAgICBpZiAob3BhY2l0eSA9PSBudWxsKSB7XG4gICAgICAgIG9wYWNpdHkgPSAxO1xuICAgICAgfVxuXG4gICAgICBjb2xvciA9IHRoaXMuZG9jLl9ub3JtYWxpemVDb2xvcihjb2xvcik7XG5cbiAgICAgIGlmICh0aGlzLnN0b3BzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VSR0InO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIHRoaXMuX2NvbG9yU3BhY2UgPSAnRGV2aWNlQ01ZSyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29sb3IubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9ICdEZXZpY2VHcmF5JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY29sb3Igc3BhY2UnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb2xvclNwYWNlID09PSAnRGV2aWNlUkdCJyAmJiBjb2xvci5sZW5ndGggIT09IDMgfHwgdGhpcy5fY29sb3JTcGFjZSA9PT0gJ0RldmljZUNNWUsnICYmIGNvbG9yLmxlbmd0aCAhPT0gNCB8fCB0aGlzLl9jb2xvclNwYWNlID09PSAnRGV2aWNlR3JheScgJiYgY29sb3IubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGdyYWRpZW50IHN0b3BzIG11c3QgdXNlIHRoZSBzYW1lIGNvbG9yIHNwYWNlJyk7XG4gICAgICB9XG5cbiAgICAgIG9wYWNpdHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBvcGFjaXR5KSk7XG4gICAgICB0aGlzLnN0b3BzLnB1c2goW3BvcywgY29sb3IsIG9wYWNpdHldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNmb3JtKG0xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IFttMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeV07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1iZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1iZWQobSkge1xuICAgICAgdmFyIGZuO1xuICAgICAgdmFyIHN0b3BzTGVuZ3RoID0gdGhpcy5zdG9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChzdG9wc0xlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1iZWRkZWQgPSB0cnVlO1xuICAgICAgdGhpcy5tYXRyaXggPSBtOyAvLyBpZiB0aGUgbGFzdCBzdG9wIGNvbWVzIGJlZm9yZSAxMDAlLCBhZGQgYSBjb3B5IGF0IDEwMCVcblxuICAgICAgdmFyIGxhc3QgPSB0aGlzLnN0b3BzW3N0b3BzTGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0WzBdIDwgMSkge1xuICAgICAgICB0aGlzLnN0b3BzLnB1c2goWzEsIGxhc3RbMV0sIGxhc3RbMl1dKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJvdW5kcyA9IFtdO1xuICAgICAgdmFyIGVuY29kZSA9IFtdO1xuICAgICAgdmFyIHN0b3BzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHNMZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgZW5jb2RlLnB1c2goMCwgMSk7XG5cbiAgICAgICAgaWYgKGkgKyAyICE9PSBzdG9wc0xlbmd0aCkge1xuICAgICAgICAgIGJvdW5kcy5wdXNoKHRoaXMuc3RvcHNbaSArIDFdWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZuID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgICBGdW5jdGlvblR5cGU6IDIsXG4gICAgICAgICAgRG9tYWluOiBbMCwgMV0sXG4gICAgICAgICAgQzA6IHRoaXMuc3RvcHNbaSArIDBdWzFdLFxuICAgICAgICAgIEMxOiB0aGlzLnN0b3BzW2kgKyAxXVsxXSxcbiAgICAgICAgICBOOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcy5wdXNoKGZuKTtcbiAgICAgICAgZm4uZW5kKCk7XG4gICAgICB9IC8vIGlmIHRoZXJlIGFyZSBvbmx5IHR3byBzdG9wcywgd2UgZG9uJ3QgbmVlZCBhIHN0aXRjaGluZyBmdW5jdGlvblxuXG5cbiAgICAgIGlmIChzdG9wc0xlbmd0aCA9PT0gMSkge1xuICAgICAgICBmbiA9IHN0b3BzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4gPSB0aGlzLmRvYy5yZWYoe1xuICAgICAgICAgIEZ1bmN0aW9uVHlwZTogMyxcbiAgICAgICAgICAvLyBzdGl0Y2hpbmcgZnVuY3Rpb25cbiAgICAgICAgICBEb21haW46IFswLCAxXSxcbiAgICAgICAgICBGdW5jdGlvbnM6IHN0b3BzLFxuICAgICAgICAgIEJvdW5kczogYm91bmRzLFxuICAgICAgICAgIEVuY29kZTogZW5jb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBmbi5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pZCA9IFwiU2hcIi5jb25jYXQoKyt0aGlzLmRvYy5fZ3JhZENvdW50KTtcbiAgICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlcihmbik7XG4gICAgICBzaGFkZXIuZW5kKCk7XG4gICAgICB2YXIgcGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgIFR5cGU6ICdQYXR0ZXJuJyxcbiAgICAgICAgUGF0dGVyblR5cGU6IDIsXG4gICAgICAgIFNoYWRpbmc6IHNoYWRlcixcbiAgICAgICAgTWF0cml4OiB0aGlzLm1hdHJpeC5tYXAobnVtYmVyKVxuICAgICAgfSk7XG4gICAgICBwYXR0ZXJuLmVuZCgpO1xuXG4gICAgICBpZiAodGhpcy5zdG9wcy5zb21lKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHJldHVybiBzdG9wWzJdIDwgMTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBncmFkID0gdGhpcy5vcGFjaXR5R3JhZGllbnQoKTtcbiAgICAgICAgZ3JhZC5fY29sb3JTcGFjZSA9ICdEZXZpY2VHcmF5JztcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5zdG9wcyksXG4gICAgICAgICAgICBfc3RlcDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgZ3JhZC5zdG9wKHN0b3BbMF0sIFtzdG9wWzJdXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmFkID0gZ3JhZC5lbWJlZCh0aGlzLm1hdHJpeCk7XG4gICAgICAgIHZhciBwYWdlQkJveCA9IFswLCAwLCB0aGlzLmRvYy5wYWdlLndpZHRoLCB0aGlzLmRvYy5wYWdlLmhlaWdodF07XG4gICAgICAgIHZhciBmb3JtID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgICBUeXBlOiAnWE9iamVjdCcsXG4gICAgICAgICAgU3VidHlwZTogJ0Zvcm0nLFxuICAgICAgICAgIEZvcm1UeXBlOiAxLFxuICAgICAgICAgIEJCb3g6IHBhZ2VCQm94LFxuICAgICAgICAgIEdyb3VwOiB7XG4gICAgICAgICAgICBUeXBlOiAnR3JvdXAnLFxuICAgICAgICAgICAgUzogJ1RyYW5zcGFyZW5jeScsXG4gICAgICAgICAgICBDUzogJ0RldmljZUdyYXknXG4gICAgICAgICAgfSxcbiAgICAgICAgICBSZXNvdXJjZXM6IHtcbiAgICAgICAgICAgIFByb2NTZXQ6IFsnUERGJywgJ1RleHQnLCAnSW1hZ2VCJywgJ0ltYWdlQycsICdJbWFnZUknXSxcbiAgICAgICAgICAgIFBhdHRlcm46IHtcbiAgICAgICAgICAgICAgU2gxOiBncmFkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZm9ybS53cml0ZSgnL1BhdHRlcm4gY3MgL1NoMSBzY24nKTtcbiAgICAgICAgZm9ybS5lbmQoXCJcIi5jb25jYXQocGFnZUJCb3guam9pbignICcpLCBcIiByZSBmXCIpKTtcbiAgICAgICAgdmFyIGdzdGF0ZSA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgICAgVHlwZTogJ0V4dEdTdGF0ZScsXG4gICAgICAgICAgU01hc2s6IHtcbiAgICAgICAgICAgIFR5cGU6ICdNYXNrJyxcbiAgICAgICAgICAgIFM6ICdMdW1pbm9zaXR5JyxcbiAgICAgICAgICAgIEc6IGZvcm1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBnc3RhdGUuZW5kKCk7XG4gICAgICAgIHZhciBvcGFjaXR5UGF0dGVybiA9IHRoaXMuZG9jLnJlZih7XG4gICAgICAgICAgVHlwZTogJ1BhdHRlcm4nLFxuICAgICAgICAgIFBhdHRlcm5UeXBlOiAxLFxuICAgICAgICAgIFBhaW50VHlwZTogMSxcbiAgICAgICAgICBUaWxpbmdUeXBlOiAyLFxuICAgICAgICAgIEJCb3g6IHBhZ2VCQm94LFxuICAgICAgICAgIFhTdGVwOiBwYWdlQkJveFsyXSxcbiAgICAgICAgICBZU3RlcDogcGFnZUJCb3hbM10sXG4gICAgICAgICAgUmVzb3VyY2VzOiB7XG4gICAgICAgICAgICBQcm9jU2V0OiBbJ1BERicsICdUZXh0JywgJ0ltYWdlQicsICdJbWFnZUMnLCAnSW1hZ2VJJ10sXG4gICAgICAgICAgICBQYXR0ZXJuOiB7XG4gICAgICAgICAgICAgIFNoMTogcGF0dGVyblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIEV4dEdTdGF0ZToge1xuICAgICAgICAgICAgICBHczE6IGdzdGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9wYWNpdHlQYXR0ZXJuLndyaXRlKCcvR3MxIGdzIC9QYXR0ZXJuIGNzIC9TaDEgc2NuJyk7XG4gICAgICAgIG9wYWNpdHlQYXR0ZXJuLmVuZChcIlwiLmNvbmNhdChwYWdlQkJveC5qb2luKCcgJyksIFwiIHJlIGZcIikpO1xuICAgICAgICB0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdID0gb3BhY2l0eVBhdHRlcm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvYy5wYWdlLnBhdHRlcm5zW3RoaXMuaWRdID0gcGF0dGVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KHN0cm9rZSkge1xuICAgICAgLy8gYXBwbHkgZ3JhZGllbnQgdHJhbnNmb3JtIHRvIGV4aXN0aW5nIGRvY3VtZW50IGN0bVxuICAgICAgdmFyIF90aGlzJGRvYyRfY3RtID0gX3NsaWNlZFRvQXJyYXkodGhpcy5kb2MuX2N0bSwgNiksXG4gICAgICAgICAgbTAgPSBfdGhpcyRkb2MkX2N0bVswXSxcbiAgICAgICAgICBtMSA9IF90aGlzJGRvYyRfY3RtWzFdLFxuICAgICAgICAgIG0yID0gX3RoaXMkZG9jJF9jdG1bMl0sXG4gICAgICAgICAgbTMgPSBfdGhpcyRkb2MkX2N0bVszXSxcbiAgICAgICAgICBtNCA9IF90aGlzJGRvYyRfY3RtWzRdLFxuICAgICAgICAgIG01ID0gX3RoaXMkZG9jJF9jdG1bNV07XG5cbiAgICAgIHZhciBfdGhpcyR0cmFuc2Zvcm0gPSBfc2xpY2VkVG9BcnJheSh0aGlzLnRyYW5zZm9ybSwgNiksXG4gICAgICAgICAgbTExID0gX3RoaXMkdHJhbnNmb3JtWzBdLFxuICAgICAgICAgIG0xMiA9IF90aGlzJHRyYW5zZm9ybVsxXSxcbiAgICAgICAgICBtMjEgPSBfdGhpcyR0cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgbTIyID0gX3RoaXMkdHJhbnNmb3JtWzNdLFxuICAgICAgICAgIGR4ID0gX3RoaXMkdHJhbnNmb3JtWzRdLFxuICAgICAgICAgIGR5ID0gX3RoaXMkdHJhbnNmb3JtWzVdO1xuXG4gICAgICB2YXIgbSA9IFttMCAqIG0xMSArIG0yICogbTEyLCBtMSAqIG0xMSArIG0zICogbTEyLCBtMCAqIG0yMSArIG0yICogbTIyLCBtMSAqIG0yMSArIG0zICogbTIyLCBtMCAqIGR4ICsgbTIgKiBkeSArIG00LCBtMSAqIGR4ICsgbTMgKiBkeSArIG01XTtcblxuICAgICAgaWYgKCF0aGlzLmVtYmVkZGVkIHx8IG0uam9pbignICcpICE9PSB0aGlzLm1hdHJpeC5qb2luKCcgJykpIHtcbiAgICAgICAgdGhpcy5lbWJlZChtKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kb2MuX3NldENvbG9yU3BhY2UoJ1BhdHRlcm4nLCBzdHJva2UpO1xuXG4gICAgICB2YXIgb3AgPSBzdHJva2UgPyAnU0NOJyA6ICdzY24nO1xuICAgICAgcmV0dXJuIHRoaXMuZG9jLmFkZENvbnRlbnQoXCIvXCIuY29uY2F0KHRoaXMuaWQsIFwiIFwiKS5jb25jYXQob3ApKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGR3JhZGllbnQ7XG59KCk7XG5cbnZhciBQREZMaW5lYXJHcmFkaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BERkdyYWRpZW50KSB7XG4gIF9pbmhlcml0cyhQREZMaW5lYXJHcmFkaWVudCwgX1BERkdyYWRpZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBERkxpbmVhckdyYWRpZW50KTtcblxuICBmdW5jdGlvbiBQREZMaW5lYXJHcmFkaWVudChkb2MsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkxpbmVhckdyYWRpZW50KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZG9jKTtcbiAgICBfdGhpcy54MSA9IHgxO1xuICAgIF90aGlzLnkxID0geTE7XG4gICAgX3RoaXMueDIgPSB4MjtcbiAgICBfdGhpcy55MiA9IHkyO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZMaW5lYXJHcmFkaWVudCwgW3tcbiAgICBrZXk6IFwic2hhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoYWRlcihmbikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jLnJlZih7XG4gICAgICAgIFNoYWRpbmdUeXBlOiAyLFxuICAgICAgICBDb2xvclNwYWNlOiB0aGlzLl9jb2xvclNwYWNlLFxuICAgICAgICBDb29yZHM6IFt0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyXSxcbiAgICAgICAgRnVuY3Rpb246IGZuLFxuICAgICAgICBFeHRlbmQ6IFt0cnVlLCB0cnVlXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9wYWNpdHlHcmFkaWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGFjaXR5R3JhZGllbnQoKSB7XG4gICAgICByZXR1cm4gbmV3IFBERkxpbmVhckdyYWRpZW50KHRoaXMuZG9jLCB0aGlzLngxLCB0aGlzLnkxLCB0aGlzLngyLCB0aGlzLnkyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGTGluZWFyR3JhZGllbnQ7XG59KFBERkdyYWRpZW50KTtcblxudmFyIFBERlJhZGlhbEdyYWRpZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUERGR3JhZGllbnQyKSB7XG4gIF9pbmhlcml0cyhQREZSYWRpYWxHcmFkaWVudCwgX1BERkdyYWRpZW50Mik7XG5cbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoUERGUmFkaWFsR3JhZGllbnQpO1xuXG4gIGZ1bmN0aW9uIFBERlJhZGlhbEdyYWRpZW50KGRvYywgeDEsIHkxLCByMSwgeDIsIHkyLCByMikge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGUmFkaWFsR3JhZGllbnQpO1xuXG4gICAgX3RoaXMyID0gX3N1cGVyMi5jYWxsKHRoaXMsIGRvYyk7XG4gICAgX3RoaXMyLmRvYyA9IGRvYztcbiAgICBfdGhpczIueDEgPSB4MTtcbiAgICBfdGhpczIueTEgPSB5MTtcbiAgICBfdGhpczIucjEgPSByMTtcbiAgICBfdGhpczIueDIgPSB4MjtcbiAgICBfdGhpczIueTIgPSB5MjtcbiAgICBfdGhpczIucjIgPSByMjtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERlJhZGlhbEdyYWRpZW50LCBbe1xuICAgIGtleTogXCJzaGFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hhZGVyKGZuKSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgU2hhZGluZ1R5cGU6IDMsXG4gICAgICAgIENvbG9yU3BhY2U6IHRoaXMuX2NvbG9yU3BhY2UsXG4gICAgICAgIENvb3JkczogW3RoaXMueDEsIHRoaXMueTEsIHRoaXMucjEsIHRoaXMueDIsIHRoaXMueTIsIHRoaXMucjJdLFxuICAgICAgICBGdW5jdGlvbjogZm4sXG4gICAgICAgIEV4dGVuZDogW3RydWUsIHRydWVdXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3BhY2l0eUdyYWRpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wYWNpdHlHcmFkaWVudCgpIHtcbiAgICAgIHJldHVybiBuZXcgUERGUmFkaWFsR3JhZGllbnQodGhpcy5kb2MsIHRoaXMueDEsIHRoaXMueTEsIHRoaXMucjEsIHRoaXMueDIsIHRoaXMueTIsIHRoaXMucjIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZSYWRpYWxHcmFkaWVudDtcbn0oUERGR3JhZGllbnQpO1xuXG52YXIgR3JhZGllbnQgPSB7XG4gIFBERkdyYWRpZW50OiBQREZHcmFkaWVudCxcbiAgUERGTGluZWFyR3JhZGllbnQ6IFBERkxpbmVhckdyYWRpZW50LFxuICBQREZSYWRpYWxHcmFkaWVudDogUERGUmFkaWFsR3JhZGllbnRcbn07XG5cbi8qXHJcblBERiB0aWxpbmcgcGF0dGVybiBzdXBwb3J0LiBVbmNvbG9yZWQgb25seS5cclxuICovXG52YXIgdW5kZXJseWluZ0NvbG9yU3BhY2VzID0gWydEZXZpY2VDTVlLJywgJ0RldmljZVJHQiddO1xuXG52YXIgUERGVGlsaW5nUGF0dGVybiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERlRpbGluZ1BhdHRlcm4oZG9jLCBiQm94LCB4U3RlcCwgeVN0ZXAsIHN0cmVhbSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZUaWxpbmdQYXR0ZXJuKTtcblxuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIHRoaXMuYkJveCA9IGJCb3g7XG4gICAgdGhpcy54U3RlcCA9IHhTdGVwO1xuICAgIHRoaXMueVN0ZXAgPSB5U3RlcDtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZUaWxpbmdQYXR0ZXJuLCBbe1xuICAgIGtleTogXCJjcmVhdGVQYXR0ZXJuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVBhdHRlcm4oKSB7XG4gICAgICAvLyBubyByZXNvdXJjZXMgbmVlZGVkIGZvciBvdXIgY3VycmVudCB1c2FnZVxuICAgICAgLy8gcmVxdWlyZWQgZW50cnlcbiAgICAgIHZhciByZXNvdXJjZXMgPSB0aGlzLmRvYy5yZWYoKTtcbiAgICAgIHJlc291cmNlcy5lbmQoKTsgLy8gYXBwbHkgZGVmYXVsdCB0cmFuc2Zvcm0gbWF0cml4IChmbGlwcGVkIGluIHRoZSBkZWZhdWx0IGRvYy5fY3RtKVxuICAgICAgLy8gc2VlIGRvY3VtZW50LmpzICYgZ3JhZGllbnQuanNcblxuICAgICAgdmFyIF90aGlzJGRvYyRfY3RtID0gX3NsaWNlZFRvQXJyYXkodGhpcy5kb2MuX2N0bSwgNiksXG4gICAgICAgICAgbTAgPSBfdGhpcyRkb2MkX2N0bVswXSxcbiAgICAgICAgICBtMSA9IF90aGlzJGRvYyRfY3RtWzFdLFxuICAgICAgICAgIG0yID0gX3RoaXMkZG9jJF9jdG1bMl0sXG4gICAgICAgICAgbTMgPSBfdGhpcyRkb2MkX2N0bVszXSxcbiAgICAgICAgICBtNCA9IF90aGlzJGRvYyRfY3RtWzRdLFxuICAgICAgICAgIG01ID0gX3RoaXMkZG9jJF9jdG1bNV07XG5cbiAgICAgIHZhciBtMTEgPSAxLFxuICAgICAgICAgIG0xMiA9IDAsXG4gICAgICAgICAgbTIxID0gMCxcbiAgICAgICAgICBtMjIgPSAxLFxuICAgICAgICAgIGR4ID0gMCxcbiAgICAgICAgICBkeSA9IDA7XG4gICAgICB2YXIgbSA9IFttMCAqIG0xMSArIG0yICogbTEyLCBtMSAqIG0xMSArIG0zICogbTEyLCBtMCAqIG0yMSArIG0yICogbTIyLCBtMSAqIG0yMSArIG0zICogbTIyLCBtMCAqIGR4ICsgbTIgKiBkeSArIG00LCBtMSAqIGR4ICsgbTMgKiBkeSArIG01XTtcbiAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5kb2MucmVmKHtcbiAgICAgICAgVHlwZTogJ1BhdHRlcm4nLFxuICAgICAgICBQYXR0ZXJuVHlwZTogMSxcbiAgICAgICAgLy8gdGlsaW5nXG4gICAgICAgIFBhaW50VHlwZTogMixcbiAgICAgICAgLy8gMS1jb2xvcmVkLCAyLXVuY29sb3JlZFxuICAgICAgICBUaWxpbmdUeXBlOiAyLFxuICAgICAgICAvLyAyLW5vIGRpc3RvcnRpb25cbiAgICAgICAgQkJveDogdGhpcy5iQm94LFxuICAgICAgICBYU3RlcDogdGhpcy54U3RlcCxcbiAgICAgICAgWVN0ZXA6IHRoaXMueVN0ZXAsXG4gICAgICAgIE1hdHJpeDogbS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gK3YudG9GaXhlZCg1KTtcbiAgICAgICAgfSksXG4gICAgICAgIFJlc291cmNlczogcmVzb3VyY2VzXG4gICAgICB9KTtcbiAgICAgIHBhdHRlcm4uZW5kKHRoaXMuc3RyZWFtKTtcbiAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWJlZFBhdHRlcm5Db2xvclNwYWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWJlZFBhdHRlcm5Db2xvclNwYWNlcygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIG1hcCBlYWNoIHBhdHRlcm4gdG8gYW4gdW5kZXJseWluZyBjb2xvciBzcGFjZVxuICAgICAgLy8gYW5kIGVtYmVkIG9uIGVhY2ggcGFnZVxuICAgICAgdW5kZXJseWluZ0NvbG9yU3BhY2VzLmZvckVhY2goZnVuY3Rpb24gKGNzTmFtZSkge1xuICAgICAgICB2YXIgY3NJZCA9IF90aGlzLmdldFBhdHRlcm5Db2xvclNwYWNlSWQoY3NOYW1lKTtcblxuICAgICAgICBpZiAoX3RoaXMuZG9jLnBhZ2UuY29sb3JTcGFjZXNbY3NJZF0pIHJldHVybjtcblxuICAgICAgICB2YXIgY3MgPSBfdGhpcy5kb2MucmVmKFsnUGF0dGVybicsIGNzTmFtZV0pO1xuXG4gICAgICAgIGNzLmVuZCgpO1xuICAgICAgICBfdGhpcy5kb2MucGFnZS5jb2xvclNwYWNlc1tjc0lkXSA9IGNzO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhdHRlcm5Db2xvclNwYWNlSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGF0dGVybkNvbG9yU3BhY2VJZCh1bmRlcmx5aW5nQ29sb3JzcGFjZSkge1xuICAgICAgcmV0dXJuIFwiQ3NQXCIuY29uY2F0KHVuZGVybHlpbmdDb2xvcnNwYWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1iZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1iZWQoKSB7XG4gICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgdGhpcy5kb2MuX3BhdHRlcm5Db3VudCA9IHRoaXMuZG9jLl9wYXR0ZXJuQ291bnQgKyAxO1xuICAgICAgICB0aGlzLmlkID0gJ1AnICsgdGhpcy5kb2MuX3BhdHRlcm5Db3VudDtcbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gdGhpcy5jcmVhdGVQYXR0ZXJuKCk7XG4gICAgICB9IC8vIHBhdHRlcm5zIGFyZSBlbWJlZGRlZCBpbiBlYWNoIHBhZ2VcblxuXG4gICAgICBpZiAoIXRoaXMuZG9jLnBhZ2UucGF0dGVybnNbdGhpcy5pZF0pIHtcbiAgICAgICAgdGhpcy5kb2MucGFnZS5wYXR0ZXJuc1t0aGlzLmlkXSA9IHRoaXMucGF0dGVybjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHkoc3Ryb2tlLCBwYXR0ZXJuQ29sb3IpIHtcbiAgICAgIC8vIGRvIGFueSBlbWJlZGRpbmcvY3JlYXRpbmcgdGhhdCBtaWdodCBiZSBuZWVkZWRcbiAgICAgIHRoaXMuZW1iZWRQYXR0ZXJuQ29sb3JTcGFjZXMoKTtcbiAgICAgIHRoaXMuZW1iZWQoKTtcblxuICAgICAgdmFyIG5vcm1hbGl6ZWRDb2xvciA9IHRoaXMuZG9jLl9ub3JtYWxpemVDb2xvcihwYXR0ZXJuQ29sb3IpO1xuXG4gICAgICBpZiAoIW5vcm1hbGl6ZWRDb2xvcikgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHBhdHRlcm4gY29sb3IuICh2YWx1ZTogXCIuY29uY2F0KHBhdHRlcm5Db2xvciwgXCIpXCIpKTsgLy8gc2VsZWN0IG9uZSBvZiB0aGUgcGF0dGVybiBjb2xvciBzcGFjZXNcblxuICAgICAgdmFyIGNzSWQgPSB0aGlzLmdldFBhdHRlcm5Db2xvclNwYWNlSWQodGhpcy5kb2MuX2dldENvbG9yU3BhY2Uobm9ybWFsaXplZENvbG9yKSk7XG5cbiAgICAgIHRoaXMuZG9jLl9zZXRDb2xvclNwYWNlKGNzSWQsIHN0cm9rZSk7IC8vIHN0cm9rZS9maWxsIHVzaW5nIHRoZSBwYXR0ZXJuIGFuZCBjb2xvciAoaW4gdGhlIGFib3ZlIHVuZGVybHlpbmcgY29sb3Igc3BhY2UpXG5cblxuICAgICAgdmFyIG9wID0gc3Ryb2tlID8gJ1NDTicgOiAnc2NuJztcbiAgICAgIHJldHVybiB0aGlzLmRvYy5hZGRDb250ZW50KFwiXCIuY29uY2F0KG5vcm1hbGl6ZWRDb2xvci5qb2luKCcgJyksIFwiIC9cIikuY29uY2F0KHRoaXMuaWQsIFwiIFwiKS5jb25jYXQob3ApKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGVGlsaW5nUGF0dGVybjtcbn0oKTtcblxudmFyIHBhdHRlcm4gPSB7XG4gIFBERlRpbGluZ1BhdHRlcm46IFBERlRpbGluZ1BhdHRlcm5cbn07XG5cbnZhciBQREZHcmFkaWVudCQxID0gR3JhZGllbnQuUERGR3JhZGllbnQsXG4gICAgUERGTGluZWFyR3JhZGllbnQkMSA9IEdyYWRpZW50LlBERkxpbmVhckdyYWRpZW50LFxuICAgIFBERlJhZGlhbEdyYWRpZW50JDEgPSBHcmFkaWVudC5QREZSYWRpYWxHcmFkaWVudDtcbnZhciBQREZUaWxpbmdQYXR0ZXJuJDEgPSBwYXR0ZXJuLlBERlRpbGluZ1BhdHRlcm47XG52YXIgQ29sb3JNaXhpbiA9IHtcbiAgaW5pdENvbG9yOiBmdW5jdGlvbiBpbml0Q29sb3IoKSB7XG4gICAgLy8gVGhlIG9wYWNpdHkgZGljdGlvbmFyaWVzXG4gICAgdGhpcy5fb3BhY2l0eVJlZ2lzdHJ5ID0ge307XG4gICAgdGhpcy5fb3BhY2l0eUNvdW50ID0gMDtcbiAgICB0aGlzLl9wYXR0ZXJuQ291bnQgPSAwO1xuICAgIHJldHVybiB0aGlzLl9ncmFkQ291bnQgPSAwO1xuICB9LFxuICBfbm9ybWFsaXplQ29sb3I6IGZ1bmN0aW9uIF9ub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoY29sb3IuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgvIyhbMC05QS1GXSkoWzAtOUEtRl0pKFswLTlBLUZdKS9pLCAnIyQxJDEkMiQyJDMkMycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhleCA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgICAgIGNvbG9yID0gW2hleCA+PiAxNiwgaGV4ID4+IDggJiAweGZmLCBoZXggJiAweGZmXTtcbiAgICAgIH0gZWxzZSBpZiAobmFtZWRDb2xvcnNbY29sb3JdKSB7XG4gICAgICAgIGNvbG9yID0gbmFtZWRDb2xvcnNbY29sb3JdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSkge1xuICAgICAgLy8gUkdCXG4gICAgICBpZiAoY29sb3IubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIGNvbG9yID0gY29sb3IubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnQgLyAyNTU7XG4gICAgICAgIH0pOyAvLyBDTVlLXG4gICAgICB9IGVsc2UgaWYgKGNvbG9yLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICBjb2xvciA9IGNvbG9yLm1hcChmdW5jdGlvbiAocGFydCkge1xuICAgICAgICAgIHJldHVybiBwYXJ0IC8gMTAwO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBfc2V0Q29sb3I6IGZ1bmN0aW9uIF9zZXRDb2xvcihjb2xvciwgc3Ryb2tlKSB7XG4gICAgaWYgKGNvbG9yIGluc3RhbmNlb2YgUERGR3JhZGllbnQkMSkge1xuICAgICAgY29sb3IuYXBwbHkoc3Ryb2tlKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBzZWUgaWYgdGlsaW5nIHBhdHRlcm4sIGRlY29kZSAmIGFwcGx5IGl0IGl0XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbG9yKSAmJiBjb2xvclswXSBpbnN0YW5jZW9mIFBERlRpbGluZ1BhdHRlcm4kMSkge1xuICAgICAgY29sb3JbMF0uYXBwbHkoc3Ryb2tlLCBjb2xvclsxXSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIGFueSBvdGhlciBjYXNlIHNob3VsZCBiZSBhIG5vcm1hbCBjb2xvciBhbmQgbm90IGEgcGF0dGVyblxuXG5cbiAgICByZXR1cm4gdGhpcy5fc2V0Q29sb3JDb3JlKGNvbG9yLCBzdHJva2UpO1xuICB9LFxuICBfc2V0Q29sb3JDb3JlOiBmdW5jdGlvbiBfc2V0Q29sb3JDb3JlKGNvbG9yLCBzdHJva2UpIHtcbiAgICBjb2xvciA9IHRoaXMuX25vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcblxuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb3AgPSBzdHJva2UgPyAnU0NOJyA6ICdzY24nO1xuXG4gICAgdmFyIHNwYWNlID0gdGhpcy5fZ2V0Q29sb3JTcGFjZShjb2xvcik7XG5cbiAgICB0aGlzLl9zZXRDb2xvclNwYWNlKHNwYWNlLCBzdHJva2UpO1xuXG4gICAgY29sb3IgPSBjb2xvci5qb2luKCcgJyk7XG4gICAgdGhpcy5hZGRDb250ZW50KFwiXCIuY29uY2F0KGNvbG9yLCBcIiBcIikuY29uY2F0KG9wKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIF9zZXRDb2xvclNwYWNlOiBmdW5jdGlvbiBfc2V0Q29sb3JTcGFjZShzcGFjZSwgc3Ryb2tlKSB7XG4gICAgdmFyIG9wID0gc3Ryb2tlID8gJ0NTJyA6ICdjcyc7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChcIi9cIi5jb25jYXQoc3BhY2UsIFwiIFwiKS5jb25jYXQob3ApKTtcbiAgfSxcbiAgX2dldENvbG9yU3BhY2U6IGZ1bmN0aW9uIF9nZXRDb2xvclNwYWNlKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yLmxlbmd0aCA9PT0gNCA/ICdEZXZpY2VDTVlLJyA6ICdEZXZpY2VSR0InO1xuICB9LFxuICBmaWxsQ29sb3I6IGZ1bmN0aW9uIGZpbGxDb2xvcihjb2xvciwgb3BhY2l0eSkge1xuICAgIHZhciBzZXQgPSB0aGlzLl9zZXRDb2xvcihjb2xvciwgZmFsc2UpO1xuXG4gICAgaWYgKHNldCkge1xuICAgICAgdGhpcy5maWxsT3BhY2l0eShvcGFjaXR5KTtcbiAgICB9IC8vIHNhdmUgdGhpcyBmb3IgdGV4dCB3cmFwcGVyLCB3aGljaCBuZWVkcyB0byByZXNldFxuICAgIC8vIHRoZSBmaWxsIGNvbG9yIG9uIG5ldyBwYWdlc1xuXG5cbiAgICB0aGlzLl9maWxsQ29sb3IgPSBbY29sb3IsIG9wYWNpdHldO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHJva2VDb2xvcjogZnVuY3Rpb24gc3Ryb2tlQ29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICB2YXIgc2V0ID0gdGhpcy5fc2V0Q29sb3IoY29sb3IsIHRydWUpO1xuXG4gICAgaWYgKHNldCkge1xuICAgICAgdGhpcy5zdHJva2VPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvcGFjaXR5OiBmdW5jdGlvbiBvcGFjaXR5KF9vcGFjaXR5KSB7XG4gICAgdGhpcy5fZG9PcGFjaXR5KF9vcGFjaXR5LCBfb3BhY2l0eSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZmlsbE9wYWNpdHk6IGZ1bmN0aW9uIGZpbGxPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9kb09wYWNpdHkob3BhY2l0eSwgbnVsbCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc3Ryb2tlT3BhY2l0eTogZnVuY3Rpb24gc3Ryb2tlT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5fZG9PcGFjaXR5KG51bGwsIG9wYWNpdHkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb09wYWNpdHk6IGZ1bmN0aW9uIF9kb09wYWNpdHkoZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHkpIHtcbiAgICB2YXIgZGljdGlvbmFyeSwgbmFtZTtcblxuICAgIGlmIChmaWxsT3BhY2l0eSA9PSBudWxsICYmIHN0cm9rZU9wYWNpdHkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmaWxsT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICBmaWxsT3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGZpbGxPcGFjaXR5KSk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZU9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgc3Ryb2tlT3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHN0cm9rZU9wYWNpdHkpKTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gXCJcIi5jb25jYXQoZmlsbE9wYWNpdHksIFwiX1wiKS5jb25jYXQoc3Ryb2tlT3BhY2l0eSk7XG5cbiAgICBpZiAodGhpcy5fb3BhY2l0eVJlZ2lzdHJ5W2tleV0pIHtcbiAgICAgIHZhciBfdGhpcyRfb3BhY2l0eVJlZ2lzdHIgPSBfc2xpY2VkVG9BcnJheSh0aGlzLl9vcGFjaXR5UmVnaXN0cnlba2V5XSwgMik7XG5cbiAgICAgIGRpY3Rpb25hcnkgPSBfdGhpcyRfb3BhY2l0eVJlZ2lzdHJbMF07XG4gICAgICBuYW1lID0gX3RoaXMkX29wYWNpdHlSZWdpc3RyWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWN0aW9uYXJ5ID0ge1xuICAgICAgICBUeXBlOiAnRXh0R1N0YXRlJ1xuICAgICAgfTtcblxuICAgICAgaWYgKGZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgZGljdGlvbmFyeS5jYSA9IGZpbGxPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuQ0EgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBkaWN0aW9uYXJ5ID0gdGhpcy5yZWYoZGljdGlvbmFyeSk7XG4gICAgICBkaWN0aW9uYXJ5LmVuZCgpO1xuICAgICAgdmFyIGlkID0gKyt0aGlzLl9vcGFjaXR5Q291bnQ7XG4gICAgICBuYW1lID0gXCJHc1wiLmNvbmNhdChpZCk7XG4gICAgICB0aGlzLl9vcGFjaXR5UmVnaXN0cnlba2V5XSA9IFtkaWN0aW9uYXJ5LCBuYW1lXTtcbiAgICB9XG5cbiAgICB0aGlzLnBhZ2UuZXh0X2dzdGF0ZXNbbmFtZV0gPSBkaWN0aW9uYXJ5O1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoXCIvXCIuY29uY2F0KG5hbWUsIFwiIGdzXCIpKTtcbiAgfSxcbiAgbGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uIGxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIG5ldyBQREZMaW5lYXJHcmFkaWVudCQxKHRoaXMsIHgxLCB5MSwgeDIsIHkyKTtcbiAgfSxcbiAgcmFkaWFsR3JhZGllbnQ6IGZ1bmN0aW9uIHJhZGlhbEdyYWRpZW50KHgxLCB5MSwgcjEsIHgyLCB5MiwgcjIpIHtcbiAgICByZXR1cm4gbmV3IFBERlJhZGlhbEdyYWRpZW50JDEodGhpcywgeDEsIHkxLCByMSwgeDIsIHkyLCByMik7XG4gIH0sXG4gIHBhdHRlcm46IGZ1bmN0aW9uIHBhdHRlcm4oYmJveCwgeFN0ZXAsIHlTdGVwLCBzdHJlYW0pIHtcbiAgICByZXR1cm4gbmV3IFBERlRpbGluZ1BhdHRlcm4kMSh0aGlzLCBiYm94LCB4U3RlcCwgeVN0ZXAsIHN0cmVhbSk7XG4gIH1cbn07XG52YXIgbmFtZWRDb2xvcnMgPSB7XG4gIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICBhbnRpcXVld2hpdGU6IFsyNTAsIDIzNSwgMjE1XSxcbiAgYXF1YTogWzAsIDI1NSwgMjU1XSxcbiAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICBhenVyZTogWzI0MCwgMjU1LCAyNTVdLFxuICBiZWlnZTogWzI0NSwgMjQ1LCAyMjBdLFxuICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgYmxhbmNoZWRhbG1vbmQ6IFsyNTUsIDIzNSwgMjA1XSxcbiAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gIGJsdWV2aW9sZXQ6IFsxMzgsIDQzLCAyMjZdLFxuICBicm93bjogWzE2NSwgNDIsIDQyXSxcbiAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gIGNhZGV0Ymx1ZTogWzk1LCAxNTgsIDE2MF0sXG4gIGNoYXJ0cmV1c2U6IFsxMjcsIDI1NSwgMF0sXG4gIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gIGNvcmFsOiBbMjU1LCAxMjcsIDgwXSxcbiAgY29ybmZsb3dlcmJsdWU6IFsxMDAsIDE0OSwgMjM3XSxcbiAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgY3JpbXNvbjogWzIyMCwgMjAsIDYwXSxcbiAgY3lhbjogWzAsIDI1NSwgMjU1XSxcbiAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICBkYXJrY3lhbjogWzAsIDEzOSwgMTM5XSxcbiAgZGFya2dvbGRlbnJvZDogWzE4NCwgMTM0LCAxMV0sXG4gIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtncmVlbjogWzAsIDEwMCwgMF0sXG4gIGRhcmtncmV5OiBbMTY5LCAxNjksIDE2OV0sXG4gIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICBkYXJrbWFnZW50YTogWzEzOSwgMCwgMTM5XSxcbiAgZGFya29saXZlZ3JlZW46IFs4NSwgMTA3LCA0N10sXG4gIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gIGRhcmtvcmNoaWQ6IFsxNTMsIDUwLCAyMDRdLFxuICBkYXJrcmVkOiBbMTM5LCAwLCAwXSxcbiAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICBkYXJrc2VhZ3JlZW46IFsxNDMsIDE4OCwgMTQzXSxcbiAgZGFya3NsYXRlYmx1ZTogWzcyLCA2MSwgMTM5XSxcbiAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICBkYXJrc2xhdGVncmV5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmt0dXJxdW9pc2U6IFswLCAyMDYsIDIwOV0sXG4gIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gIGRlZXBwaW5rOiBbMjU1LCAyMCwgMTQ3XSxcbiAgZGVlcHNreWJsdWU6IFswLCAxOTEsIDI1NV0sXG4gIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgZGltZ3JleTogWzEwNSwgMTA1LCAxMDVdLFxuICBkb2RnZXJibHVlOiBbMzAsIDE0NCwgMjU1XSxcbiAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICBmbG9yYWx3aGl0ZTogWzI1NSwgMjUwLCAyNDBdLFxuICBmb3Jlc3RncmVlbjogWzM0LCAxMzksIDM0XSxcbiAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgZ2FpbnNib3JvOiBbMjIwLCAyMjAsIDIyMF0sXG4gIGdob3N0d2hpdGU6IFsyNDgsIDI0OCwgMjU1XSxcbiAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgZ29sZGVucm9kOiBbMjE4LCAxNjUsIDMyXSxcbiAgZ3JheTogWzEyOCwgMTI4LCAxMjhdLFxuICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgZ3JlZW55ZWxsb3c6IFsxNzMsIDI1NSwgNDddLFxuICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICBob3RwaW5rOiBbMjU1LCAxMDUsIDE4MF0sXG4gIGluZGlhbnJlZDogWzIwNSwgOTIsIDkyXSxcbiAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gIGl2b3J5OiBbMjU1LCAyNTUsIDI0MF0sXG4gIGtoYWtpOiBbMjQwLCAyMzAsIDE0MF0sXG4gIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gIGxhdmVuZGVyYmx1c2g6IFsyNTUsIDI0MCwgMjQ1XSxcbiAgbGF3bmdyZWVuOiBbMTI0LCAyNTIsIDBdLFxuICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgbGlnaHRibHVlOiBbMTczLCAyMTYsIDIzMF0sXG4gIGxpZ2h0Y29yYWw6IFsyNDAsIDEyOCwgMTI4XSxcbiAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBbMjUwLCAyNTAsIDIxMF0sXG4gIGxpZ2h0Z3JheTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gIGxpZ2h0Z3JleTogWzIxMSwgMjExLCAyMTFdLFxuICBsaWdodHBpbms6IFsyNTUsIDE4MiwgMTkzXSxcbiAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgbGlnaHRzZWFncmVlbjogWzMyLCAxNzgsIDE3MF0sXG4gIGxpZ2h0c2t5Ymx1ZTogWzEzNSwgMjA2LCAyNTBdLFxuICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHNsYXRlZ3JleTogWzExOSwgMTM2LCAxNTNdLFxuICBsaWdodHN0ZWVsYmx1ZTogWzE3NiwgMTk2LCAyMjJdLFxuICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICBsaW1lOiBbMCwgMjU1LCAwXSxcbiAgbGltZWdyZWVuOiBbNTAsIDIwNSwgNTBdLFxuICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICBtYWdlbnRhOiBbMjU1LCAwLCAyNTVdLFxuICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gIG1lZGl1bWJsdWU6IFswLCAwLCAyMDVdLFxuICBtZWRpdW1vcmNoaWQ6IFsxODYsIDg1LCAyMTFdLFxuICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgbWVkaXVtc2VhZ3JlZW46IFs2MCwgMTc5LCAxMTNdLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFsxMjMsIDEwNCwgMjM4XSxcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gIG1lZGl1bXR1cnF1b2lzZTogWzcyLCAyMDksIDIwNF0sXG4gIG1lZGl1bXZpb2xldHJlZDogWzE5OSwgMjEsIDEzM10sXG4gIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgbWludGNyZWFtOiBbMjQ1LCAyNTUsIDI1MF0sXG4gIG1pc3R5cm9zZTogWzI1NSwgMjI4LCAyMjVdLFxuICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICBuYXZham93aGl0ZTogWzI1NSwgMjIyLCAxNzNdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICBvbGl2ZTogWzEyOCwgMTI4LCAwXSxcbiAgb2xpdmVkcmFiOiBbMTA3LCAxNDIsIDM1XSxcbiAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICBvcmFuZ2VyZWQ6IFsyNTUsIDY5LCAwXSxcbiAgb3JjaGlkOiBbMjE4LCAxMTIsIDIxNF0sXG4gIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgcGFsZWdyZWVuOiBbMTUyLCAyNTEsIDE1Ml0sXG4gIHBhbGV0dXJxdW9pc2U6IFsxNzUsIDIzOCwgMjM4XSxcbiAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICBwYXBheWF3aGlwOiBbMjU1LCAyMzksIDIxM10sXG4gIHBlYWNocHVmZjogWzI1NSwgMjE4LCAxODVdLFxuICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgcGluazogWzI1NSwgMTkyLCAyMDNdLFxuICBwbHVtOiBbMjIxLCAxNjAsIDIyMV0sXG4gIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICByZWQ6IFsyNTUsIDAsIDBdLFxuICByb3N5YnJvd246IFsxODgsIDE0MywgMTQzXSxcbiAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgc2FkZGxlYnJvd246IFsxMzksIDY5LCAxOV0sXG4gIHNhbG1vbjogWzI1MCwgMTI4LCAxMTRdLFxuICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgc2VhZ3JlZW46IFs0NiwgMTM5LCA4N10sXG4gIHNlYXNoZWxsOiBbMjU1LCAyNDUsIDIzOF0sXG4gIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gIHNreWJsdWU6IFsxMzUsIDIwNiwgMjM1XSxcbiAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgc2xhdGVncmF5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNsYXRlZ3JleTogWzExMiwgMTI4LCAxNDRdLFxuICBzbm93OiBbMjU1LCAyNTAsIDI1MF0sXG4gIHNwcmluZ2dyZWVuOiBbMCwgMjU1LCAxMjddLFxuICBzdGVlbGJsdWU6IFs3MCwgMTMwLCAxODBdLFxuICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgdGhpc3RsZTogWzIxNiwgMTkxLCAyMTZdLFxuICB0b21hdG86IFsyNTUsIDk5LCA3MV0sXG4gIHR1cnF1b2lzZTogWzY0LCAyMjQsIDIwOF0sXG4gIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICB3aGVhdDogWzI0NSwgMjIyLCAxNzldLFxuICB3aGl0ZTogWzI1NSwgMjU1LCAyNTVdLFxuICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gIHllbGxvdzogWzI1NSwgMjU1LCAwXSxcbiAgeWVsbG93Z3JlZW46IFsxNTQsIDIwNSwgNTBdXG59O1xuXG52YXIgY3gsIGN5LCBweCwgcHksIHN4LCBzeTtcbmN4ID0gY3kgPSBweCA9IHB5ID0gc3ggPSBzeSA9IDA7XG52YXIgcGFyYW1ldGVycyA9IHtcbiAgQTogNyxcbiAgYTogNyxcbiAgQzogNixcbiAgYzogNixcbiAgSDogMSxcbiAgaDogMSxcbiAgTDogMixcbiAgbDogMixcbiAgTTogMixcbiAgbTogMixcbiAgUTogNCxcbiAgcTogNCxcbiAgUzogNCxcbiAgczogNCxcbiAgVDogMixcbiAgdDogMixcbiAgVjogMSxcbiAgdjogMSxcbiAgWjogMCxcbiAgejogMFxufTtcblxudmFyIHBhcnNlID0gZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICB2YXIgY21kO1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBhcmdzID0gW107XG4gIHZhciBjdXJBcmcgPSAnJztcbiAgdmFyIGZvdW5kRGVjaW1hbCA9IGZhbHNlO1xuICB2YXIgcGFyYW1zID0gMDtcblxuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGF0aCksXG4gICAgICBfc3RlcDtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgYyA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAocGFyYW1ldGVyc1tjXSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtZXRlcnNbY107XG5cbiAgICAgICAgaWYgKGNtZCkge1xuICAgICAgICAgIC8vIHNhdmUgZXhpc3RpbmcgY29tbWFuZFxuICAgICAgICAgIGlmIChjdXJBcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXJnc1thcmdzLmxlbmd0aF0gPSArY3VyQXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgIGNtZDogY21kLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgICAgYXJncyA9IFtdO1xuICAgICAgICAgIGN1ckFyZyA9ICcnO1xuICAgICAgICAgIGZvdW5kRGVjaW1hbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY21kID0gYztcbiAgICAgIH0gZWxzZSBpZiAoWycgJywgJywnXS5pbmNsdWRlcyhjKSB8fCBjID09PSAnLScgJiYgY3VyQXJnLmxlbmd0aCA+IDAgJiYgY3VyQXJnW2N1ckFyZy5sZW5ndGggLSAxXSAhPT0gJ2UnIHx8IGMgPT09ICcuJyAmJiBmb3VuZERlY2ltYWwpIHtcbiAgICAgICAgaWYgKGN1ckFyZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gcGFyYW1zKSB7XG4gICAgICAgICAgLy8gaGFuZGxlIHJldXNlZCBjb21tYW5kc1xuICAgICAgICAgIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICAgICAgICAgIGNtZDogY21kLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgICAgYXJncyA9IFsrY3VyQXJnXTsgLy8gaGFuZGxlIGFzc3VtZWQgY29tbWFuZHNcblxuICAgICAgICAgIGlmIChjbWQgPT09ICdNJykge1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjbWQgPT09ICdtJykge1xuICAgICAgICAgICAgY21kID0gJ2wnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoXSA9ICtjdXJBcmc7XG4gICAgICAgIH1cblxuICAgICAgICBmb3VuZERlY2ltYWwgPSBjID09PSAnLic7IC8vIGZpeCBmb3IgbmVnYXRpdmUgbnVtYmVycyBvciByZXBlYXRlZCBkZWNpbWFscyB3aXRoIG5vIGRlbGltZXRlciBiZXR3ZWVuIGNvbW1hbmRzXG5cbiAgICAgICAgY3VyQXJnID0gWyctJywgJy4nXS5pbmNsdWRlcyhjKSA/IGMgOiAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ckFyZyArPSBjO1xuXG4gICAgICAgIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICBmb3VuZERlY2ltYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBhZGQgdGhlIGxhc3QgY29tbWFuZFxuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuXG4gIGlmIChjdXJBcmcubGVuZ3RoID4gMCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gcGFyYW1zKSB7XG4gICAgICAvLyBoYW5kbGUgcmV1c2VkIGNvbW1hbmRzXG4gICAgICByZXRbcmV0Lmxlbmd0aF0gPSB7XG4gICAgICAgIGNtZDogY21kLFxuICAgICAgICBhcmdzOiBhcmdzXG4gICAgICB9O1xuICAgICAgYXJncyA9IFsrY3VyQXJnXTsgLy8gaGFuZGxlIGFzc3VtZWQgY29tbWFuZHNcblxuICAgICAgaWYgKGNtZCA9PT0gJ00nKSB7XG4gICAgICAgIGNtZCA9ICdMJztcbiAgICAgIH1cblxuICAgICAgaWYgKGNtZCA9PT0gJ20nKSB7XG4gICAgICAgIGNtZCA9ICdsJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXJnc1thcmdzLmxlbmd0aF0gPSArY3VyQXJnO1xuICAgIH1cbiAgfVxuXG4gIHJldFtyZXQubGVuZ3RoXSA9IHtcbiAgICBjbWQ6IGNtZCxcbiAgICBhcmdzOiBhcmdzXG4gIH07XG4gIHJldHVybiByZXQ7XG59O1xuXG52YXIgX2FwcGx5ID0gZnVuY3Rpb24gYXBwbHkoY29tbWFuZHMsIGRvYykge1xuICAvLyBjdXJyZW50IHBvaW50LCBjb250cm9sIHBvaW50LCBhbmQgc3VicGF0aCBzdGFydGluZyBwb2ludFxuICBjeCA9IGN5ID0gcHggPSBweSA9IHN4ID0gc3kgPSAwOyAvLyBydW4gdGhlIGNvbW1hbmRzXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tbWFuZHNbaV07XG5cbiAgICBpZiAodHlwZW9mIHJ1bm5lcnNbYy5jbWRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBydW5uZXJzW2MuY21kXShkb2MsIGMuYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcnVubmVycyA9IHtcbiAgTTogZnVuY3Rpb24gTShkb2MsIGEpIHtcbiAgICBjeCA9IGFbMF07XG4gICAgY3kgPSBhWzFdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHN4ID0gY3g7XG4gICAgc3kgPSBjeTtcbiAgICByZXR1cm4gZG9jLm1vdmVUbyhjeCwgY3kpO1xuICB9LFxuICBtOiBmdW5jdGlvbiBtKGRvYywgYSkge1xuICAgIGN4ICs9IGFbMF07XG4gICAgY3kgKz0gYVsxXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICBzeCA9IGN4O1xuICAgIHN5ID0gY3k7XG4gICAgcmV0dXJuIGRvYy5tb3ZlVG8oY3gsIGN5KTtcbiAgfSxcbiAgQzogZnVuY3Rpb24gQyhkb2MsIGEpIHtcbiAgICBjeCA9IGFbNF07XG4gICAgY3kgPSBhWzVdO1xuICAgIHB4ID0gYVsyXTtcbiAgICBweSA9IGFbM107XG4gICAgcmV0dXJuIGRvYy5iZXppZXJDdXJ2ZVRvLmFwcGx5KGRvYywgX3RvQ29uc3VtYWJsZUFycmF5KGEpKTtcbiAgfSxcbiAgYzogZnVuY3Rpb24gYyhkb2MsIGEpIHtcbiAgICBkb2MuYmV6aWVyQ3VydmVUbyhhWzBdICsgY3gsIGFbMV0gKyBjeSwgYVsyXSArIGN4LCBhWzNdICsgY3ksIGFbNF0gKyBjeCwgYVs1XSArIGN5KTtcbiAgICBweCA9IGN4ICsgYVsyXTtcbiAgICBweSA9IGN5ICsgYVszXTtcbiAgICBjeCArPSBhWzRdO1xuICAgIHJldHVybiBjeSArPSBhWzVdO1xuICB9LFxuICBTOiBmdW5jdGlvbiBTKGRvYywgYSkge1xuICAgIGlmIChweCA9PT0gbnVsbCkge1xuICAgICAgcHggPSBjeDtcbiAgICAgIHB5ID0gY3k7XG4gICAgfVxuXG4gICAgZG9jLmJlemllckN1cnZlVG8oY3ggLSAocHggLSBjeCksIGN5IC0gKHB5IC0gY3kpLCBhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICBweCA9IGFbMF07XG4gICAgcHkgPSBhWzFdO1xuICAgIGN4ID0gYVsyXTtcbiAgICByZXR1cm4gY3kgPSBhWzNdO1xuICB9LFxuICBzOiBmdW5jdGlvbiBzKGRvYywgYSkge1xuICAgIGlmIChweCA9PT0gbnVsbCkge1xuICAgICAgcHggPSBjeDtcbiAgICAgIHB5ID0gY3k7XG4gICAgfVxuXG4gICAgZG9jLmJlemllckN1cnZlVG8oY3ggLSAocHggLSBjeCksIGN5IC0gKHB5IC0gY3kpLCBjeCArIGFbMF0sIGN5ICsgYVsxXSwgY3ggKyBhWzJdLCBjeSArIGFbM10pO1xuICAgIHB4ID0gY3ggKyBhWzBdO1xuICAgIHB5ID0gY3kgKyBhWzFdO1xuICAgIGN4ICs9IGFbMl07XG4gICAgcmV0dXJuIGN5ICs9IGFbM107XG4gIH0sXG4gIFE6IGZ1bmN0aW9uIFEoZG9jLCBhKSB7XG4gICAgcHggPSBhWzBdO1xuICAgIHB5ID0gYVsxXTtcbiAgICBjeCA9IGFbMl07XG4gICAgY3kgPSBhWzNdO1xuICAgIHJldHVybiBkb2MucXVhZHJhdGljQ3VydmVUbyhhWzBdLCBhWzFdLCBjeCwgY3kpO1xuICB9LFxuICBxOiBmdW5jdGlvbiBxKGRvYywgYSkge1xuICAgIGRvYy5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0gKyBjeCwgYVsxXSArIGN5LCBhWzJdICsgY3gsIGFbM10gKyBjeSk7XG4gICAgcHggPSBjeCArIGFbMF07XG4gICAgcHkgPSBjeSArIGFbMV07XG4gICAgY3ggKz0gYVsyXTtcbiAgICByZXR1cm4gY3kgKz0gYVszXTtcbiAgfSxcbiAgVDogZnVuY3Rpb24gVChkb2MsIGEpIHtcbiAgICBpZiAocHggPT09IG51bGwpIHtcbiAgICAgIHB4ID0gY3g7XG4gICAgICBweSA9IGN5O1xuICAgIH0gZWxzZSB7XG4gICAgICBweCA9IGN4IC0gKHB4IC0gY3gpO1xuICAgICAgcHkgPSBjeSAtIChweSAtIGN5KTtcbiAgICB9XG5cbiAgICBkb2MucXVhZHJhdGljQ3VydmVUbyhweCwgcHksIGFbMF0sIGFbMV0pO1xuICAgIHB4ID0gY3ggLSAocHggLSBjeCk7XG4gICAgcHkgPSBjeSAtIChweSAtIGN5KTtcbiAgICBjeCA9IGFbMF07XG4gICAgcmV0dXJuIGN5ID0gYVsxXTtcbiAgfSxcbiAgdDogZnVuY3Rpb24gdChkb2MsIGEpIHtcbiAgICBpZiAocHggPT09IG51bGwpIHtcbiAgICAgIHB4ID0gY3g7XG4gICAgICBweSA9IGN5O1xuICAgIH0gZWxzZSB7XG4gICAgICBweCA9IGN4IC0gKHB4IC0gY3gpO1xuICAgICAgcHkgPSBjeSAtIChweSAtIGN5KTtcbiAgICB9XG5cbiAgICBkb2MucXVhZHJhdGljQ3VydmVUbyhweCwgcHksIGN4ICsgYVswXSwgY3kgKyBhWzFdKTtcbiAgICBjeCArPSBhWzBdO1xuICAgIHJldHVybiBjeSArPSBhWzFdO1xuICB9LFxuICBBOiBmdW5jdGlvbiBBKGRvYywgYSkge1xuICAgIHNvbHZlQXJjKGRvYywgY3gsIGN5LCBhKTtcbiAgICBjeCA9IGFbNV07XG4gICAgcmV0dXJuIGN5ID0gYVs2XTtcbiAgfSxcbiAgYTogZnVuY3Rpb24gYShkb2MsIF9hKSB7XG4gICAgX2FbNV0gKz0gY3g7XG4gICAgX2FbNl0gKz0gY3k7XG4gICAgc29sdmVBcmMoZG9jLCBjeCwgY3ksIF9hKTtcbiAgICBjeCA9IF9hWzVdO1xuICAgIHJldHVybiBjeSA9IF9hWzZdO1xuICB9LFxuICBMOiBmdW5jdGlvbiBMKGRvYywgYSkge1xuICAgIGN4ID0gYVswXTtcbiAgICBjeSA9IGFbMV07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgbDogZnVuY3Rpb24gbChkb2MsIGEpIHtcbiAgICBjeCArPSBhWzBdO1xuICAgIGN5ICs9IGFbMV07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgSDogZnVuY3Rpb24gSChkb2MsIGEpIHtcbiAgICBjeCA9IGFbMF07XG4gICAgcHggPSBweSA9IG51bGw7XG4gICAgcmV0dXJuIGRvYy5saW5lVG8oY3gsIGN5KTtcbiAgfSxcbiAgaDogZnVuY3Rpb24gaChkb2MsIGEpIHtcbiAgICBjeCArPSBhWzBdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIFY6IGZ1bmN0aW9uIFYoZG9jLCBhKSB7XG4gICAgY3kgPSBhWzBdO1xuICAgIHB4ID0gcHkgPSBudWxsO1xuICAgIHJldHVybiBkb2MubGluZVRvKGN4LCBjeSk7XG4gIH0sXG4gIHY6IGZ1bmN0aW9uIHYoZG9jLCBhKSB7XG4gICAgY3kgKz0gYVswXTtcbiAgICBweCA9IHB5ID0gbnVsbDtcbiAgICByZXR1cm4gZG9jLmxpbmVUbyhjeCwgY3kpO1xuICB9LFxuICBaOiBmdW5jdGlvbiBaKGRvYykge1xuICAgIGRvYy5jbG9zZVBhdGgoKTtcbiAgICBjeCA9IHN4O1xuICAgIHJldHVybiBjeSA9IHN5O1xuICB9LFxuICB6OiBmdW5jdGlvbiB6KGRvYykge1xuICAgIGRvYy5jbG9zZVBhdGgoKTtcbiAgICBjeCA9IHN4O1xuICAgIHJldHVybiBjeSA9IHN5O1xuICB9XG59O1xuXG52YXIgc29sdmVBcmMgPSBmdW5jdGlvbiBzb2x2ZUFyYyhkb2MsIHgsIHksIGNvb3Jkcykge1xuICB2YXIgX2Nvb3JkcyA9IF9zbGljZWRUb0FycmF5KGNvb3JkcywgNyksXG4gICAgICByeCA9IF9jb29yZHNbMF0sXG4gICAgICByeSA9IF9jb29yZHNbMV0sXG4gICAgICByb3QgPSBfY29vcmRzWzJdLFxuICAgICAgbGFyZ2UgPSBfY29vcmRzWzNdLFxuICAgICAgc3dlZXAgPSBfY29vcmRzWzRdLFxuICAgICAgZXggPSBfY29vcmRzWzVdLFxuICAgICAgZXkgPSBfY29vcmRzWzZdO1xuXG4gIHZhciBzZWdzID0gYXJjVG9TZWdtZW50cyhleCwgZXksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QsIHgsIHkpO1xuXG4gIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2VncyksXG4gICAgICBfc3RlcDI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgdmFyIHNlZyA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIHZhciBiZXogPSBzZWdtZW50VG9CZXppZXIuYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoc2VnKSk7XG4gICAgICBkb2MuYmV6aWVyQ3VydmVUby5hcHBseShkb2MsIF90b0NvbnN1bWFibGVBcnJheShiZXopKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjIuZigpO1xuICB9XG59OyAvLyBmcm9tIElua3NjYXBlIHN2Z3RvcGRmLCB0aGFua3MhXG5cblxudmFyIGFyY1RvU2VnbWVudHMgPSBmdW5jdGlvbiBhcmNUb1NlZ21lbnRzKHgsIHksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYLCBveCwgb3kpIHtcbiAgdmFyIHRoID0gcm90YXRlWCAqIChNYXRoLlBJIC8gMTgwKTtcbiAgdmFyIHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgdmFyIGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICBweCA9IGNvc190aCAqIChveCAtIHgpICogMC41ICsgc2luX3RoICogKG95IC0geSkgKiAwLjU7XG4gIHB5ID0gY29zX3RoICogKG95IC0geSkgKiAwLjUgLSBzaW5fdGggKiAob3ggLSB4KSAqIDAuNTtcbiAgdmFyIHBsID0gcHggKiBweCAvIChyeCAqIHJ4KSArIHB5ICogcHkgLyAocnkgKiByeSk7XG5cbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuXG4gIHZhciBhMDAgPSBjb3NfdGggLyByeDtcbiAgdmFyIGEwMSA9IHNpbl90aCAvIHJ4O1xuICB2YXIgYTEwID0gLXNpbl90aCAvIHJ5O1xuICB2YXIgYTExID0gY29zX3RoIC8gcnk7XG4gIHZhciB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIHZhciB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIHZhciB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICB2YXIgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcbiAgdmFyIGQgPSAoeDEgLSB4MCkgKiAoeDEgLSB4MCkgKyAoeTEgLSB5MCkgKiAoeTEgLSB5MCk7XG4gIHZhciBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuXG4gIGlmIChzZmFjdG9yX3NxIDwgMCkge1xuICAgIHNmYWN0b3Jfc3EgPSAwO1xuICB9XG5cbiAgdmFyIHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG5cbiAgaWYgKHN3ZWVwID09PSBsYXJnZSkge1xuICAgIHNmYWN0b3IgPSAtc2ZhY3RvcjtcbiAgfVxuXG4gIHZhciB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEgLSB5MCk7XG4gIHZhciB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEgLSB4MCk7XG4gIHZhciB0aDAgPSBNYXRoLmF0YW4yKHkwIC0geWMsIHgwIC0geGMpO1xuICB2YXIgdGgxID0gTWF0aC5hdGFuMih5MSAtIHljLCB4MSAtIHhjKTtcbiAgdmFyIHRoX2FyYyA9IHRoMSAtIHRoMDtcblxuICBpZiAodGhfYXJjIDwgMCAmJiBzd2VlcCA9PT0gMSkge1xuICAgIHRoX2FyYyArPSAyICogTWF0aC5QSTtcbiAgfSBlbHNlIGlmICh0aF9hcmMgPiAwICYmIHN3ZWVwID09PSAwKSB7XG4gICAgdGhfYXJjIC09IDIgKiBNYXRoLlBJO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoX2FyYyAvIChNYXRoLlBJICogMC41ICsgMC4wMDEpKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzOyBpKyspIHtcbiAgICB2YXIgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ21lbnRzO1xuICAgIHZhciB0aDMgPSB0aDAgKyAoaSArIDEpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBzZWdtZW50VG9CZXppZXIgPSBmdW5jdGlvbiBzZWdtZW50VG9CZXppZXIoY3gsIGN5LCB0aDAsIHRoMSwgcngsIHJ5LCBzaW5fdGgsIGNvc190aCkge1xuICB2YXIgYTAwID0gY29zX3RoICogcng7XG4gIHZhciBhMDEgPSAtc2luX3RoICogcnk7XG4gIHZhciBhMTAgPSBzaW5fdGggKiByeDtcbiAgdmFyIGExMSA9IGNvc190aCAqIHJ5O1xuICB2YXIgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICB2YXIgdCA9IDggLyAzICogTWF0aC5zaW4odGhfaGFsZiAqIDAuNSkgKiBNYXRoLnNpbih0aF9oYWxmICogMC41KSAvIE1hdGguc2luKHRoX2hhbGYpO1xuICB2YXIgeDEgPSBjeCArIE1hdGguY29zKHRoMCkgLSB0ICogTWF0aC5zaW4odGgwKTtcbiAgdmFyIHkxID0gY3kgKyBNYXRoLnNpbih0aDApICsgdCAqIE1hdGguY29zKHRoMCk7XG4gIHZhciB4MyA9IGN4ICsgTWF0aC5jb3ModGgxKTtcbiAgdmFyIHkzID0gY3kgKyBNYXRoLnNpbih0aDEpO1xuICB2YXIgeDIgPSB4MyArIHQgKiBNYXRoLnNpbih0aDEpO1xuICB2YXIgeTIgPSB5MyAtIHQgKiBNYXRoLmNvcyh0aDEpO1xuICByZXR1cm4gW2EwMCAqIHgxICsgYTAxICogeTEsIGExMCAqIHgxICsgYTExICogeTEsIGEwMCAqIHgyICsgYTAxICogeTIsIGExMCAqIHgyICsgYTExICogeTIsIGEwMCAqIHgzICsgYTAxICogeTMsIGExMCAqIHgzICsgYTExICogeTNdO1xufTtcblxudmFyIFNWR1BhdGggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTVkdQYXRoKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTVkdQYXRoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTVkdQYXRoLCBudWxsLCBbe1xuICAgIGtleTogXCJhcHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseShkb2MsIHBhdGgpIHtcbiAgICAgIHZhciBjb21tYW5kcyA9IHBhcnNlKHBhdGgpO1xuXG4gICAgICBfYXBwbHkoY29tbWFuZHMsIGRvYyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNWR1BhdGg7XG59KCk7XG5cbnZhciBudW1iZXIkMSA9IFBERk9iamVjdC5udW1iZXI7IC8vIFRoaXMgY29uc3RhbnQgaXMgdXNlZCB0byBhcHByb3hpbWF0ZSBhIHN5bW1ldHJpY2FsIGFyYyB1c2luZyBhIGN1YmljXG4vLyBCZXppZXIgY3VydmUuXG5cbnZhciBLQVBQQSA9IDQuMCAqICgoTWF0aC5zcXJ0KDIpIC0gMS4wKSAvIDMuMCk7XG52YXIgVmVjdG9yTWl4aW4gPSB7XG4gIGluaXRWZWN0b3I6IGZ1bmN0aW9uIGluaXRWZWN0b3IoKSB7XG4gICAgdGhpcy5fY3RtID0gWzEsIDAsIDAsIDEsIDAsIDBdOyAvLyBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuXG4gICAgcmV0dXJuIHRoaXMuX2N0bVN0YWNrID0gW107XG4gIH0sXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgdGhpcy5fY3RtU3RhY2sucHVzaCh0aGlzLl9jdG0uc2xpY2UoKSk7IC8vIFRPRE86IHNhdmUvcmVzdG9yZSBjb2xvcnNwYWNlIGFuZCBzdHlsZXMgc28gbm90IHNldHRpbmcgaXQgdW5uZXNzZXNhcmlseSBhbGwgdGhlIHRpbWU/XG5cblxuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoJ3EnKTtcbiAgfSxcbiAgcmVzdG9yZTogZnVuY3Rpb24gcmVzdG9yZSgpIHtcbiAgICB0aGlzLl9jdG0gPSB0aGlzLl9jdG1TdGFjay5wb3AoKSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnUScpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uIGNsb3NlUGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KCdoJyk7XG4gIH0sXG4gIGxpbmVXaWR0aDogZnVuY3Rpb24gbGluZVdpZHRoKHcpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KFwiXCIuY29uY2F0KG51bWJlciQxKHcpLCBcIiB3XCIpKTtcbiAgfSxcbiAgX0NBUF9TVFlMRVM6IHtcbiAgICBCVVRUOiAwLFxuICAgIFJPVU5EOiAxLFxuICAgIFNRVUFSRTogMlxuICB9LFxuICBsaW5lQ2FwOiBmdW5jdGlvbiBsaW5lQ2FwKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjID0gdGhpcy5fQ0FQX1NUWUxFU1tjLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoXCJcIi5jb25jYXQoYywgXCIgSlwiKSk7XG4gIH0sXG4gIF9KT0lOX1NUWUxFUzoge1xuICAgIE1JVEVSOiAwLFxuICAgIFJPVU5EOiAxLFxuICAgIEJFVkVMOiAyXG4gIH0sXG4gIGxpbmVKb2luOiBmdW5jdGlvbiBsaW5lSm9pbihqKSB7XG4gICAgaWYgKHR5cGVvZiBqID09PSAnc3RyaW5nJykge1xuICAgICAgaiA9IHRoaXMuX0pPSU5fU1RZTEVTW2oudG9VcHBlckNhc2UoKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChcIlwiLmNvbmNhdChqLCBcIiBqXCIpKTtcbiAgfSxcbiAgbWl0ZXJMaW1pdDogZnVuY3Rpb24gbWl0ZXJMaW1pdChtKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChcIlwiLmNvbmNhdChudW1iZXIkMShtKSwgXCIgTVwiKSk7XG4gIH0sXG4gIGRhc2g6IGZ1bmN0aW9uIGRhc2gobGVuZ3RoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBvcmlnaW5hbExlbmd0aCA9IGxlbmd0aDtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBbbGVuZ3RoLCBvcHRpb25zLnNwYWNlIHx8IGxlbmd0aF07XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkID0gbGVuZ3RoLmV2ZXJ5KGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpICYmIHggPiAwO1xuICAgIH0pO1xuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGFzaChcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxMZW5ndGgpLCBcIiwgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShvcHRpb25zKSwgXCIpIGludmFsaWQsIGxlbmd0aHMgbXVzdCBiZSBudW1lcmljIGFuZCBncmVhdGVyIHRoYW4gemVyb1wiKSk7XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gbGVuZ3RoLm1hcChudW1iZXIkMSkuam9pbignICcpO1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoXCJbXCIuY29uY2F0KGxlbmd0aCwgXCJdIFwiKS5jb25jYXQobnVtYmVyJDEob3B0aW9ucy5waGFzZSB8fCAwKSwgXCIgZFwiKSk7XG4gIH0sXG4gIHVuZGFzaDogZnVuY3Rpb24gdW5kYXNoKCkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoJ1tdIDAgZCcpO1xuICB9LFxuICBtb3ZlVG86IGZ1bmN0aW9uIG1vdmVUbyh4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChcIlwiLmNvbmNhdChudW1iZXIkMSh4KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMSh5KSwgXCIgbVwiKSk7XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24gbGluZVRvKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KFwiXCIuY29uY2F0KG51bWJlciQxKHgpLCBcIiBcIikuY29uY2F0KG51bWJlciQxKHkpLCBcIiBsXCIpKTtcbiAgfSxcbiAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChcIlwiLmNvbmNhdChudW1iZXIkMShjcDF4KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMShjcDF5KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMShjcDJ4KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMShjcDJ5KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMSh4KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMSh5KSwgXCIgY1wiKSk7XG4gIH0sXG4gIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uIHF1YWRyYXRpY0N1cnZlVG8oY3B4LCBjcHksIHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KFwiXCIuY29uY2F0KG51bWJlciQxKGNweCksIFwiIFwiKS5jb25jYXQobnVtYmVyJDEoY3B5KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMSh4KSwgXCIgXCIpLmNvbmNhdChudW1iZXIkMSh5KSwgXCIgdlwiKSk7XG4gIH0sXG4gIHJlY3Q6IGZ1bmN0aW9uIHJlY3QoeCwgeSwgdywgaCkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoXCJcIi5jb25jYXQobnVtYmVyJDEoeCksIFwiIFwiKS5jb25jYXQobnVtYmVyJDEoeSksIFwiIFwiKS5jb25jYXQobnVtYmVyJDEodyksIFwiIFwiKS5jb25jYXQobnVtYmVyJDEoaCksIFwiIHJlXCIpKTtcbiAgfSxcbiAgcm91bmRlZFJlY3Q6IGZ1bmN0aW9uIHJvdW5kZWRSZWN0KHgsIHksIHcsIGgsIHIpIHtcbiAgICBpZiAociA9PSBudWxsKSB7XG4gICAgICByID0gMDtcbiAgICB9XG5cbiAgICByID0gTWF0aC5taW4ociwgMC41ICogdywgMC41ICogaCk7IC8vIGFtb3VudCB0byBpbnNldCBjb250cm9sIHBvaW50cyBmcm9tIGNvcm5lcnMgKHNlZSBgZWxsaXBzZWApXG5cbiAgICB2YXIgYyA9IHIgKiAoMS4wIC0gS0FQUEEpO1xuICAgIHRoaXMubW92ZVRvKHggKyByLCB5KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgdyAtIHIsIHkpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4ICsgdyAtIGMsIHksIHggKyB3LCB5ICsgYywgeCArIHcsIHkgKyByKTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgdywgeSArIGggLSByKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCArIHcsIHkgKyBoIC0gYywgeCArIHcgLSBjLCB5ICsgaCwgeCArIHcgLSByLCB5ICsgaCk7XG4gICAgdGhpcy5saW5lVG8oeCArIHIsIHkgKyBoKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeCArIGMsIHkgKyBoLCB4LCB5ICsgaCAtIGMsIHgsIHkgKyBoIC0gcik7XG4gICAgdGhpcy5saW5lVG8oeCwgeSArIHIpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVUbyh4LCB5ICsgYywgeCArIGMsIHksIHggKyByLCB5KTtcbiAgICByZXR1cm4gdGhpcy5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgZWxsaXBzZTogZnVuY3Rpb24gZWxsaXBzZSh4LCB5LCByMSwgcjIpIHtcbiAgICAvLyBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXMvMjE3MzA4NCMyMTczMDg0XG4gICAgaWYgKHIyID09IG51bGwpIHtcbiAgICAgIHIyID0gcjE7XG4gICAgfVxuXG4gICAgeCAtPSByMTtcbiAgICB5IC09IHIyO1xuICAgIHZhciBveCA9IHIxICogS0FQUEE7XG4gICAgdmFyIG95ID0gcjIgKiBLQVBQQTtcbiAgICB2YXIgeGUgPSB4ICsgcjEgKiAyO1xuICAgIHZhciB5ZSA9IHkgKyByMiAqIDI7XG4gICAgdmFyIHhtID0geCArIHIxO1xuICAgIHZhciB5bSA9IHkgKyByMjtcbiAgICB0aGlzLm1vdmVUbyh4LCB5bSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHgsIHltIC0gb3ksIHhtIC0gb3gsIHksIHhtLCB5KTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gKyBveCwgeSwgeGUsIHltIC0gb3ksIHhlLCB5bSk7XG4gICAgdGhpcy5iZXppZXJDdXJ2ZVRvKHhlLCB5bSArIG95LCB4bSArIG94LCB5ZSwgeG0sIHllKTtcbiAgICB0aGlzLmJlemllckN1cnZlVG8oeG0gLSBveCwgeWUsIHgsIHltICsgb3ksIHgsIHltKTtcbiAgICByZXR1cm4gdGhpcy5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgY2lyY2xlOiBmdW5jdGlvbiBjaXJjbGUoeCwgeSwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxsaXBzZSh4LCB5LCByYWRpdXMpO1xuICB9LFxuICBhcmM6IGZ1bmN0aW9uIGFyYyh4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKSB7XG4gICAgaWYgKGFudGljbG9ja3dpc2UgPT0gbnVsbCkge1xuICAgICAgYW50aWNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBUV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuICAgIHZhciBIQUxGX1BJID0gMC41ICogTWF0aC5QSTtcbiAgICB2YXIgZGVsdGFBbmcgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFBbmcpID4gVFdPX1BJKSB7XG4gICAgICAvLyBkcmF3IG9ubHkgZnVsbCBjaXJjbGUgaWYgbW9yZSB0aGFuIHRoYXQgaXMgc3BlY2lmaWVkXG4gICAgICBkZWx0YUFuZyA9IFRXT19QSTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhQW5nICE9PSAwICYmIGFudGljbG9ja3dpc2UgIT09IGRlbHRhQW5nIDwgMCkge1xuICAgICAgLy8gbmVjZXNzYXJ5IHRvIGZsaXAgZGlyZWN0aW9uIG9mIHJlbmRlcmluZ1xuICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAtMSA6IDE7XG4gICAgICBkZWx0YUFuZyA9IGRpciAqIFRXT19QSSArIGRlbHRhQW5nO1xuICAgIH1cblxuICAgIHZhciBudW1TZWdzID0gTWF0aC5jZWlsKE1hdGguYWJzKGRlbHRhQW5nKSAvIEhBTEZfUEkpO1xuICAgIHZhciBzZWdBbmcgPSBkZWx0YUFuZyAvIG51bVNlZ3M7XG4gICAgdmFyIGhhbmRsZUxlbiA9IHNlZ0FuZyAvIEhBTEZfUEkgKiBLQVBQQSAqIHJhZGl1cztcbiAgICB2YXIgY3VyQW5nID0gc3RhcnRBbmdsZTsgLy8gY29tcG9uZW50IGRpc3RhbmNlcyBiZXR3ZWVuIGFuY2hvciBwb2ludCBhbmQgY29udHJvbCBwb2ludFxuXG4gICAgdmFyIGRlbHRhQ3ggPSAtTWF0aC5zaW4oY3VyQW5nKSAqIGhhbmRsZUxlbjtcbiAgICB2YXIgZGVsdGFDeSA9IE1hdGguY29zKGN1ckFuZykgKiBoYW5kbGVMZW47IC8vIGFuY2hvciBwb2ludFxuXG4gICAgdmFyIGF4ID0geCArIE1hdGguY29zKGN1ckFuZykgKiByYWRpdXM7XG4gICAgdmFyIGF5ID0geSArIE1hdGguc2luKGN1ckFuZykgKiByYWRpdXM7IC8vIGNhbGN1bGF0ZSBhbmQgcmVuZGVyIHNlZ21lbnRzXG5cbiAgICB0aGlzLm1vdmVUbyhheCwgYXkpO1xuXG4gICAgZm9yICh2YXIgc2VnSWR4ID0gMDsgc2VnSWR4IDwgbnVtU2Vnczsgc2VnSWR4KyspIHtcbiAgICAgIC8vIHN0YXJ0aW5nIGNvbnRyb2wgcG9pbnRcbiAgICAgIHZhciBjcDF4ID0gYXggKyBkZWx0YUN4O1xuICAgICAgdmFyIGNwMXkgPSBheSArIGRlbHRhQ3k7IC8vIHN0ZXAgYW5nbGVcblxuICAgICAgY3VyQW5nICs9IHNlZ0FuZzsgLy8gbmV4dCBhbmNob3IgcG9pbnRcblxuICAgICAgYXggPSB4ICsgTWF0aC5jb3MoY3VyQW5nKSAqIHJhZGl1cztcbiAgICAgIGF5ID0geSArIE1hdGguc2luKGN1ckFuZykgKiByYWRpdXM7IC8vIG5leHQgY29udHJvbCBwb2ludCBkZWx0YVxuXG4gICAgICBkZWx0YUN4ID0gLU1hdGguc2luKGN1ckFuZykgKiBoYW5kbGVMZW47XG4gICAgICBkZWx0YUN5ID0gTWF0aC5jb3MoY3VyQW5nKSAqIGhhbmRsZUxlbjsgLy8gZW5kaW5nIGNvbnRyb2wgcG9pbnRcblxuICAgICAgdmFyIGNwMnggPSBheCAtIGRlbHRhQ3g7XG4gICAgICB2YXIgY3AyeSA9IGF5IC0gZGVsdGFDeTsgLy8gcmVuZGVyIHNlZ21lbnRcblxuICAgICAgdGhpcy5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIGF4LCBheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24oKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHBvaW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB0aGlzLm1vdmVUby5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkocG9pbnRzLnNoaWZ0KCkgfHwgW10pKTtcblxuICAgIGZvciAodmFyIF9pID0gMCwgX3BvaW50cyA9IHBvaW50czsgX2kgPCBfcG9pbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHBvaW50ID0gX3BvaW50c1tfaV07XG4gICAgICB0aGlzLmxpbmVUby5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkocG9pbnQgfHwgW10pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jbG9zZVBhdGgoKTtcbiAgfSxcbiAgcGF0aDogZnVuY3Rpb24gcGF0aChfcGF0aCkge1xuICAgIFNWR1BhdGguYXBwbHkodGhpcywgX3BhdGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfd2luZGluZ1J1bGU6IGZ1bmN0aW9uIF93aW5kaW5nUnVsZShydWxlKSB7XG4gICAgaWYgKC9ldmVuLT9vZGQvLnRlc3QocnVsZSkpIHtcbiAgICAgIHJldHVybiAnKic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9LFxuICBmaWxsOiBmdW5jdGlvbiBmaWxsKGNvbG9yLCBydWxlKSB7XG4gICAgaWYgKC8oZXZlbi0/b2RkKXwobm9uLT96ZXJvKS8udGVzdChjb2xvcikpIHtcbiAgICAgIHJ1bGUgPSBjb2xvcjtcbiAgICAgIGNvbG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuZmlsbENvbG9yKGNvbG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hZGRDb250ZW50KFwiZlwiLmNvbmNhdCh0aGlzLl93aW5kaW5nUnVsZShydWxlKSkpO1xuICB9LFxuICBzdHJva2U6IGZ1bmN0aW9uIHN0cm9rZShjb2xvcikge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5zdHJva2VDb2xvcihjb2xvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudCgnUycpO1xuICB9LFxuICBmaWxsQW5kU3Ryb2tlOiBmdW5jdGlvbiBmaWxsQW5kU3Ryb2tlKGZpbGxDb2xvciwgc3Ryb2tlQ29sb3IsIHJ1bGUpIHtcbiAgICBpZiAoc3Ryb2tlQ29sb3IgPT0gbnVsbCkge1xuICAgICAgc3Ryb2tlQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgfVxuXG4gICAgdmFyIGlzRmlsbFJ1bGUgPSAvKGV2ZW4tP29kZCl8KG5vbi0/emVybykvO1xuXG4gICAgaWYgKGlzRmlsbFJ1bGUudGVzdChmaWxsQ29sb3IpKSB7XG4gICAgICBydWxlID0gZmlsbENvbG9yO1xuICAgICAgZmlsbENvbG9yID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaXNGaWxsUnVsZS50ZXN0KHN0cm9rZUNvbG9yKSkge1xuICAgICAgcnVsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgc3Ryb2tlQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgfVxuXG4gICAgaWYgKGZpbGxDb2xvcikge1xuICAgICAgdGhpcy5maWxsQ29sb3IoZmlsbENvbG9yKTtcbiAgICAgIHRoaXMuc3Ryb2tlQ29sb3Ioc3Ryb2tlQ29sb3IpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoXCJCXCIuY29uY2F0KHRoaXMuX3dpbmRpbmdSdWxlKHJ1bGUpKSk7XG4gIH0sXG4gIGNsaXA6IGZ1bmN0aW9uIGNsaXAocnVsZSkge1xuICAgIHJldHVybiB0aGlzLmFkZENvbnRlbnQoXCJXXCIuY29uY2F0KHRoaXMuX3dpbmRpbmdSdWxlKHJ1bGUpLCBcIiBuXCIpKTtcbiAgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obTExLCBtMTIsIG0yMSwgbTIyLCBkeCwgZHkpIHtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgIHZhciBtID0gdGhpcy5fY3RtO1xuXG4gICAgdmFyIF9tID0gX3NsaWNlZFRvQXJyYXkobSwgNiksXG4gICAgICAgIG0wID0gX21bMF0sXG4gICAgICAgIG0xID0gX21bMV0sXG4gICAgICAgIG0yID0gX21bMl0sXG4gICAgICAgIG0zID0gX21bM10sXG4gICAgICAgIG00ID0gX21bNF0sXG4gICAgICAgIG01ID0gX21bNV07XG5cbiAgICBtWzBdID0gbTAgKiBtMTEgKyBtMiAqIG0xMjtcbiAgICBtWzFdID0gbTEgKiBtMTEgKyBtMyAqIG0xMjtcbiAgICBtWzJdID0gbTAgKiBtMjEgKyBtMiAqIG0yMjtcbiAgICBtWzNdID0gbTEgKiBtMjEgKyBtMyAqIG0yMjtcbiAgICBtWzRdID0gbTAgKiBkeCArIG0yICogZHkgKyBtNDtcbiAgICBtWzVdID0gbTEgKiBkeCArIG0zICogZHkgKyBtNTtcbiAgICB2YXIgdmFsdWVzID0gW20xMSwgbTEyLCBtMjEsIG0yMiwgZHgsIGR5XS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBudW1iZXIkMSh2KTtcbiAgICB9KS5qb2luKCcgJyk7XG4gICAgcmV0dXJuIHRoaXMuYWRkQ29udGVudChcIlwiLmNvbmNhdCh2YWx1ZXMsIFwiIGNtXCIpKTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCB4LCB5KTtcbiAgfSxcbiAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUoYW5nbGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHk7XG4gICAgdmFyIHJhZCA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgY29zID0gTWF0aC5jb3MocmFkKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4ocmFkKTtcbiAgICB2YXIgeCA9IHkgPSAwO1xuXG4gICAgaWYgKG9wdGlvbnMub3JpZ2luICE9IG51bGwpIHtcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW4gPSBfc2xpY2VkVG9BcnJheShvcHRpb25zLm9yaWdpbiwgMik7XG5cbiAgICAgIHggPSBfb3B0aW9ucyRvcmlnaW5bMF07XG4gICAgICB5ID0gX29wdGlvbnMkb3JpZ2luWzFdO1xuICAgICAgdmFyIHgxID0geCAqIGNvcyAtIHkgKiBzaW47XG4gICAgICB2YXIgeTEgPSB4ICogc2luICsgeSAqIGNvcztcbiAgICAgIHggLT0geDE7XG4gICAgICB5IC09IHkxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShjb3MsIHNpbiwgLXNpbiwgY29zLCB4LCB5KTtcbiAgfSxcbiAgc2NhbGU6IGZ1bmN0aW9uIHNjYWxlKHhGYWN0b3IsIHlGYWN0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHk7XG5cbiAgICBpZiAoeUZhY3RvciA9PSBudWxsKSB7XG4gICAgICB5RmFjdG9yID0geEZhY3RvcjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHlGYWN0b3IgPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0geUZhY3RvcjtcbiAgICAgIHlGYWN0b3IgPSB4RmFjdG9yO1xuICAgIH1cblxuICAgIHZhciB4ID0geSA9IDA7XG5cbiAgICBpZiAob3B0aW9ucy5vcmlnaW4gIT0gbnVsbCkge1xuICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbjIgPSBfc2xpY2VkVG9BcnJheShvcHRpb25zLm9yaWdpbiwgMik7XG5cbiAgICAgIHggPSBfb3B0aW9ucyRvcmlnaW4yWzBdO1xuICAgICAgeSA9IF9vcHRpb25zJG9yaWdpbjJbMV07XG4gICAgICB4IC09IHhGYWN0b3IgKiB4O1xuICAgICAgeSAtPSB5RmFjdG9yICogeTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0oeEZhY3RvciwgMCwgMCwgeUZhY3RvciwgeCwgeSk7XG4gIH1cbn07XG5cbnZhciBXSU5fQU5TSV9NQVAgPSB7XG4gIDQwMjogMTMxLFxuICA4MjExOiAxNTAsXG4gIDgyMTI6IDE1MSxcbiAgODIxNjogMTQ1LFxuICA4MjE3OiAxNDYsXG4gIDgyMTg6IDEzMCxcbiAgODIyMDogMTQ3LFxuICA4MjIxOiAxNDgsXG4gIDgyMjI6IDEzMixcbiAgODIyNDogMTM0LFxuICA4MjI1OiAxMzUsXG4gIDgyMjY6IDE0OSxcbiAgODIzMDogMTMzLFxuICA4MzY0OiAxMjgsXG4gIDgyNDA6IDEzNyxcbiAgODI0OTogMTM5LFxuICA4MjUwOiAxNTUsXG4gIDcxMDogMTM2LFxuICA4NDgyOiAxNTMsXG4gIDMzODogMTQwLFxuICAzMzk6IDE1NixcbiAgNzMyOiAxNTIsXG4gIDM1MjogMTM4LFxuICAzNTM6IDE1NCxcbiAgMzc2OiAxNTksXG4gIDM4MTogMTQyLFxuICAzODI6IDE1OFxufTtcbnZhciBjaGFyYWN0ZXJzID0gXCIubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4ubm90ZGVmICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWYgICAgICAgIC5ub3RkZWZcXG4gIFxcbnNwYWNlICAgICAgICAgZXhjbGFtICAgICAgICAgcXVvdGVkYmwgICAgICAgbnVtYmVyc2lnblxcbmRvbGxhciAgICAgICAgcGVyY2VudCAgICAgICAgYW1wZXJzYW5kICAgICAgcXVvdGVzaW5nbGVcXG5wYXJlbmxlZnQgICAgIHBhcmVucmlnaHQgICAgIGFzdGVyaXNrICAgICAgIHBsdXNcXG5jb21tYSAgICAgICAgIGh5cGhlbiAgICAgICAgIHBlcmlvZCAgICAgICAgIHNsYXNoXFxuemVybyAgICAgICAgICBvbmUgICAgICAgICAgICB0d28gICAgICAgICAgICB0aHJlZVxcbmZvdXIgICAgICAgICAgZml2ZSAgICAgICAgICAgc2l4ICAgICAgICAgICAgc2V2ZW5cXG5laWdodCAgICAgICAgIG5pbmUgICAgICAgICAgIGNvbG9uICAgICAgICAgIHNlbWljb2xvblxcbmxlc3MgICAgICAgICAgZXF1YWwgICAgICAgICAgZ3JlYXRlciAgICAgICAgcXVlc3Rpb25cXG4gIFxcbmF0ICAgICAgICAgICAgQSAgICAgICAgICAgICAgQiAgICAgICAgICAgICAgQ1xcbkQgICAgICAgICAgICAgRSAgICAgICAgICAgICAgRiAgICAgICAgICAgICAgR1xcbkggICAgICAgICAgICAgSSAgICAgICAgICAgICAgSiAgICAgICAgICAgICAgS1xcbkwgICAgICAgICAgICAgTSAgICAgICAgICAgICAgTiAgICAgICAgICAgICAgT1xcblAgICAgICAgICAgICAgUSAgICAgICAgICAgICAgUiAgICAgICAgICAgICAgU1xcblQgICAgICAgICAgICAgVSAgICAgICAgICAgICAgViAgICAgICAgICAgICAgV1xcblggICAgICAgICAgICAgWSAgICAgICAgICAgICAgWiAgICAgICAgICAgICAgYnJhY2tldGxlZnRcXG5iYWNrc2xhc2ggICAgIGJyYWNrZXRyaWdodCAgIGFzY2lpY2lyY3VtICAgIHVuZGVyc2NvcmVcXG4gIFxcbmdyYXZlICAgICAgICAgYSAgICAgICAgICAgICAgYiAgICAgICAgICAgICAgY1xcbmQgICAgICAgICAgICAgZSAgICAgICAgICAgICAgZiAgICAgICAgICAgICAgZ1xcbmggICAgICAgICAgICAgaSAgICAgICAgICAgICAgaiAgICAgICAgICAgICAga1xcbmwgICAgICAgICAgICAgbSAgICAgICAgICAgICAgbiAgICAgICAgICAgICAgb1xcbnAgICAgICAgICAgICAgcSAgICAgICAgICAgICAgciAgICAgICAgICAgICAgc1xcbnQgICAgICAgICAgICAgdSAgICAgICAgICAgICAgdiAgICAgICAgICAgICAgd1xcbnggICAgICAgICAgICAgeSAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgYnJhY2VsZWZ0XFxuYmFyICAgICAgICAgICBicmFjZXJpZ2h0ICAgICBhc2NpaXRpbGRlICAgICAubm90ZGVmXFxuICBcXG5FdXJvICAgICAgICAgIC5ub3RkZWYgICAgICAgIHF1b3Rlc2luZ2xiYXNlIGZsb3JpblxcbnF1b3RlZGJsYmFzZSAgZWxsaXBzaXMgICAgICAgZGFnZ2VyICAgICAgICAgZGFnZ2VyZGJsXFxuY2lyY3VtZmxleCAgICBwZXJ0aG91c2FuZCAgICBTY2Fyb24gICAgICAgICBndWlsc2luZ2xsZWZ0XFxuT0UgICAgICAgICAgICAubm90ZGVmICAgICAgICBaY2Fyb24gICAgICAgICAubm90ZGVmXFxuLm5vdGRlZiAgICAgICBxdW90ZWxlZnQgICAgICBxdW90ZXJpZ2h0ICAgICBxdW90ZWRibGxlZnRcXG5xdW90ZWRibHJpZ2h0IGJ1bGxldCAgICAgICAgIGVuZGFzaCAgICAgICAgIGVtZGFzaFxcbnRpbGRlICAgICAgICAgdHJhZGVtYXJrICAgICAgc2Nhcm9uICAgICAgICAgZ3VpbHNpbmdscmlnaHRcXG5vZSAgICAgICAgICAgIC5ub3RkZWYgICAgICAgIHpjYXJvbiAgICAgICAgIHlkaWVyZXNpc1xcbiAgXFxuc3BhY2UgICAgICAgICBleGNsYW1kb3duICAgICBjZW50ICAgICAgICAgICBzdGVybGluZ1xcbmN1cnJlbmN5ICAgICAgeWVuICAgICAgICAgICAgYnJva2VuYmFyICAgICAgc2VjdGlvblxcbmRpZXJlc2lzICAgICAgY29weXJpZ2h0ICAgICAgb3JkZmVtaW5pbmUgICAgZ3VpbGxlbW90bGVmdFxcbmxvZ2ljYWxub3QgICAgaHlwaGVuICAgICAgICAgcmVnaXN0ZXJlZCAgICAgbWFjcm9uXFxuZGVncmVlICAgICAgICBwbHVzbWludXMgICAgICB0d29zdXBlcmlvciAgICB0aHJlZXN1cGVyaW9yXFxuYWN1dGUgICAgICAgICBtdSAgICAgICAgICAgICBwYXJhZ3JhcGggICAgICBwZXJpb2RjZW50ZXJlZFxcbmNlZGlsbGEgICAgICAgb25lc3VwZXJpb3IgICAgb3JkbWFzY3VsaW5lICAgZ3VpbGxlbW90cmlnaHRcXG5vbmVxdWFydGVyICAgIG9uZWhhbGYgICAgICAgIHRocmVlcXVhcnRlcnMgIHF1ZXN0aW9uZG93blxcbiAgXFxuQWdyYXZlICAgICAgICBBYWN1dGUgICAgICAgICBBY2lyY3VtZmxleCAgICBBdGlsZGVcXG5BZGllcmVzaXMgICAgIEFyaW5nICAgICAgICAgIEFFICAgICAgICAgICAgIENjZWRpbGxhXFxuRWdyYXZlICAgICAgICBFYWN1dGUgICAgICAgICBFY2lyY3VtZmxleCAgICBFZGllcmVzaXNcXG5JZ3JhdmUgICAgICAgIElhY3V0ZSAgICAgICAgIEljaXJjdW1mbGV4ICAgIElkaWVyZXNpc1xcbkV0aCAgICAgICAgICAgTnRpbGRlICAgICAgICAgT2dyYXZlICAgICAgICAgT2FjdXRlXFxuT2NpcmN1bWZsZXggICBPdGlsZGUgICAgICAgICBPZGllcmVzaXMgICAgICBtdWx0aXBseVxcbk9zbGFzaCAgICAgICAgVWdyYXZlICAgICAgICAgVWFjdXRlICAgICAgICAgVWNpcmN1bWZsZXhcXG5VZGllcmVzaXMgICAgIFlhY3V0ZSAgICAgICAgIFRob3JuICAgICAgICAgIGdlcm1hbmRibHNcXG4gIFxcbmFncmF2ZSAgICAgICAgYWFjdXRlICAgICAgICAgYWNpcmN1bWZsZXggICAgYXRpbGRlXFxuYWRpZXJlc2lzICAgICBhcmluZyAgICAgICAgICBhZSAgICAgICAgICAgICBjY2VkaWxsYVxcbmVncmF2ZSAgICAgICAgZWFjdXRlICAgICAgICAgZWNpcmN1bWZsZXggICAgZWRpZXJlc2lzXFxuaWdyYXZlICAgICAgICBpYWN1dGUgICAgICAgICBpY2lyY3VtZmxleCAgICBpZGllcmVzaXNcXG5ldGggICAgICAgICAgIG50aWxkZSAgICAgICAgIG9ncmF2ZSAgICAgICAgIG9hY3V0ZVxcbm9jaXJjdW1mbGV4ICAgb3RpbGRlICAgICAgICAgb2RpZXJlc2lzICAgICAgZGl2aWRlXFxub3NsYXNoICAgICAgICB1Z3JhdmUgICAgICAgICB1YWN1dGUgICAgICAgICB1Y2lyY3VtZmxleFxcbnVkaWVyZXNpcyAgICAgeWFjdXRlICAgICAgICAgdGhvcm4gICAgICAgICAgeWRpZXJlc2lzXCIuc3BsaXQoL1xccysvKTtcblxudmFyIEFGTUZvbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoQUZNRm9udCwgbnVsbCwgW3tcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGZpbGVuYW1lKSB7XG4gICAgICByZXR1cm4gbmV3IEFGTUZvbnQoZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpKTtcbiAgICB9XG4gIH1dKTtcblxuICBmdW5jdGlvbiBBRk1Gb250KGNvbnRlbnRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFGTUZvbnQpO1xuXG4gICAgdGhpcy5jb250ZW50cyA9IGNvbnRlbnRzO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuZ2x5cGhXaWR0aHMgPSB7fTtcbiAgICB0aGlzLmJvdW5kaW5nQm94ZXMgPSB7fTtcbiAgICB0aGlzLmtlcm5QYWlycyA9IHt9O1xuICAgIHRoaXMucGFyc2UoKTsgLy8gdG9kbzogcmVtb3ZlIGNoYXJXaWR0aHMgc2luY2UgYXBwZWFycyB0byBub3QgYmUgdXNlZFxuXG4gICAgdGhpcy5jaGFyV2lkdGhzID0gbmV3IEFycmF5KDI1Nik7XG5cbiAgICBmb3IgKHZhciBjaGFyID0gMDsgY2hhciA8PSAyNTU7IGNoYXIrKykge1xuICAgICAgdGhpcy5jaGFyV2lkdGhzW2NoYXJdID0gdGhpcy5nbHlwaFdpZHRoc1tjaGFyYWN0ZXJzW2NoYXJdXTtcbiAgICB9XG5cbiAgICB0aGlzLmJib3ggPSB0aGlzLmF0dHJpYnV0ZXNbJ0ZvbnRCQm94J10uc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiArZTtcbiAgICB9KTtcbiAgICB0aGlzLmFzY2VuZGVyID0gKyh0aGlzLmF0dHJpYnV0ZXNbJ0FzY2VuZGVyJ10gfHwgMCk7XG4gICAgdGhpcy5kZXNjZW5kZXIgPSArKHRoaXMuYXR0cmlidXRlc1snRGVzY2VuZGVyJ10gfHwgMCk7XG4gICAgdGhpcy54SGVpZ2h0ID0gKyh0aGlzLmF0dHJpYnV0ZXNbJ1hIZWlnaHQnXSB8fCAwKTtcbiAgICB0aGlzLmNhcEhlaWdodCA9ICsodGhpcy5hdHRyaWJ1dGVzWydDYXBIZWlnaHQnXSB8fCAwKTtcbiAgICB0aGlzLmxpbmVHYXAgPSB0aGlzLmJib3hbM10gLSB0aGlzLmJib3hbMV0gLSAodGhpcy5hc2NlbmRlciAtIHRoaXMuZGVzY2VuZGVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBRk1Gb250LCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZSgpIHtcbiAgICAgIHZhciBzZWN0aW9uID0gJyc7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmNvbnRlbnRzLnNwbGl0KCdcXG4nKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgdmFyIGE7XG5cbiAgICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKC9eU3RhcnQoXFx3KykvKSkge1xuICAgICAgICAgICAgc2VjdGlvbiA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goL15FbmQoXFx3KykvKSkge1xuICAgICAgICAgICAgc2VjdGlvbiA9ICcnO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChzZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdGb250TWV0cmljcyc6XG4gICAgICAgICAgICAgIG1hdGNoID0gbGluZS5tYXRjaCgvKF5cXHcrKVxccysoLiopLyk7XG4gICAgICAgICAgICAgIHZhciBrZXkgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbWF0Y2hbMl07XG5cbiAgICAgICAgICAgICAgaWYgKGEgPSB0aGlzLmF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgICAgICAgYSA9IHRoaXMuYXR0cmlidXRlc1trZXldID0gW2FdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGEucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdDaGFyTWV0cmljcyc6XG4gICAgICAgICAgICAgIGlmICghL15DSD9cXHMvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBuYW1lID0gbGluZS5tYXRjaCgvXFxiTlxccysoXFwuP1xcdyspXFxzKjsvKVsxXTtcbiAgICAgICAgICAgICAgdGhpcy5nbHlwaFdpZHRoc1tuYW1lXSA9ICtsaW5lLm1hdGNoKC9cXGJXWFxccysoXFxkKylcXHMqOy8pWzFdO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnS2VyblBhaXJzJzpcbiAgICAgICAgICAgICAgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eS1BYXFxzKyhcXC4/XFx3KylcXHMrKFxcLj9cXHcrKVxccysoLT9cXGQrKS8pO1xuXG4gICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMua2VyblBhaXJzW21hdGNoWzFdICsgJ1xcMCcgKyBtYXRjaFsyXV0gPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5jb2RlVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGVUZXh0KHRleHQpIHtcbiAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXIgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGNoYXIgPSBXSU5fQU5TSV9NQVBbY2hhcl0gfHwgY2hhcjtcbiAgICAgICAgcmVzLnB1c2goY2hhci50b1N0cmluZygxNikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnbHlwaHNGb3JTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2x5cGhzRm9yU3RyaW5nKHN0cmluZykge1xuICAgICAgdmFyIGdseXBocyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBnbHlwaHMucHVzaCh0aGlzLmNoYXJhY3RlclRvR2x5cGgoY2hhckNvZGUpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdseXBocztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hhcmFjdGVyVG9HbHlwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFyYWN0ZXJUb0dseXBoKGNoYXJhY3Rlcikge1xuICAgICAgcmV0dXJuIGNoYXJhY3RlcnNbV0lOX0FOU0lfTUFQW2NoYXJhY3Rlcl0gfHwgY2hhcmFjdGVyXSB8fCAnLm5vdGRlZic7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoT2ZHbHlwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aE9mR2x5cGgoZ2x5cGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdseXBoV2lkdGhzW2dseXBoXSB8fCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRLZXJuUGFpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRLZXJuUGFpcihsZWZ0LCByaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMua2VyblBhaXJzW2xlZnQgKyAnXFwwJyArIHJpZ2h0XSB8fCAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZHZhbmNlc0ZvckdseXBoc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZHZhbmNlc0ZvckdseXBocyhnbHlwaHMpIHtcbiAgICAgIHZhciBhZHZhbmNlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZ2x5cGhzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgbGVmdCA9IGdseXBoc1tpbmRleF07XG4gICAgICAgIHZhciByaWdodCA9IGdseXBoc1tpbmRleCArIDFdO1xuICAgICAgICBhZHZhbmNlcy5wdXNoKHRoaXMud2lkdGhPZkdseXBoKGxlZnQpICsgdGhpcy5nZXRLZXJuUGFpcihsZWZ0LCByaWdodCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWR2YW5jZXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFGTUZvbnQ7XG59KCk7XG5cbnZhciBQREZGb250ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRm9udCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRm9udCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRm9udCwgW3tcbiAgICBrZXk6IFwiZW5jb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY29kZSgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoT2ZTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2lkdGhPZlN0cmluZygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWYoKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5ICE9IG51bGwgPyB0aGlzLmRpY3Rpb25hcnkgOiB0aGlzLmRpY3Rpb25hcnkgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5hbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcbiAgICAgIGlmICh0aGlzLmVtYmVkZGVkIHx8IHRoaXMuZGljdGlvbmFyeSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWJlZCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZW1iZWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbWJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWJlZCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc2VzJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxpbmVIZWlnaHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluZUhlaWdodChzaXplLCBpbmNsdWRlR2FwKSB7XG4gICAgICBpZiAoaW5jbHVkZUdhcCA9PSBudWxsKSB7XG4gICAgICAgIGluY2x1ZGVHYXAgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdhcCA9IGluY2x1ZGVHYXAgPyB0aGlzLmxpbmVHYXAgOiAwO1xuICAgICAgcmV0dXJuICh0aGlzLmFzY2VuZGVyICsgZ2FwIC0gdGhpcy5kZXNjZW5kZXIpIC8gMTAwMCAqIHNpemU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkZvbnQ7XG59KCk7XG5cbnZhciBTVEFOREFSRF9GT05UUyA9IHtcbiAgQ291cmllcjogZnVuY3Rpb24gQ291cmllcigpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdDb3VyaWVyLUJvbGQnOiBmdW5jdGlvbiBDb3VyaWVyQm9sZCgpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLUJvbGQuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0NvdXJpZXItT2JsaXF1ZSc6IGZ1bmN0aW9uIENvdXJpZXJPYmxpcXVlKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0NvdXJpZXItT2JsaXF1ZS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnQ291cmllci1Cb2xkT2JsaXF1ZSc6IGZ1bmN0aW9uIENvdXJpZXJCb2xkT2JsaXF1ZSgpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9Db3VyaWVyLUJvbGRPYmxpcXVlLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gIEhlbHZldGljYTogZnVuY3Rpb24gSGVsdmV0aWNhKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnSGVsdmV0aWNhLUJvbGQnOiBmdW5jdGlvbiBIZWx2ZXRpY2FCb2xkKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS1Cb2xkLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdIZWx2ZXRpY2EtT2JsaXF1ZSc6IGZ1bmN0aW9uIEhlbHZldGljYU9ibGlxdWUoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhfX2Rpcm5hbWUgKyAnL2RhdGEvSGVsdmV0aWNhLU9ibGlxdWUuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ0hlbHZldGljYS1Cb2xkT2JsaXF1ZSc6IGZ1bmN0aW9uIEhlbHZldGljYUJvbGRPYmxpcXVlKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL0hlbHZldGljYS1Cb2xkT2JsaXF1ZS5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnVGltZXMtUm9tYW4nOiBmdW5jdGlvbiBUaW1lc1JvbWFuKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1RpbWVzLVJvbWFuLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gICdUaW1lcy1Cb2xkJzogZnVuY3Rpb24gVGltZXNCb2xkKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1RpbWVzLUJvbGQuYWZtJywgJ3V0ZjgnKTtcbiAgfSxcbiAgJ1RpbWVzLUl0YWxpYyc6IGZ1bmN0aW9uIFRpbWVzSXRhbGljKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1RpbWVzLUl0YWxpYy5hZm0nLCAndXRmOCcpO1xuICB9LFxuICAnVGltZXMtQm9sZEl0YWxpYyc6IGZ1bmN0aW9uIFRpbWVzQm9sZEl0YWxpYygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9UaW1lcy1Cb2xkSXRhbGljLmFmbScsICd1dGY4Jyk7XG4gIH0sXG4gIFN5bWJvbDogZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoX19kaXJuYW1lICsgJy9kYXRhL1N5bWJvbC5hZm0nLCAndXRmOCcpO1xuICB9LFxuICBaYXBmRGluZ2JhdHM6IGZ1bmN0aW9uIFphcGZEaW5nYmF0cygpIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKF9fZGlybmFtZSArICcvZGF0YS9aYXBmRGluZ2JhdHMuYWZtJywgJ3V0ZjgnKTtcbiAgfVxufTtcblxudmFyIFN0YW5kYXJkRm9udCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BERkZvbnQpIHtcbiAgX2luaGVyaXRzKFN0YW5kYXJkRm9udCwgX1BERkZvbnQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoU3RhbmRhcmRGb250KTtcblxuICBmdW5jdGlvbiBTdGFuZGFyZEZvbnQoZG9jdW1lbnQsIG5hbWUsIGlkKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YW5kYXJkRm9udCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgX3RoaXMuaWQgPSBpZDtcbiAgICBfdGhpcy5mb250ID0gbmV3IEFGTUZvbnQoU1RBTkRBUkRfRk9OVFNbX3RoaXMubmFtZV0oKSk7XG4gICAgdmFyIF90aGlzJGZvbnQgPSBfdGhpcy5mb250O1xuICAgIF90aGlzLmFzY2VuZGVyID0gX3RoaXMkZm9udC5hc2NlbmRlcjtcbiAgICBfdGhpcy5kZXNjZW5kZXIgPSBfdGhpcyRmb250LmRlc2NlbmRlcjtcbiAgICBfdGhpcy5iYm94ID0gX3RoaXMkZm9udC5iYm94O1xuICAgIF90aGlzLmxpbmVHYXAgPSBfdGhpcyRmb250LmxpbmVHYXA7XG4gICAgX3RoaXMueEhlaWdodCA9IF90aGlzJGZvbnQueEhlaWdodDtcbiAgICBfdGhpcy5jYXBIZWlnaHQgPSBfdGhpcyRmb250LmNhcEhlaWdodDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RhbmRhcmRGb250LCBbe1xuICAgIGtleTogXCJlbWJlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWJlZCgpIHtcbiAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhID0ge1xuICAgICAgICBUeXBlOiAnRm9udCcsXG4gICAgICAgIEJhc2VGb250OiB0aGlzLm5hbWUsXG4gICAgICAgIFN1YnR5cGU6ICdUeXBlMScsXG4gICAgICAgIEVuY29kaW5nOiAnV2luQW5zaUVuY29kaW5nJ1xuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnkuZW5kKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGUodGV4dCkge1xuICAgICAgdmFyIGVuY29kZWQgPSB0aGlzLmZvbnQuZW5jb2RlVGV4dCh0ZXh0KTtcbiAgICAgIHZhciBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzRm9yU3RyaW5nKFwiXCIuY29uY2F0KHRleHQpKTtcbiAgICAgIHZhciBhZHZhbmNlcyA9IHRoaXMuZm9udC5hZHZhbmNlc0ZvckdseXBocyhnbHlwaHMpO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICB4QWR2YW5jZTogYWR2YW5jZXNbaV0sXG4gICAgICAgICAgeUFkdmFuY2U6IDAsXG4gICAgICAgICAgeE9mZnNldDogMCxcbiAgICAgICAgICB5T2Zmc2V0OiAwLFxuICAgICAgICAgIGFkdmFuY2VXaWR0aDogdGhpcy5mb250LndpZHRoT2ZHbHlwaChnbHlwaClcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbZW5jb2RlZCwgcG9zaXRpb25zXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhPZlN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aE9mU3RyaW5nKHN0cmluZywgc2l6ZSkge1xuICAgICAgdmFyIGdseXBocyA9IHRoaXMuZm9udC5nbHlwaHNGb3JTdHJpbmcoXCJcIi5jb25jYXQoc3RyaW5nKSk7XG4gICAgICB2YXIgYWR2YW5jZXMgPSB0aGlzLmZvbnQuYWR2YW5jZXNGb3JHbHlwaHMoZ2x5cGhzKTtcbiAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhZHZhbmNlcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGFkdmFuY2UgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB3aWR0aCArPSBhZHZhbmNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzY2FsZSA9IHNpemUgLyAxMDAwO1xuICAgICAgcmV0dXJuIHdpZHRoICogc2NhbGU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaXNTdGFuZGFyZEZvbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdGFuZGFyZEZvbnQobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWUgaW4gU1RBTkRBUkRfRk9OVFM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YW5kYXJkRm9udDtcbn0oUERGRm9udCk7XG5cbnZhciB0b0hleCA9IGZ1bmN0aW9uIHRvSGV4KG51bSkge1xuICByZXR1cm4gXCIwMDAwXCIuY29uY2F0KG51bS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbn07XG5cbnZhciBFbWJlZGRlZEZvbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QREZGb250KSB7XG4gIF9pbmhlcml0cyhFbWJlZGRlZEZvbnQsIF9QREZGb250KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEVtYmVkZGVkRm9udCk7XG5cbiAgZnVuY3Rpb24gRW1iZWRkZWRGb250KGRvY3VtZW50LCBmb250LCBpZCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbWJlZGRlZEZvbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIF90aGlzLmZvbnQgPSBmb250O1xuICAgIF90aGlzLmlkID0gaWQ7XG4gICAgX3RoaXMuc3Vic2V0ID0gX3RoaXMuZm9udC5jcmVhdGVTdWJzZXQoKTtcbiAgICBfdGhpcy51bmljb2RlID0gW1swXV07XG4gICAgX3RoaXMud2lkdGhzID0gW190aGlzLmZvbnQuZ2V0R2x5cGgoMCkuYWR2YW5jZVdpZHRoXTtcbiAgICBfdGhpcy5uYW1lID0gX3RoaXMuZm9udC5wb3N0c2NyaXB0TmFtZTtcbiAgICBfdGhpcy5zY2FsZSA9IDEwMDAgLyBfdGhpcy5mb250LnVuaXRzUGVyRW07XG4gICAgX3RoaXMuYXNjZW5kZXIgPSBfdGhpcy5mb250LmFzY2VudCAqIF90aGlzLnNjYWxlO1xuICAgIF90aGlzLmRlc2NlbmRlciA9IF90aGlzLmZvbnQuZGVzY2VudCAqIF90aGlzLnNjYWxlO1xuICAgIF90aGlzLnhIZWlnaHQgPSBfdGhpcy5mb250LnhIZWlnaHQgKiBfdGhpcy5zY2FsZTtcbiAgICBfdGhpcy5jYXBIZWlnaHQgPSBfdGhpcy5mb250LmNhcEhlaWdodCAqIF90aGlzLnNjYWxlO1xuICAgIF90aGlzLmxpbmVHYXAgPSBfdGhpcy5mb250LmxpbmVHYXAgKiBfdGhpcy5zY2FsZTtcbiAgICBfdGhpcy5iYm94ID0gX3RoaXMuZm9udC5iYm94O1xuXG4gICAgaWYgKGRvY3VtZW50Lm9wdGlvbnMuZm9udExheW91dENhY2hlICE9PSBmYWxzZSkge1xuICAgICAgX3RoaXMubGF5b3V0Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFbWJlZGRlZEZvbnQsIFt7XG4gICAga2V5OiBcImxheW91dFJ1blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXRSdW4odGV4dCwgZmVhdHVyZXMpIHtcbiAgICAgIHZhciBydW4gPSB0aGlzLmZvbnQubGF5b3V0KHRleHQsIGZlYXR1cmVzKTsgLy8gTm9ybWFsaXplIHBvc2l0aW9uIHZhbHVlc1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bi5wb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gcnVuLnBvc2l0aW9uc1tpXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcG9zaXRpb24pIHtcbiAgICAgICAgICBwb3NpdGlvbltrZXldICo9IHRoaXMuc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvbi5hZHZhbmNlV2lkdGggPSBydW4uZ2x5cGhzW2ldLmFkdmFuY2VXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBydW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxheW91dENhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXRDYWNoZWQodGV4dCkge1xuICAgICAgaWYgKCF0aGlzLmxheW91dENhY2hlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dFJ1bih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlZDtcblxuICAgICAgaWYgKGNhY2hlZCA9IHRoaXMubGF5b3V0Q2FjaGVbdGV4dF0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJ1biA9IHRoaXMubGF5b3V0UnVuKHRleHQpO1xuICAgICAgdGhpcy5sYXlvdXRDYWNoZVt0ZXh0XSA9IHJ1bjtcbiAgICAgIHJldHVybiBydW47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxheW91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYXlvdXQodGV4dCwgZmVhdHVyZXMsIG9ubHlXaWR0aCkge1xuICAgICAgLy8gU2tpcCB0aGUgY2FjaGUgaWYgYW55IHVzZXIgZGVmaW5lZCBmZWF0dXJlcyBhcmUgYXBwbGllZFxuICAgICAgaWYgKGZlYXR1cmVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dFJ1bih0ZXh0LCBmZWF0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBnbHlwaHMgPSBvbmx5V2lkdGggPyBudWxsIDogW107XG4gICAgICB2YXIgcG9zaXRpb25zID0gb25seVdpZHRoID8gbnVsbCA6IFtdO1xuICAgICAgdmFyIGFkdmFuY2VXaWR0aCA9IDA7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYnkgd29yZHMgdG8gaW5jcmVhc2UgY2FjaGUgZWZmaWNpZW5jeS5cbiAgICAgIC8vIEZvciB0aGlzIHB1cnBvc2UsIHNwYWNlcyBhbmQgdGFicyBhcmUgYSBnb29kIGVub3VnaCBkZWxpbWV0ZXIuXG5cbiAgICAgIHZhciBsYXN0ID0gMDtcbiAgICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgbmVlZGxlO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gdGV4dC5sZW5ndGggJiYgbGFzdCA8IGluZGV4IHx8IChuZWVkbGUgPSB0ZXh0LmNoYXJBdChpbmRleCksIFsnICcsICdcXHQnXS5pbmNsdWRlcyhuZWVkbGUpKSkge1xuICAgICAgICAgIHZhciBydW4gPSB0aGlzLmxheW91dENhY2hlZCh0ZXh0LnNsaWNlKGxhc3QsICsraW5kZXgpKTtcblxuICAgICAgICAgIGlmICghb25seVdpZHRoKSB7XG4gICAgICAgICAgICBnbHlwaHMgPSBnbHlwaHMuY29uY2F0KHJ1bi5nbHlwaHMpO1xuICAgICAgICAgICAgcG9zaXRpb25zID0gcG9zaXRpb25zLmNvbmNhdChydW4ucG9zaXRpb25zKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZHZhbmNlV2lkdGggKz0gcnVuLmFkdmFuY2VXaWR0aDtcbiAgICAgICAgICBsYXN0ID0gaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBnbHlwaHM6IGdseXBocyxcbiAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICAgIGFkdmFuY2VXaWR0aDogYWR2YW5jZVdpZHRoXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmNvZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5jb2RlKHRleHQsIGZlYXR1cmVzKSB7XG4gICAgICB2YXIgX3RoaXMkbGF5b3V0ID0gdGhpcy5sYXlvdXQodGV4dCwgZmVhdHVyZXMpLFxuICAgICAgICAgIGdseXBocyA9IF90aGlzJGxheW91dC5nbHlwaHMsXG4gICAgICAgICAgcG9zaXRpb25zID0gX3RoaXMkbGF5b3V0LnBvc2l0aW9ucztcblxuICAgICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIHZhciBnaWQgPSB0aGlzLnN1YnNldC5pbmNsdWRlR2x5cGgoZ2x5cGguaWQpO1xuICAgICAgICByZXMucHVzaChcIjAwMDBcIi5jb25jYXQoZ2lkLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpKTtcblxuICAgICAgICBpZiAodGhpcy53aWR0aHNbZ2lkXSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy53aWR0aHNbZ2lkXSA9IGdseXBoLmFkdmFuY2VXaWR0aCAqIHRoaXMuc2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy51bmljb2RlW2dpZF0gPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5pY29kZVtnaWRdID0gZ2x5cGguY29kZVBvaW50cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3JlcywgcG9zaXRpb25zXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2lkdGhPZlN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aWR0aE9mU3RyaW5nKHN0cmluZywgc2l6ZSwgZmVhdHVyZXMpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMubGF5b3V0KHN0cmluZywgZmVhdHVyZXMsIHRydWUpLmFkdmFuY2VXaWR0aDtcbiAgICAgIHZhciBzY2FsZSA9IHNpemUgLyAxMDAwO1xuICAgICAgcmV0dXJuIHdpZHRoICogc2NhbGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVtYmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtYmVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBpc0NGRiA9IHRoaXMuc3Vic2V0LmNmZiAhPSBudWxsO1xuICAgICAgdmFyIGZvbnRGaWxlID0gdGhpcy5kb2N1bWVudC5yZWYoKTtcblxuICAgICAgaWYgKGlzQ0ZGKSB7XG4gICAgICAgIGZvbnRGaWxlLmRhdGEuU3VidHlwZSA9ICdDSURGb250VHlwZTBDJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdWJzZXQuZW5jb2RlU3RyZWFtKCkub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZm9udEZpbGUud3JpdGUoZGF0YSk7XG4gICAgICB9KS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm9udEZpbGUuZW5kKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBmYW1pbHlDbGFzcyA9ICgodGhpcy5mb250WydPUy8yJ10gIT0gbnVsbCA/IHRoaXMuZm9udFsnT1MvMiddLnNGYW1pbHlDbGFzcyA6IHVuZGVmaW5lZCkgfHwgMCkgPj4gODtcbiAgICAgIHZhciBmbGFncyA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmZvbnQucG9zdC5pc0ZpeGVkUGl0Y2gpIHtcbiAgICAgICAgZmxhZ3MgfD0gMSA8PCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoMSA8PSBmYW1pbHlDbGFzcyAmJiBmYW1pbHlDbGFzcyA8PSA3KSB7XG4gICAgICAgIGZsYWdzIHw9IDEgPDwgMTtcbiAgICAgIH1cblxuICAgICAgZmxhZ3MgfD0gMSA8PCAyOyAvLyBhc3N1bWUgdGhlIGZvbnQgdXNlcyBub24tbGF0aW4gY2hhcmFjdGVyc1xuXG4gICAgICBpZiAoZmFtaWx5Q2xhc3MgPT09IDEwKSB7XG4gICAgICAgIGZsYWdzIHw9IDEgPDwgMztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZm9udC5oZWFkLm1hY1N0eWxlLml0YWxpYykge1xuICAgICAgICBmbGFncyB8PSAxIDw8IDY7XG4gICAgICB9IC8vIGdlbmVyYXRlIGEgdGFnICg2IHVwcGVyY2FzZSBsZXR0ZXJzLiAxNyBpcyB0aGUgY2hhciBjb2RlIG9mZnNldCBmcm9tICcwJyB0byAnQScuIDczIHdpbGwgbWFwIHRvICdaJylcblxuXG4gICAgICB2YXIgdGFnID0gWzEsIDIsIDMsIDQsIDUsIDZdLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgoX3RoaXMyLmlkLmNoYXJDb2RlQXQoaSkgfHwgNzMpICsgMTcpO1xuICAgICAgfSkuam9pbignJyk7XG4gICAgICB2YXIgbmFtZSA9IHRhZyArICcrJyArIHRoaXMuZm9udC5wb3N0c2NyaXB0TmFtZTtcbiAgICAgIHZhciBiYm94ID0gdGhpcy5mb250LmJib3g7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgVHlwZTogJ0ZvbnREZXNjcmlwdG9yJyxcbiAgICAgICAgRm9udE5hbWU6IG5hbWUsXG4gICAgICAgIEZsYWdzOiBmbGFncyxcbiAgICAgICAgRm9udEJCb3g6IFtiYm94Lm1pblggKiB0aGlzLnNjYWxlLCBiYm94Lm1pblkgKiB0aGlzLnNjYWxlLCBiYm94Lm1heFggKiB0aGlzLnNjYWxlLCBiYm94Lm1heFkgKiB0aGlzLnNjYWxlXSxcbiAgICAgICAgSXRhbGljQW5nbGU6IHRoaXMuZm9udC5pdGFsaWNBbmdsZSxcbiAgICAgICAgQXNjZW50OiB0aGlzLmFzY2VuZGVyLFxuICAgICAgICBEZXNjZW50OiB0aGlzLmRlc2NlbmRlcixcbiAgICAgICAgQ2FwSGVpZ2h0OiAodGhpcy5mb250LmNhcEhlaWdodCB8fCB0aGlzLmZvbnQuYXNjZW50KSAqIHRoaXMuc2NhbGUsXG4gICAgICAgIFhIZWlnaHQ6ICh0aGlzLmZvbnQueEhlaWdodCB8fCAwKSAqIHRoaXMuc2NhbGUsXG4gICAgICAgIFN0ZW1WOiAwXG4gICAgICB9KTsgLy8gbm90IHN1cmUgaG93IHRvIGNhbGN1bGF0ZSB0aGlzXG5cbiAgICAgIGlmIChpc0NGRikge1xuICAgICAgICBkZXNjcmlwdG9yLmRhdGEuRm9udEZpbGUzID0gZm9udEZpbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXNjcmlwdG9yLmRhdGEuRm9udEZpbGUyID0gZm9udEZpbGU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRvY3VtZW50LnN1YnNldCkge1xuICAgICAgICB2YXIgQ0lEU2V0ID0gQnVmZmVyLmZyb20oJ0ZGRkZGRkZGQzAnLCAnaGV4Jyk7XG4gICAgICAgIHZhciBDSURTZXRSZWYgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgICAgICBDSURTZXRSZWYud3JpdGUoQ0lEU2V0KTtcbiAgICAgICAgQ0lEU2V0UmVmLmVuZCgpO1xuICAgICAgICBkZXNjcmlwdG9yLmRhdGEuQ0lEU2V0ID0gQ0lEU2V0UmVmO1xuICAgICAgfVxuXG4gICAgICBkZXNjcmlwdG9yLmVuZCgpO1xuICAgICAgdmFyIGRlc2NlbmRhbnRGb250RGF0YSA9IHtcbiAgICAgICAgVHlwZTogJ0ZvbnQnLFxuICAgICAgICBTdWJ0eXBlOiAnQ0lERm9udFR5cGUwJyxcbiAgICAgICAgQmFzZUZvbnQ6IG5hbWUsXG4gICAgICAgIENJRFN5c3RlbUluZm86IHtcbiAgICAgICAgICBSZWdpc3RyeTogbmV3IFN0cmluZygnQWRvYmUnKSxcbiAgICAgICAgICBPcmRlcmluZzogbmV3IFN0cmluZygnSWRlbnRpdHknKSxcbiAgICAgICAgICBTdXBwbGVtZW50OiAwXG4gICAgICAgIH0sXG4gICAgICAgIEZvbnREZXNjcmlwdG9yOiBkZXNjcmlwdG9yLFxuICAgICAgICBXOiBbMCwgdGhpcy53aWR0aHNdXG4gICAgICB9O1xuXG4gICAgICBpZiAoIWlzQ0ZGKSB7XG4gICAgICAgIGRlc2NlbmRhbnRGb250RGF0YS5TdWJ0eXBlID0gJ0NJREZvbnRUeXBlMic7XG4gICAgICAgIGRlc2NlbmRhbnRGb250RGF0YS5DSURUb0dJRE1hcCA9ICdJZGVudGl0eSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjZW5kYW50Rm9udCA9IHRoaXMuZG9jdW1lbnQucmVmKGRlc2NlbmRhbnRGb250RGF0YSk7XG4gICAgICBkZXNjZW5kYW50Rm9udC5lbmQoKTtcbiAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhID0ge1xuICAgICAgICBUeXBlOiAnRm9udCcsXG4gICAgICAgIFN1YnR5cGU6ICdUeXBlMCcsXG4gICAgICAgIEJhc2VGb250OiBuYW1lLFxuICAgICAgICBFbmNvZGluZzogJ0lkZW50aXR5LUgnLFxuICAgICAgICBEZXNjZW5kYW50Rm9udHM6IFtkZXNjZW5kYW50Rm9udF0sXG4gICAgICAgIFRvVW5pY29kZTogdGhpcy50b1VuaWNvZGVDbWFwKClcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5kaWN0aW9uYXJ5LmVuZCgpO1xuICAgIH0gLy8gTWFwcyB0aGUgZ2x5cGggaWRzIGVuY29kZWQgaW4gdGhlIFBERiBiYWNrIHRvIHVuaWNvZGUgc3RyaW5nc1xuICAgIC8vIEJlY2F1c2Ugb2YgbGlnYXR1cmUgc3Vic3RpdHV0aW9ucyBhbmQgdGhlIGxpa2UsIHRoZXJlIG1heSBiZSBvbmUgb3IgbW9yZVxuICAgIC8vIHVuaWNvZGUgY2hhcmFjdGVycyByZXByZXNlbnRlZCBieSBlYWNoIGdseXBoLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwidG9Vbmljb2RlQ21hcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1VuaWNvZGVDbWFwKCkge1xuICAgICAgdmFyIGNtYXAgPSB0aGlzLmRvY3VtZW50LnJlZigpO1xuICAgICAgdmFyIGVudHJpZXMgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMudW5pY29kZSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNvZGVQb2ludHMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgZW5jb2RlZCA9IFtdOyAvLyBlbmNvZGUgY29kZVBvaW50cyB0byB1dGYxNlxuXG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb2RlUG9pbnRzKSxcbiAgICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweGZmZmYpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwO1xuICAgICAgICAgICAgICAgIGVuY29kZWQucHVzaCh0b0hleCh2YWx1ZSA+Pj4gMTAgJiAweDNmZiB8IDB4ZDgwMCkpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gMHhkYzAwIHwgdmFsdWUgJiAweDNmZjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVuY29kZWQucHVzaCh0b0hleCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVudHJpZXMucHVzaChcIjxcIi5jb25jYXQoZW5jb2RlZC5qb2luKCcgJyksIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cblxuICAgICAgY21hcC5lbmQoXCIvQ0lESW5pdCAvUHJvY1NldCBmaW5kcmVzb3VyY2UgYmVnaW5cXG4xMiBkaWN0IGJlZ2luXFxuYmVnaW5jbWFwXFxuL0NJRFN5c3RlbUluZm8gPDxcXG4gIC9SZWdpc3RyeSAoQWRvYmUpXFxuICAvT3JkZXJpbmcgKFVDUylcXG4gIC9TdXBwbGVtZW50IDBcXG4+PiBkZWZcXG4vQ01hcE5hbWUgL0Fkb2JlLUlkZW50aXR5LVVDUyBkZWZcXG4vQ01hcFR5cGUgMiBkZWZcXG4xIGJlZ2luY29kZXNwYWNlcmFuZ2VcXG48MDAwMD48ZmZmZj5cXG5lbmRjb2Rlc3BhY2VyYW5nZVxcbjEgYmVnaW5iZnJhbmdlXFxuPDAwMDA+IDxcIi5jb25jYXQodG9IZXgoZW50cmllcy5sZW5ndGggLSAxKSwgXCI+IFtcIikuY29uY2F0KGVudHJpZXMuam9pbignICcpLCBcIl1cXG5lbmRiZnJhbmdlXFxuZW5kY21hcFxcbkNNYXBOYW1lIGN1cnJlbnRkaWN0IC9DTWFwIGRlZmluZXJlc291cmNlIHBvcFxcbmVuZFxcbmVuZFwiKSk7XG4gICAgICByZXR1cm4gY21hcDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRW1iZWRkZWRGb250O1xufShQREZGb250KTtcblxudmFyIFBERkZvbnRGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRm9udEZhY3RvcnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkZvbnRGYWN0b3J5KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZGb250RmFjdG9yeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKGRvY3VtZW50LCBzcmMsIGZhbWlseSwgaWQpIHtcbiAgICAgIHZhciBmb250O1xuXG4gICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKFN0YW5kYXJkRm9udC5pc1N0YW5kYXJkRm9udChzcmMpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGFuZGFyZEZvbnQoZG9jdW1lbnQsIHNyYywgaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3JjID0gZnMucmVhZEZpbGVTeW5jKHNyYyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3JjKSkge1xuICAgICAgICBmb250ID0gZm9udGtpdC5jcmVhdGUoc3JjLCBmYW1pbHkpO1xuICAgICAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIGZvbnQgPSBmb250a2l0LmNyZWF0ZShCdWZmZXIuZnJvbShzcmMpLCBmYW1pbHkpO1xuICAgICAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBmb250ID0gZm9udGtpdC5jcmVhdGUoQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoc3JjKSksIGZhbWlseSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb250ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBzdXBwb3J0ZWQgZm9udCBmb3JtYXQgb3Igc3RhbmRhcmQgUERGIGZvbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRW1iZWRkZWRGb250KGRvY3VtZW50LCBmb250LCBpZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkZvbnRGYWN0b3J5O1xufSgpO1xuXG52YXIgRm9udHNNaXhpbiA9IHtcbiAgaW5pdEZvbnRzOiBmdW5jdGlvbiBpbml0Rm9udHMoKSB7XG4gICAgdmFyIGRlZmF1bHRGb250ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnSGVsdmV0aWNhJztcbiAgICAvLyBMb29rdXAgdGFibGUgZm9yIGVtYmVkZGVkIGZvbnRzXG4gICAgdGhpcy5fZm9udEZhbWlsaWVzID0ge307XG4gICAgdGhpcy5fZm9udENvdW50ID0gMDsgLy8gRm9udCBzdGF0ZVxuXG4gICAgdGhpcy5fZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLl9mb250ID0gbnVsbDtcbiAgICB0aGlzLl9yZWdpc3RlcmVkRm9udHMgPSB7fTsgLy8gU2V0IHRoZSBkZWZhdWx0IGZvbnRcblxuICAgIGlmIChkZWZhdWx0Rm9udCkge1xuICAgICAgdGhpcy5mb250KGRlZmF1bHRGb250KTtcbiAgICB9XG4gIH0sXG4gIGZvbnQ6IGZ1bmN0aW9uIGZvbnQoc3JjLCBmYW1pbHksIHNpemUpIHtcbiAgICB2YXIgY2FjaGVLZXksIGZvbnQ7XG5cbiAgICBpZiAodHlwZW9mIGZhbWlseSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHNpemUgPSBmYW1pbHk7XG4gICAgICBmYW1pbHkgPSBudWxsO1xuICAgIH0gLy8gY2hlY2sgcmVnaXN0ZXJlZCBmb250cyBpZiBzcmMgaXMgYSBzdHJpbmdcblxuXG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHRoaXMuX3JlZ2lzdGVyZWRGb250c1tzcmNdKSB7XG4gICAgICBjYWNoZUtleSA9IHNyYztcbiAgICAgIHZhciBfdGhpcyRfcmVnaXN0ZXJlZEZvbnQgPSB0aGlzLl9yZWdpc3RlcmVkRm9udHNbc3JjXTtcbiAgICAgIHNyYyA9IF90aGlzJF9yZWdpc3RlcmVkRm9udC5zcmM7XG4gICAgICBmYW1pbHkgPSBfdGhpcyRfcmVnaXN0ZXJlZEZvbnQuZmFtaWx5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZUtleSA9IGZhbWlseSB8fCBzcmM7XG5cbiAgICAgIGlmICh0eXBlb2YgY2FjaGVLZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNhY2hlS2V5ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2l6ZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZvbnRTaXplKHNpemUpO1xuICAgIH0gLy8gZmFzdCBwYXRoOiBjaGVjayBpZiB0aGUgZm9udCBpcyBhbHJlYWR5IGluIHRoZSBQREZcblxuXG4gICAgaWYgKGZvbnQgPSB0aGlzLl9mb250RmFtaWxpZXNbY2FjaGVLZXldKSB7XG4gICAgICB0aGlzLl9mb250ID0gZm9udDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gbG9hZCB0aGUgZm9udFxuXG5cbiAgICB2YXIgaWQgPSBcIkZcIi5jb25jYXQoKyt0aGlzLl9mb250Q291bnQpO1xuICAgIHRoaXMuX2ZvbnQgPSBQREZGb250RmFjdG9yeS5vcGVuKHRoaXMsIHNyYywgZmFtaWx5LCBpZCk7IC8vIGNoZWNrIGZvciBleGlzdGluZyBmb250IGZhbWlsZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGFscmVhZHkgaW4gdGhlIFBERlxuICAgIC8vIHVzZWZ1bCBpZiB0aGUgZm9udCB3YXMgcGFzc2VkIGFzIGEgYnVmZmVyXG5cbiAgICBpZiAoZm9udCA9IHRoaXMuX2ZvbnRGYW1pbGllc1t0aGlzLl9mb250Lm5hbWVdKSB7XG4gICAgICB0aGlzLl9mb250ID0gZm9udDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gc2F2ZSB0aGUgZm9udCBmb3IgcmV1c2UgbGF0ZXJcblxuXG4gICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICB0aGlzLl9mb250RmFtaWxpZXNbY2FjaGVLZXldID0gdGhpcy5fZm9udDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZm9udC5uYW1lKSB7XG4gICAgICB0aGlzLl9mb250RmFtaWxpZXNbdGhpcy5fZm9udC5uYW1lXSA9IHRoaXMuX2ZvbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGZvbnRTaXplOiBmdW5jdGlvbiBmb250U2l6ZShfZm9udFNpemUpIHtcbiAgICB0aGlzLl9mb250U2l6ZSA9IF9mb250U2l6ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY3VycmVudExpbmVIZWlnaHQ6IGZ1bmN0aW9uIGN1cnJlbnRMaW5lSGVpZ2h0KGluY2x1ZGVHYXApIHtcbiAgICBpZiAoaW5jbHVkZUdhcCA9PSBudWxsKSB7XG4gICAgICBpbmNsdWRlR2FwID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2ZvbnQubGluZUhlaWdodCh0aGlzLl9mb250U2l6ZSwgaW5jbHVkZUdhcCk7XG4gIH0sXG4gIHJlZ2lzdGVyRm9udDogZnVuY3Rpb24gcmVnaXN0ZXJGb250KG5hbWUsIHNyYywgZmFtaWx5KSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEZvbnRzW25hbWVdID0ge1xuICAgICAgc3JjOiBzcmMsXG4gICAgICBmYW1pbHk6IGZhbWlseVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbnZhciBMaW5lV3JhcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoTGluZVdyYXBwZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoTGluZVdyYXBwZXIpO1xuXG4gIGZ1bmN0aW9uIExpbmVXcmFwcGVyKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmVXcmFwcGVyKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICBfdGhpcy5pbmRlbnQgPSBvcHRpb25zLmluZGVudCB8fCAwO1xuICAgIF90aGlzLmNoYXJhY3RlclNwYWNpbmcgPSBvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMDtcbiAgICBfdGhpcy53b3JkU3BhY2luZyA9IG9wdGlvbnMud29yZFNwYWNpbmcgPT09IDA7XG4gICAgX3RoaXMuY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucyB8fCAxO1xuICAgIF90aGlzLmNvbHVtbkdhcCA9IG9wdGlvbnMuY29sdW1uR2FwICE9IG51bGwgPyBvcHRpb25zLmNvbHVtbkdhcCA6IDE4OyAvLyAxLzQgaW5jaFxuXG4gICAgX3RoaXMubGluZVdpZHRoID0gKG9wdGlvbnMud2lkdGggLSBfdGhpcy5jb2x1bW5HYXAgKiAoX3RoaXMuY29sdW1ucyAtIDEpKSAvIF90aGlzLmNvbHVtbnM7XG4gICAgX3RoaXMuc3BhY2VMZWZ0ID0gX3RoaXMubGluZVdpZHRoO1xuICAgIF90aGlzLnN0YXJ0WCA9IF90aGlzLmRvY3VtZW50Lng7XG4gICAgX3RoaXMuc3RhcnRZID0gX3RoaXMuZG9jdW1lbnQueTtcbiAgICBfdGhpcy5jb2x1bW4gPSAxO1xuICAgIF90aGlzLmVsbGlwc2lzID0gb3B0aW9ucy5lbGxpcHNpcztcbiAgICBfdGhpcy5jb250aW51ZWRYID0gMDtcbiAgICBfdGhpcy5mZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7IC8vIGNhbGN1bGF0ZSB0aGUgbWF4aW11bSBZIHBvc2l0aW9uIHRoZSB0ZXh0IGNhbiBhcHBlYXIgYXRcblxuICAgIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICBfdGhpcy5oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgIF90aGlzLm1heFkgPSBfdGhpcy5zdGFydFkgKyBvcHRpb25zLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXMubWF4WSA9IF90aGlzLmRvY3VtZW50LnBhZ2UubWF4WSgpO1xuICAgIH0gLy8gaGFuZGxlIHBhcmFncmFwaCBpbmRlbnRzXG5cblxuICAgIF90aGlzLm9uKCdmaXJzdExpbmUnLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3QgbGluZSBvZiB0aGUgdGV4dCBzZWdtZW50LCBhbmRcbiAgICAgIC8vIHdlJ3JlIGNvbnRpbnVpbmcgd2hlcmUgd2UgbGVmdCBvZmYsIGluZGVudCB0aGF0IG11Y2hcbiAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIHVzZXIgc3BlY2lmaWVkIGluZGVudCBvcHRpb25cbiAgICAgIHZhciBpbmRlbnQgPSBfdGhpcy5jb250aW51ZWRYIHx8IF90aGlzLmluZGVudDtcbiAgICAgIF90aGlzLmRvY3VtZW50LnggKz0gaW5kZW50O1xuICAgICAgX3RoaXMubGluZVdpZHRoIC09IGluZGVudDtcbiAgICAgIHJldHVybiBfdGhpcy5vbmNlKCdsaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kb2N1bWVudC54IC09IGluZGVudDtcbiAgICAgICAgX3RoaXMubGluZVdpZHRoICs9IGluZGVudDtcblxuICAgICAgICBpZiAob3B0aW9ucy5jb250aW51ZWQgJiYgIV90aGlzLmNvbnRpbnVlZFgpIHtcbiAgICAgICAgICBfdGhpcy5jb250aW51ZWRYID0gX3RoaXMuaW5kZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmNvbnRpbnVlZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jb250aW51ZWRYID0gMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7IC8vIGhhbmRsZSBsZWZ0IGFsaWduaW5nIGxhc3QgbGluZXMgb2YgcGFyYWdyYXBoc1xuXG5cbiAgICBfdGhpcy5vbignbGFzdExpbmUnLCBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgdmFyIGFsaWduID0gb3B0aW9ucy5hbGlnbjtcblxuICAgICAgaWYgKGFsaWduID09PSAnanVzdGlmeScpIHtcbiAgICAgICAgb3B0aW9ucy5hbGlnbiA9ICdsZWZ0JztcbiAgICAgIH1cblxuICAgICAgX3RoaXMubGFzdExpbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIF90aGlzLm9uY2UoJ2xpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRvY3VtZW50LnkgKz0gb3B0aW9ucy5wYXJhZ3JhcGhHYXAgfHwgMDtcbiAgICAgICAgb3B0aW9ucy5hbGlnbiA9IGFsaWduO1xuICAgICAgICByZXR1cm4gX3RoaXMubGFzdExpbmUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmVXcmFwcGVyLCBbe1xuICAgIGtleTogXCJ3b3JkV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd29yZFdpZHRoKHdvcmQpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LndpZHRoT2ZTdHJpbmcod29yZCwgdGhpcykgKyB0aGlzLmNoYXJhY3RlclNwYWNpbmcgKyB0aGlzLndvcmRTcGFjaW5nO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoV29yZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoV29yZCh0ZXh0LCBmbikge1xuICAgICAgLy8gc2V0dXAgYSB1bmljb2RlIGxpbmUgYnJlYWtlclxuICAgICAgdmFyIGJrO1xuICAgICAgdmFyIGJyZWFrZXIgPSBuZXcgTGluZUJyZWFrZXIodGV4dCk7XG4gICAgICB2YXIgbGFzdCA9IG51bGw7XG4gICAgICB2YXIgd29yZFdpZHRocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHdoaWxlIChiayA9IGJyZWFrZXIubmV4dEJyZWFrKCkpIHtcbiAgICAgICAgdmFyIHNob3VsZENvbnRpbnVlO1xuICAgICAgICB2YXIgd29yZCA9IHRleHQuc2xpY2UoKGxhc3QgIT0gbnVsbCA/IGxhc3QucG9zaXRpb24gOiB1bmRlZmluZWQpIHx8IDAsIGJrLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHcgPSB3b3JkV2lkdGhzW3dvcmRdICE9IG51bGwgPyB3b3JkV2lkdGhzW3dvcmRdIDogd29yZFdpZHRoc1t3b3JkXSA9IHRoaXMud29yZFdpZHRoKHdvcmQpOyAvLyBpZiB0aGUgd29yZCBpcyBsb25nZXIgdGhhbiB0aGUgd2hvbGUgbGluZSwgY2hvcCBpdCB1cFxuICAgICAgICAvLyBUT0RPOiBicmVhayBieSBncmFwaGVtZSBjbHVzdGVycywgbm90IEpTIHN0cmluZyBjaGFyYWN0ZXJzXG5cbiAgICAgICAgaWYgKHcgPiB0aGlzLmxpbmVXaWR0aCArIHRoaXMuY29udGludWVkWCkge1xuICAgICAgICAgIC8vIG1ha2Ugc29tZSBmYWtlIGJyZWFrIG9iamVjdHNcbiAgICAgICAgICB2YXIgbGJrID0gbGFzdDtcbiAgICAgICAgICB2YXIgZmJrID0ge307XG5cbiAgICAgICAgICB3aGlsZSAod29yZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGZpdCBhcyBtdWNoIG9mIHRoZSB3b3JkIGFzIHBvc3NpYmxlIGludG8gdGhlIHNwYWNlIHdlIGhhdmVcbiAgICAgICAgICAgIHZhciBsLCBtaWdodEdyb3c7XG5cbiAgICAgICAgICAgIGlmICh3ID4gdGhpcy5zcGFjZUxlZnQpIHtcbiAgICAgICAgICAgICAgLy8gc3RhcnQgb3VyIGNoZWNrIGF0IHRoZSBlbmQgb2Ygb3VyIGF2YWlsYWJsZSBzcGFjZSAtIHRoaXMgbWV0aG9kIGlzIGZhc3RlciB0aGFuIGEgbG9vcCBvZiBlYWNoIGNoYXJhY3RlciBhbmQgaXQgcmVzb2x2ZXNcbiAgICAgICAgICAgICAgLy8gYW4gaXNzdWUgd2l0aCBsb25nIGxvb3BzIHdoZW4gcHJvY2Vzc2luZyBtYXNzaXZlIHdvcmRzLCBzdWNoIGFzIGEgaHVnZSBudW1iZXIgb2Ygc3BhY2VzXG4gICAgICAgICAgICAgIGwgPSBNYXRoLmNlaWwodGhpcy5zcGFjZUxlZnQgLyAodyAvIHdvcmQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgIHcgPSB0aGlzLndvcmRXaWR0aCh3b3JkLnNsaWNlKDAsIGwpKTtcbiAgICAgICAgICAgICAgbWlnaHRHcm93ID0gdyA8PSB0aGlzLnNwYWNlTGVmdCAmJiBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsID0gd29yZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtdXN0U2hyaW5rID0gdyA+IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPiAwOyAvLyBzaHJpbmsgb3IgZ3JvdyB3b3JkIGFzIG5lY2Vzc2FyeSBhZnRlciBvdXIgbmVhci1ndWVzcyBhYm92ZVxuXG4gICAgICAgICAgICB3aGlsZSAobXVzdFNocmluayB8fCBtaWdodEdyb3cpIHtcbiAgICAgICAgICAgICAgaWYgKG11c3RTaHJpbmspIHtcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy53b3JkV2lkdGgod29yZC5zbGljZSgwLCAtLWwpKTtcbiAgICAgICAgICAgICAgICBtdXN0U2hyaW5rID0gdyA+IHRoaXMuc3BhY2VMZWZ0ICYmIGwgPiAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHcgPSB0aGlzLndvcmRXaWR0aCh3b3JkLnNsaWNlKDAsICsrbCkpO1xuICAgICAgICAgICAgICAgIG11c3RTaHJpbmsgPSB3ID4gdGhpcy5zcGFjZUxlZnQgJiYgbCA+IDA7XG4gICAgICAgICAgICAgICAgbWlnaHRHcm93ID0gdyA8PSB0aGlzLnNwYWNlTGVmdCAmJiBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gY2hlY2sgZm9yIHRoZSBlZGdlIGNhc2Ugd2hlcmUgYSBzaW5nbGUgY2hhcmFjdGVyIGNhbm5vdCBmaXQgaW50byBhIGxpbmUuXG5cblxuICAgICAgICAgICAgaWYgKGwgPT09IDAgJiYgdGhpcy5zcGFjZUxlZnQgPT09IHRoaXMubGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgIGwgPSAxO1xuICAgICAgICAgICAgfSAvLyBzZW5kIGEgcmVxdWlyZWQgYnJlYWsgdW5sZXNzIHRoaXMgaXMgdGhlIGxhc3QgcGllY2UgYW5kIGEgbGluZWJyZWFrIGlzIG5vdCBzcGVjaWZpZWRcblxuXG4gICAgICAgICAgICBmYmsucmVxdWlyZWQgPSBiay5yZXF1aXJlZCB8fCBsIDwgd29yZC5sZW5ndGg7XG4gICAgICAgICAgICBzaG91bGRDb250aW51ZSA9IGZuKHdvcmQuc2xpY2UoMCwgbCksIHcsIGZiaywgbGJrKTtcbiAgICAgICAgICAgIGxiayA9IHtcbiAgICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgICAgICAgICB9OyAvLyBnZXQgdGhlIHJlbWFpbmluZyBwaWVjZSBvZiB0aGUgd29yZFxuXG4gICAgICAgICAgICB3b3JkID0gd29yZC5zbGljZShsKTtcbiAgICAgICAgICAgIHcgPSB0aGlzLndvcmRXaWR0aCh3b3JkKTtcblxuICAgICAgICAgICAgaWYgKHNob3VsZENvbnRpbnVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgZW1pdCB0aGUgYnJlYWsgYXMgaXQgd2FzIGdpdmVuIHRvIHVzXG4gICAgICAgICAgc2hvdWxkQ29udGludWUgPSBmbih3b3JkLCB3LCBiaywgbGFzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkQ29udGludWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0ID0gYms7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd3JhcCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gb3ZlcnJpZGUgb3B0aW9ucyBmcm9tIHByZXZpb3VzIGNvbnRpbnVlZCBmcmFnbWVudHNcbiAgICAgIGlmIChvcHRpb25zLmluZGVudCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoYXJhY3RlclNwYWNpbmcgPSBvcHRpb25zLmNoYXJhY3RlclNwYWNpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLndvcmRTcGFjaW5nICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy53b3JkU3BhY2luZyA9IG9wdGlvbnMud29yZFNwYWNpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmVsbGlwc2lzICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbGxpcHNpcyA9IG9wdGlvbnMuZWxsaXBzaXM7XG4gICAgICB9IC8vIG1ha2Ugc3VyZSB3ZSdyZSBhY3R1YWxseSBvbiB0aGUgcGFnZVxuICAgICAgLy8gYW5kIHRoYXQgdGhlIGZpcnN0IGxpbmUgb2YgaXMgbmV2ZXIgYnlcbiAgICAgIC8vIGl0c2VsZiBhdCB0aGUgYm90dG9tIG9mIGEgcGFnZSAob3JwaGFucylcblxuXG4gICAgICB2YXIgbmV4dFkgPSB0aGlzLmRvY3VtZW50LnkgKyB0aGlzLmRvY3VtZW50LmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpO1xuXG4gICAgICBpZiAodGhpcy5kb2N1bWVudC55ID4gdGhpcy5tYXhZIHx8IG5leHRZID4gdGhpcy5tYXhZKSB7XG4gICAgICAgIHRoaXMubmV4dFNlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1ZmZlciA9ICcnO1xuICAgICAgdmFyIHRleHRXaWR0aCA9IDA7XG4gICAgICB2YXIgd2MgPSAwO1xuICAgICAgdmFyIGxjID0gMDtcbiAgICAgIHZhciB5ID0gdGhpcy5kb2N1bWVudC55OyAvLyB1c2VkIHRvIHJlc2V0IFkgcG9zIGlmIG9wdGlvbnMuY29udGludWVkIChiZWxvdylcblxuICAgICAgdmFyIGVtaXRMaW5lID0gZnVuY3Rpb24gZW1pdExpbmUoKSB7XG4gICAgICAgIG9wdGlvbnMudGV4dFdpZHRoID0gdGV4dFdpZHRoICsgX3RoaXMyLndvcmRTcGFjaW5nICogKHdjIC0gMSk7XG4gICAgICAgIG9wdGlvbnMud29yZENvdW50ID0gd2M7XG4gICAgICAgIG9wdGlvbnMubGluZVdpZHRoID0gX3RoaXMyLmxpbmVXaWR0aDtcbiAgICAgICAgeSA9IF90aGlzMi5kb2N1bWVudC55O1xuXG4gICAgICAgIF90aGlzMi5lbWl0KCdsaW5lJywgYnVmZmVyLCBvcHRpb25zLCBfdGhpczIpO1xuXG4gICAgICAgIHJldHVybiBsYysrO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5lbWl0KCdzZWN0aW9uU3RhcnQnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIHRoaXMuZWFjaFdvcmQodGV4dCwgZnVuY3Rpb24gKHdvcmQsIHcsIGJrLCBsYXN0KSB7XG4gICAgICAgIGlmIChsYXN0ID09IG51bGwgfHwgbGFzdC5yZXF1aXJlZCkge1xuICAgICAgICAgIF90aGlzMi5lbWl0KCdmaXJzdExpbmUnLCBvcHRpb25zLCBfdGhpczIpO1xuXG4gICAgICAgICAgX3RoaXMyLnNwYWNlTGVmdCA9IF90aGlzMi5saW5lV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodyA8PSBfdGhpczIuc3BhY2VMZWZ0KSB7XG4gICAgICAgICAgYnVmZmVyICs9IHdvcmQ7XG4gICAgICAgICAgdGV4dFdpZHRoICs9IHc7XG4gICAgICAgICAgd2MrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiay5yZXF1aXJlZCB8fCB3ID4gX3RoaXMyLnNwYWNlTGVmdCkge1xuICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIHNwZWNpZmllZCBhIG1heCBoZWlnaHQgYW5kIGFuIGVsbGlwc2lzLCBhbmQgaXMgYWJvdXQgdG8gcGFzcyB0aGVcbiAgICAgICAgICAvLyBtYXggaGVpZ2h0IGFuZCBtYXggY29sdW1ucyBhZnRlciB0aGUgbmV4dCBsaW5lLCBhcHBlbmQgdGhlIGVsbGlwc2lzXG4gICAgICAgICAgdmFyIGxoID0gX3RoaXMyLmRvY3VtZW50LmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpO1xuXG4gICAgICAgICAgaWYgKF90aGlzMi5oZWlnaHQgIT0gbnVsbCAmJiBfdGhpczIuZWxsaXBzaXMgJiYgX3RoaXMyLmRvY3VtZW50LnkgKyBsaCAqIDIgPiBfdGhpczIubWF4WSAmJiBfdGhpczIuY29sdW1uID49IF90aGlzMi5jb2x1bW5zKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMyLmVsbGlwc2lzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5lbGxpcHNpcyA9ICfigKYnO1xuICAgICAgICAgICAgfSAvLyBtYXAgZGVmYXVsdCBlbGxpcHNpcyBjaGFyYWN0ZXJcblxuXG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXIucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgICAgICB0ZXh0V2lkdGggPSBfdGhpczIud29yZFdpZHRoKGJ1ZmZlciArIF90aGlzMi5lbGxpcHNpcyk7IC8vIHJlbW92ZSBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlciB1bnRpbCB0aGUgZWxsaXBzaXMgZml0c1xuICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcCBuZWVkIHRvIHN0b3Agd2hpbGUtbG9vcCBpZiBidWZmZXIgaXMgZW1wdHkgc3RyaW5nXG5cbiAgICAgICAgICAgIHdoaWxlIChidWZmZXIgJiYgdGV4dFdpZHRoID4gX3RoaXMyLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgLTEpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBfdGhpczIud29yZFdpZHRoKGJ1ZmZlciArIF90aGlzMi5lbGxpcHNpcyk7XG4gICAgICAgICAgICB9IC8vIG5lZWQgdG8gYWRkIGVsbGlwc2lzIG9ubHkgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIGZvciBpdFxuXG5cbiAgICAgICAgICAgIGlmICh0ZXh0V2lkdGggPD0gX3RoaXMyLmxpbmVXaWR0aCkge1xuICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIgKyBfdGhpczIuZWxsaXBzaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRleHRXaWR0aCA9IF90aGlzMi53b3JkV2lkdGgoYnVmZmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmsucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIGlmICh3ID4gX3RoaXMyLnNwYWNlTGVmdCkge1xuICAgICAgICAgICAgICBlbWl0TGluZSgpO1xuICAgICAgICAgICAgICBidWZmZXIgPSB3b3JkO1xuICAgICAgICAgICAgICB0ZXh0V2lkdGggPSB3O1xuICAgICAgICAgICAgICB3YyA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzMi5lbWl0KCdsYXN0TGluZScsIG9wdGlvbnMsIF90aGlzMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW1pdExpbmUoKTsgLy8gaWYgd2UndmUgcmVhY2hlZCB0aGUgZWRnZSBvZiB0aGUgcGFnZSxcbiAgICAgICAgICAvLyBjb250aW51ZSBvbiBhIG5ldyBwYWdlIG9yIGNvbHVtblxuXG4gICAgICAgICAgaWYgKF90aGlzMi5kb2N1bWVudC55ICsgbGggPiBfdGhpczIubWF4WSkge1xuICAgICAgICAgICAgdmFyIHNob3VsZENvbnRpbnVlID0gX3RoaXMyLm5leHRTZWN0aW9uKCk7IC8vIHN0b3AgaWYgd2UgcmVhY2hlZCB0aGUgbWF4aW11bSBoZWlnaHRcblxuXG4gICAgICAgICAgICBpZiAoIXNob3VsZENvbnRpbnVlKSB7XG4gICAgICAgICAgICAgIHdjID0gMDtcbiAgICAgICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIHJlc2V0IHRoZSBzcGFjZSBsZWZ0IGFuZCBidWZmZXJcblxuXG4gICAgICAgICAgaWYgKGJrLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICBfdGhpczIuc3BhY2VMZWZ0ID0gX3RoaXMyLmxpbmVXaWR0aDtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgdGV4dFdpZHRoID0gMDtcbiAgICAgICAgICAgIHJldHVybiB3YyA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBzcGFjZSBsZWZ0IGFuZCBidWZmZXJcbiAgICAgICAgICAgIF90aGlzMi5zcGFjZUxlZnQgPSBfdGhpczIubGluZVdpZHRoIC0gdztcbiAgICAgICAgICAgIGJ1ZmZlciA9IHdvcmQ7XG4gICAgICAgICAgICB0ZXh0V2lkdGggPSB3O1xuICAgICAgICAgICAgcmV0dXJuIHdjID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5zcGFjZUxlZnQgLT0gdztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh3YyA+IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsYXN0TGluZScsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICBlbWl0TGluZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXQoJ3NlY3Rpb25FbmQnLCBvcHRpb25zLCB0aGlzKTsgLy8gaWYgdGhlIHdyYXAgaXMgc2V0IHRvIGJlIGNvbnRpbnVlZCwgc2F2ZSB0aGUgWCBwb3NpdGlvblxuICAgICAgLy8gdG8gc3RhcnQgdGhlIGZpcnN0IGxpbmUgb2YgdGhlIG5leHQgc2VnbWVudCBhdCwgYW5kIHJlc2V0XG4gICAgICAvLyB0aGUgeSBwb3NpdGlvblxuXG4gICAgICBpZiAob3B0aW9ucy5jb250aW51ZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKGxjID4gMSkge1xuICAgICAgICAgIHRoaXMuY29udGludWVkWCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbnRpbnVlZFggKz0gb3B0aW9ucy50ZXh0V2lkdGggfHwgMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQueSA9IHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC54ID0gdGhpcy5zdGFydFg7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRTZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5leHRTZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZW1pdCgnc2VjdGlvbkVuZCcsIG9wdGlvbnMsIHRoaXMpO1xuXG4gICAgICBpZiAoKyt0aGlzLmNvbHVtbiA+IHRoaXMuY29sdW1ucykge1xuICAgICAgICAvLyBpZiBhIG1heCBoZWlnaHQgd2FzIHNwZWNpZmllZCBieSB0aGUgdXNlciwgd2UncmUgZG9uZS5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCB0aGUgZGVmYXVsdCBpcyB0byBtYWtlIGEgbmV3IHBhZ2UgYXQgdGhlIGJvdHRvbS5cbiAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRvY3VtZW50LmNvbnRpbnVlT25OZXdQYWdlKCk7XG4gICAgICAgIHRoaXMuY29sdW1uID0gMTtcbiAgICAgICAgdGhpcy5zdGFydFkgPSB0aGlzLmRvY3VtZW50LnBhZ2UubWFyZ2lucy50b3A7XG4gICAgICAgIHRoaXMubWF4WSA9IHRoaXMuZG9jdW1lbnQucGFnZS5tYXhZKCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQueCA9IHRoaXMuc3RhcnRYO1xuXG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50Ll9maWxsQ29sb3IpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkZG9jdW1lbnQ7XG5cbiAgICAgICAgICAoX3RoaXMkZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50KS5maWxsQ29sb3IuYXBwbHkoX3RoaXMkZG9jdW1lbnQsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmRvY3VtZW50Ll9maWxsQ29sb3IpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgncGFnZUJyZWFrJywgb3B0aW9ucywgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvY3VtZW50LnggKz0gdGhpcy5saW5lV2lkdGggKyB0aGlzLmNvbHVtbkdhcDtcbiAgICAgICAgdGhpcy5kb2N1bWVudC55ID0gdGhpcy5zdGFydFk7XG4gICAgICAgIHRoaXMuZW1pdCgnY29sdW1uQnJlYWsnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbWl0KCdzZWN0aW9uU3RhcnQnLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5lV3JhcHBlcjtcbn0oRXZlbnRFbWl0dGVyKTtcblxudmFyIG51bWJlciQyID0gUERGT2JqZWN0Lm51bWJlcjtcbnZhciBUZXh0TWl4aW4gPSB7XG4gIGluaXRUZXh0OiBmdW5jdGlvbiBpbml0VGV4dCgpIHtcbiAgICB0aGlzLl9saW5lID0gdGhpcy5fbGluZS5iaW5kKHRoaXMpOyAvLyBDdXJyZW50IGNvb3JkaW5hdGVzXG5cbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX2xpbmVHYXAgPSAwO1xuICB9LFxuICBsaW5lR2FwOiBmdW5jdGlvbiBsaW5lR2FwKF9saW5lR2FwKSB7XG4gICAgdGhpcy5fbGluZUdhcCA9IF9saW5lR2FwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtb3ZlRG93bjogZnVuY3Rpb24gbW92ZURvd24obGluZXMpIHtcbiAgICBpZiAobGluZXMgPT0gbnVsbCkge1xuICAgICAgbGluZXMgPSAxO1xuICAgIH1cblxuICAgIHRoaXMueSArPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICogbGluZXMgKyB0aGlzLl9saW5lR2FwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtb3ZlVXA6IGZ1bmN0aW9uIG1vdmVVcChsaW5lcykge1xuICAgIGlmIChsaW5lcyA9PSBudWxsKSB7XG4gICAgICBsaW5lcyA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy55IC09IHRoaXMuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKiBsaW5lcyArIHRoaXMuX2xpbmVHYXA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF90ZXh0OiBmdW5jdGlvbiBfdGV4dCh0ZXh0LCB4LCB5LCBvcHRpb25zLCBsaW5lQ2FsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IHRoaXMuX2luaXRPcHRpb25zKHgsIHksIG9wdGlvbnMpOyAvLyBDb252ZXJ0IHRleHQgdG8gYSBzdHJpbmdcblxuICAgIHRleHQgPSB0ZXh0ID09IG51bGwgPyAnJyA6IFwiXCIuY29uY2F0KHRleHQpOyAvLyBpZiB0aGUgd29yZFNwYWNpbmcgb3B0aW9uIGlzIHNwZWNpZmllZCwgcmVtb3ZlIG11bHRpcGxlIGNvbnNlY3V0aXZlIHNwYWNlc1xuXG4gICAgaWYgKG9wdGlvbnMud29yZFNwYWNpbmcpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbiAgICB9XG5cbiAgICB2YXIgYWRkU3RydWN0dXJlID0gZnVuY3Rpb24gYWRkU3RydWN0dXJlKCkge1xuICAgICAgaWYgKG9wdGlvbnMuc3RydWN0UGFyZW50KSB7XG4gICAgICAgIG9wdGlvbnMuc3RydWN0UGFyZW50LmFkZChfdGhpcy5zdHJ1Y3Qob3B0aW9ucy5zdHJ1Y3RUeXBlIHx8ICdQJywgW190aGlzLm1hcmtTdHJ1Y3R1cmVDb250ZW50KG9wdGlvbnMuc3RydWN0VHlwZSB8fCAnUCcpXSkpO1xuICAgICAgfVxuICAgIH07IC8vIHdvcmQgd3JhcHBpbmdcblxuXG4gICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlcjtcblxuICAgICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICAgIHdyYXBwZXIgPSBuZXcgTGluZVdyYXBwZXIodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHdyYXBwZXIub24oJ2xpbmUnLCBsaW5lQ2FsbGJhY2spO1xuICAgICAgICB3cmFwcGVyLm9uKCdmaXJzdExpbmUnLCBhZGRTdHJ1Y3R1cmUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cmFwcGVyID0gb3B0aW9ucy5jb250aW51ZWQgPyB3cmFwcGVyIDogbnVsbDtcbiAgICAgIHRoaXMuX3RleHRPcHRpb25zID0gb3B0aW9ucy5jb250aW51ZWQgPyBvcHRpb25zIDogbnVsbDtcbiAgICAgIHdyYXBwZXIud3JhcCh0ZXh0LCBvcHRpb25zKTsgLy8gcmVuZGVyIHBhcmFncmFwaHMgYXMgc2luZ2xlIGxpbmVzXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0ZXh0LnNwbGl0KCdcXG4nKSksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxpbmUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBhZGRTdHJ1Y3R1cmUoKTtcbiAgICAgICAgICBsaW5lQ2FsbGJhY2sobGluZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdGV4dDogZnVuY3Rpb24gdGV4dChfdGV4dDIsIHgsIHksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dChfdGV4dDIsIHgsIHksIG9wdGlvbnMsIHRoaXMuX2xpbmUpO1xuICB9LFxuICB3aWR0aE9mU3RyaW5nOiBmdW5jdGlvbiB3aWR0aE9mU3RyaW5nKHN0cmluZykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5fZm9udC53aWR0aE9mU3RyaW5nKHN0cmluZywgdGhpcy5fZm9udFNpemUsIG9wdGlvbnMuZmVhdHVyZXMpICsgKG9wdGlvbnMuY2hhcmFjdGVyU3BhY2luZyB8fCAwKSAqIChzdHJpbmcubGVuZ3RoIC0gMSk7XG4gIH0sXG4gIGhlaWdodE9mU3RyaW5nOiBmdW5jdGlvbiBoZWlnaHRPZlN0cmluZyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgeCA9IHRoaXMueCxcbiAgICAgICAgeSA9IHRoaXMueTtcbiAgICBvcHRpb25zID0gdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5oZWlnaHQgPSBJbmZpbml0eTsgLy8gZG9uJ3QgYnJlYWsgcGFnZXNcblxuICAgIHZhciBsaW5lR2FwID0gb3B0aW9ucy5saW5lR2FwIHx8IHRoaXMuX2xpbmVHYXAgfHwgMDtcblxuICAgIHRoaXMuX3RleHQodGV4dCwgdGhpcy54LCB0aGlzLnksIG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpczIueSArPSBfdGhpczIuY3VycmVudExpbmVIZWlnaHQodHJ1ZSkgKyBsaW5lR2FwO1xuICAgIH0pO1xuXG4gICAgdmFyIGhlaWdodCA9IHRoaXMueSAtIHk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiBoZWlnaHQ7XG4gIH0sXG4gIGxpc3Q6IGZ1bmN0aW9uIGxpc3QoX2xpc3QsIHgsIHksIG9wdGlvbnMsIHdyYXBwZXIpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSB0aGlzLl9pbml0T3B0aW9ucyh4LCB5LCBvcHRpb25zKTtcbiAgICB2YXIgbGlzdFR5cGUgPSBvcHRpb25zLmxpc3RUeXBlIHx8ICdidWxsZXQnO1xuICAgIHZhciB1bml0ID0gTWF0aC5yb3VuZCh0aGlzLl9mb250LmFzY2VuZGVyIC8gMTAwMCAqIHRoaXMuX2ZvbnRTaXplKTtcbiAgICB2YXIgbWlkTGluZSA9IHVuaXQgLyAyO1xuICAgIHZhciByID0gb3B0aW9ucy5idWxsZXRSYWRpdXMgfHwgdW5pdCAvIDM7XG4gICAgdmFyIGluZGVudCA9IG9wdGlvbnMudGV4dEluZGVudCB8fCAobGlzdFR5cGUgPT09ICdidWxsZXQnID8gciAqIDUgOiB1bml0ICogMik7XG4gICAgdmFyIGl0ZW1JbmRlbnQgPSBvcHRpb25zLmJ1bGxldEluZGVudCB8fCAobGlzdFR5cGUgPT09ICdidWxsZXQnID8gciAqIDggOiB1bml0ICogMik7XG4gICAgdmFyIGxldmVsID0gMTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIG51bWJlcnMgPSBbXTtcblxuICAgIHZhciBmbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbihsaXN0KSB7XG4gICAgICB2YXIgbiA9IDE7XG5cbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsaXN0Lmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGxpc3RbX2ldO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBmbGF0dGVuKGl0ZW0pO1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICBsZXZlbHMucHVzaChsZXZlbCk7XG5cbiAgICAgICAgICBpZiAobGlzdFR5cGUgIT09ICdidWxsZXQnKSB7XG4gICAgICAgICAgICBudW1iZXJzLnB1c2gobisrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZmxhdHRlbihfbGlzdCk7XG5cbiAgICB2YXIgbGFiZWwgPSBmdW5jdGlvbiBsYWJlbChuKSB7XG4gICAgICBzd2l0Y2ggKGxpc3RUeXBlKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcmVkJzpcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQobiwgXCIuXCIpO1xuXG4gICAgICAgIGNhc2UgJ2xldHRlcmVkJzpcbiAgICAgICAgICB2YXIgbGV0dGVyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgobiAtIDEpICUgMjYgKyA2NSk7XG4gICAgICAgICAgdmFyIHRpbWVzID0gTWF0aC5mbG9vcigobiAtIDEpIC8gMjYgKyAxKTtcbiAgICAgICAgICB2YXIgdGV4dCA9IEFycmF5KHRpbWVzICsgMSkuam9pbihsZXR0ZXIpO1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0ZXh0LCBcIi5cIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdyYXBwZXIgPSBuZXcgTGluZVdyYXBwZXIodGhpcywgb3B0aW9ucyk7XG4gICAgd3JhcHBlci5vbignbGluZScsIHRoaXMuX2xpbmUpO1xuICAgIGxldmVsID0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd3JhcHBlci5vbignZmlyc3RMaW5lJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGl0ZW0sIGl0ZW1UeXBlLCBsYWJlbFR5cGUsIGJvZHlUeXBlO1xuXG4gICAgICBpZiAob3B0aW9ucy5zdHJ1Y3RQYXJlbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RydWN0VHlwZXMpIHtcbiAgICAgICAgICB2YXIgX29wdGlvbnMkc3RydWN0VHlwZXMgPSBfc2xpY2VkVG9BcnJheShvcHRpb25zLnN0cnVjdFR5cGVzLCAzKTtcblxuICAgICAgICAgIGl0ZW1UeXBlID0gX29wdGlvbnMkc3RydWN0VHlwZXNbMF07XG4gICAgICAgICAgbGFiZWxUeXBlID0gX29wdGlvbnMkc3RydWN0VHlwZXNbMV07XG4gICAgICAgICAgYm9keVR5cGUgPSBfb3B0aW9ucyRzdHJ1Y3RUeXBlc1syXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtVHlwZSA9ICdMSSc7XG4gICAgICAgICAgbGFiZWxUeXBlID0gJ0xibCc7XG4gICAgICAgICAgYm9keVR5cGUgPSAnTEJvZHknO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtVHlwZSkge1xuICAgICAgICBpdGVtID0gX3RoaXMzLnN0cnVjdChpdGVtVHlwZSk7XG4gICAgICAgIG9wdGlvbnMuc3RydWN0UGFyZW50LmFkZChpdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zdHJ1Y3RQYXJlbnQpIHtcbiAgICAgICAgaXRlbSA9IG9wdGlvbnMuc3RydWN0UGFyZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgbDtcblxuICAgICAgaWYgKChsID0gbGV2ZWxzW2krK10pICE9PSBsZXZlbCkge1xuICAgICAgICB2YXIgZGlmZiA9IGl0ZW1JbmRlbnQgKiAobCAtIGxldmVsKTtcbiAgICAgICAgX3RoaXMzLnggKz0gZGlmZjtcbiAgICAgICAgd3JhcHBlci5saW5lV2lkdGggLT0gZGlmZjtcbiAgICAgICAgbGV2ZWwgPSBsO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbSAmJiAobGFiZWxUeXBlIHx8IGJvZHlUeXBlKSkge1xuICAgICAgICBpdGVtLmFkZChfdGhpczMuc3RydWN0KGxhYmVsVHlwZSB8fCBib2R5VHlwZSwgW190aGlzMy5tYXJrU3RydWN0dXJlQ29udGVudChsYWJlbFR5cGUgfHwgYm9keVR5cGUpXSkpO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGxpc3RUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2J1bGxldCc6XG4gICAgICAgICAgX3RoaXMzLmNpcmNsZShfdGhpczMueCAtIGluZGVudCArIHIsIF90aGlzMy55ICsgbWlkTGluZSwgcik7XG5cbiAgICAgICAgICBfdGhpczMuZmlsbCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbnVtYmVyZWQnOlxuICAgICAgICBjYXNlICdsZXR0ZXJlZCc6XG4gICAgICAgICAgdmFyIHRleHQgPSBsYWJlbChudW1iZXJzW2kgLSAxXSk7XG5cbiAgICAgICAgICBfdGhpczMuX2ZyYWdtZW50KHRleHQsIF90aGlzMy54IC0gaW5kZW50LCBfdGhpczMueSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0gJiYgbGFiZWxUeXBlICYmIGJvZHlUeXBlKSB7XG4gICAgICAgIGl0ZW0uYWRkKF90aGlzMy5zdHJ1Y3QoYm9keVR5cGUsIFtfdGhpczMubWFya1N0cnVjdHVyZUNvbnRlbnQoYm9keVR5cGUpXSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbSAmJiBpdGVtICE9PSBvcHRpb25zLnN0cnVjdFBhcmVudCkge1xuICAgICAgICBpdGVtLmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdyYXBwZXIub24oJ3NlY3Rpb25TdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwb3MgPSBpbmRlbnQgKyBpdGVtSW5kZW50ICogKGxldmVsIC0gMSk7XG4gICAgICBfdGhpczMueCArPSBwb3M7XG4gICAgICByZXR1cm4gd3JhcHBlci5saW5lV2lkdGggLT0gcG9zO1xuICAgIH0pO1xuICAgIHdyYXBwZXIub24oJ3NlY3Rpb25FbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcG9zID0gaW5kZW50ICsgaXRlbUluZGVudCAqIChsZXZlbCAtIDEpO1xuICAgICAgX3RoaXMzLnggLT0gcG9zO1xuICAgICAgcmV0dXJuIHdyYXBwZXIubGluZVdpZHRoICs9IHBvcztcbiAgICB9KTtcbiAgICB3cmFwcGVyLndyYXAoaXRlbXMuam9pbignXFxuJyksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBfaW5pdE9wdGlvbnM6IGZ1bmN0aW9uIF9pbml0T3B0aW9ucygpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0geDtcbiAgICAgIHggPSBudWxsO1xuICAgIH0gLy8gY2xvbmUgb3B0aW9ucyBvYmplY3RcblxuXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpOyAvLyBleHRlbmQgb3B0aW9ucyB3aXRoIHByZXZpb3VzIHZhbHVlcyBmb3IgY29udGludWVkIHRleHRcblxuICAgIGlmICh0aGlzLl90ZXh0T3B0aW9ucykge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX3RleHRPcHRpb25zKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLl90ZXh0T3B0aW9uc1trZXldO1xuXG4gICAgICAgIGlmIChrZXkgIT09ICdjb250aW51ZWQnKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVXBkYXRlIHRoZSBjdXJyZW50IHBvc2l0aW9uXG5cblxuICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgfVxuXG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgdGhpcy55ID0geTtcbiAgICB9IC8vIHdyYXAgdG8gbWFyZ2lucyBpZiBubyB4IG9yIHkgcG9zaXRpb24gcGFzc2VkXG5cblxuICAgIGlmIChyZXN1bHQubGluZUJyZWFrICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHJlc3VsdC53aWR0aCA9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC53aWR0aCA9IHRoaXMucGFnZS53aWR0aCAtIHRoaXMueCAtIHRoaXMucGFnZS5tYXJnaW5zLnJpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXN1bHQud2lkdGggPSBNYXRoLm1heChyZXN1bHQud2lkdGgsIDApO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0LmNvbHVtbnMpIHtcbiAgICAgIHJlc3VsdC5jb2x1bW5zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmNvbHVtbkdhcCA9PSBudWxsKSB7XG4gICAgICByZXN1bHQuY29sdW1uR2FwID0gMTg7XG4gICAgfSAvLyAxLzQgaW5jaFxuXG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBfbGluZTogZnVuY3Rpb24gX2xpbmUodGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgd3JhcHBlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fZnJhZ21lbnQodGV4dCwgdGhpcy54LCB0aGlzLnksIG9wdGlvbnMpO1xuXG4gICAgdmFyIGxpbmVHYXAgPSBvcHRpb25zLmxpbmVHYXAgfHwgdGhpcy5fbGluZUdhcCB8fCAwO1xuXG4gICAgaWYgKCF3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICs9IHRoaXMud2lkdGhPZlN0cmluZyh0ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMueSArPSB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KHRydWUpICsgbGluZUdhcDtcbiAgICB9XG4gIH0sXG4gIF9mcmFnbWVudDogZnVuY3Rpb24gX2ZyYWdtZW50KHRleHQsIHgsIHksIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIHZhciBkeSwgZW5jb2RlZCwgaSwgcG9zaXRpb25zLCB0ZXh0V2lkdGgsIHdvcmRzO1xuICAgIHRleHQgPSBcIlwiLmNvbmNhdCh0ZXh0KS5yZXBsYWNlKC9cXG4vZywgJycpO1xuXG4gICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBoYW5kbGUgb3B0aW9uc1xuXG5cbiAgICB2YXIgYWxpZ24gPSBvcHRpb25zLmFsaWduIHx8ICdsZWZ0JztcbiAgICB2YXIgd29yZFNwYWNpbmcgPSBvcHRpb25zLndvcmRTcGFjaW5nIHx8IDA7XG4gICAgdmFyIGNoYXJhY3RlclNwYWNpbmcgPSBvcHRpb25zLmNoYXJhY3RlclNwYWNpbmcgfHwgMDsgLy8gdGV4dCBhbGlnbm1lbnRzXG5cbiAgICBpZiAob3B0aW9ucy53aWR0aCkge1xuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgdGV4dFdpZHRoID0gdGhpcy53aWR0aE9mU3RyaW5nKHRleHQucmVwbGFjZSgvXFxzKyQvLCAnJyksIG9wdGlvbnMpO1xuICAgICAgICAgIHggKz0gb3B0aW9ucy5saW5lV2lkdGggLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICB4ICs9IG9wdGlvbnMubGluZVdpZHRoIC8gMiAtIG9wdGlvbnMudGV4dFdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdqdXN0aWZ5JzpcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdvcmQgc3BhY2luZyB2YWx1ZVxuICAgICAgICAgIHdvcmRzID0gdGV4dC50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICB0ZXh0V2lkdGggPSB0aGlzLndpZHRoT2ZTdHJpbmcodGV4dC5yZXBsYWNlKC9cXHMrL2csICcnKSwgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIHNwYWNlV2lkdGggPSB0aGlzLndpZHRoT2ZTdHJpbmcoJyAnKSArIGNoYXJhY3RlclNwYWNpbmc7XG4gICAgICAgICAgd29yZFNwYWNpbmcgPSBNYXRoLm1heCgwLCAob3B0aW9ucy5saW5lV2lkdGggLSB0ZXh0V2lkdGgpIC8gTWF0aC5tYXgoMSwgd29yZHMubGVuZ3RoIC0gMSkgLSBzcGFjZVdpZHRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IC8vIHRleHQgYmFzZWxpbmUgYWxpZ25tZW50cyBiYXNlZCBvbiBodHRwOi8vd2lraS5hcGFjaGUub3JnL3htbGdyYXBoaWNzLWZvcC9MaW5lTGF5b3V0L0FsaWdubWVudEhhbmRsaW5nXG5cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5iYXNlbGluZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGR5ID0gLW9wdGlvbnMuYmFzZWxpbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5iYXNlbGluZSkge1xuICAgICAgICBjYXNlICdzdmctbWlkZGxlJzpcbiAgICAgICAgICBkeSA9IDAuNSAqIHRoaXMuX2ZvbnQueEhlaWdodDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtaWRkbGUnOlxuICAgICAgICBjYXNlICdzdmctY2VudHJhbCc6XG4gICAgICAgICAgZHkgPSAwLjUgKiAodGhpcy5fZm9udC5kZXNjZW5kZXIgKyB0aGlzLl9mb250LmFzY2VuZGVyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjYXNlICdpZGVvZ3JhcGhpYyc6XG4gICAgICAgICAgZHkgPSB0aGlzLl9mb250LmRlc2NlbmRlcjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhbHBoYWJldGljJzpcbiAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbWF0aGVtYXRpY2FsJzpcbiAgICAgICAgICBkeSA9IDAuNSAqIHRoaXMuX2ZvbnQuYXNjZW5kZXI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaGFuZ2luZyc6XG4gICAgICAgICAgZHkgPSAwLjggKiB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgZHkgPSB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZHkgPSB0aGlzLl9mb250LmFzY2VuZGVyO1xuICAgICAgfVxuXG4gICAgICBkeSA9IGR5IC8gMTAwMCAqIHRoaXMuX2ZvbnRTaXplO1xuICAgIH0gLy8gY2FsY3VsYXRlIHRoZSBhY3R1YWwgcmVuZGVyZWQgd2lkdGggb2YgdGhlIHN0cmluZyBhZnRlciB3b3JkIGFuZCBjaGFyYWN0ZXIgc3BhY2luZ1xuXG5cbiAgICB2YXIgcmVuZGVyZWRXaWR0aCA9IG9wdGlvbnMudGV4dFdpZHRoICsgd29yZFNwYWNpbmcgKiAob3B0aW9ucy53b3JkQ291bnQgLSAxKSArIGNoYXJhY3RlclNwYWNpbmcgKiAodGV4dC5sZW5ndGggLSAxKTsgLy8gY3JlYXRlIGxpbmsgYW5ub3RhdGlvbnMgaWYgdGhlIGxpbmsgb3B0aW9uIGlzIGdpdmVuXG5cbiAgICBpZiAob3B0aW9ucy5saW5rICE9IG51bGwpIHtcbiAgICAgIHRoaXMubGluayh4LCB5LCByZW5kZXJlZFdpZHRoLCB0aGlzLmN1cnJlbnRMaW5lSGVpZ2h0KCksIG9wdGlvbnMubGluayk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZ29UbyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmdvVG8oeCwgeSwgcmVuZGVyZWRXaWR0aCwgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpLCBvcHRpb25zLmdvVG8pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRlc3RpbmF0aW9uICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYWRkTmFtZWREZXN0aW5hdGlvbihvcHRpb25zLmRlc3RpbmF0aW9uLCAnWFlaJywgeCwgeSwgbnVsbCk7XG4gICAgfSAvLyBjcmVhdGUgdW5kZXJsaW5lXG5cblxuICAgIGlmIChvcHRpb25zLnVuZGVybGluZSkge1xuICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5zdHJva2UpIHtcbiAgICAgICAgdGhpcy5zdHJva2VDb2xvci5hcHBseSh0aGlzLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5fZmlsbENvbG9yIHx8IFtdKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lV2lkdGggPSB0aGlzLl9mb250U2l6ZSA8IDEwID8gMC41IDogTWF0aC5mbG9vcih0aGlzLl9mb250U2l6ZSAvIDEwKTtcbiAgICAgIHRoaXMubGluZVdpZHRoKGxpbmVXaWR0aCk7XG4gICAgICB2YXIgbGluZVkgPSB5ICsgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpIC0gbGluZVdpZHRoO1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgbGluZVkpO1xuICAgICAgdGhpcy5saW5lVG8oeCArIHJlbmRlcmVkV2lkdGgsIGxpbmVZKTtcbiAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9IC8vIGNyZWF0ZSBzdHJpa2V0aHJvdWdoIGxpbmVcblxuXG4gICAgaWYgKG9wdGlvbnMuc3RyaWtlKSB7XG4gICAgICB0aGlzLnNhdmUoKTtcblxuICAgICAgaWYgKCFvcHRpb25zLnN0cm9rZSkge1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yLmFwcGx5KHRoaXMsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLl9maWxsQ29sb3IgfHwgW10pKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9saW5lV2lkdGggPSB0aGlzLl9mb250U2l6ZSA8IDEwID8gMC41IDogTWF0aC5mbG9vcih0aGlzLl9mb250U2l6ZSAvIDEwKTtcblxuICAgICAgdGhpcy5saW5lV2lkdGgoX2xpbmVXaWR0aCk7XG5cbiAgICAgIHZhciBfbGluZVkgPSB5ICsgdGhpcy5jdXJyZW50TGluZUhlaWdodCgpIC8gMjtcblxuICAgICAgdGhpcy5tb3ZlVG8oeCwgX2xpbmVZKTtcbiAgICAgIHRoaXMubGluZVRvKHggKyByZW5kZXJlZFdpZHRoLCBfbGluZVkpO1xuICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMuc2F2ZSgpOyAvLyBvYmxpcXVlIChhbmdsZSBpbiBkZWdyZWVzIG9yIGJvb2xlYW4pXG5cbiAgICBpZiAob3B0aW9ucy5vYmxpcXVlKSB7XG4gICAgICB2YXIgc2tldztcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9ibGlxdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNrZXcgPSAtTWF0aC50YW4ob3B0aW9ucy5vYmxpcXVlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBza2V3ID0gLTAuMjU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhbnNmb3JtKDEsIDAsIDAsIDEsIHgsIHkpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oMSwgMCwgc2tldywgMSwgLXNrZXcgKiBkeSwgMCk7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCAteCwgLXkpO1xuICAgIH0gLy8gZmxpcCBjb29yZGluYXRlIHN5c3RlbVxuXG5cbiAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgdGhpcy5wYWdlLmhlaWdodCk7XG4gICAgeSA9IHRoaXMucGFnZS5oZWlnaHQgLSB5IC0gZHk7IC8vIGFkZCBjdXJyZW50IGZvbnQgdG8gcGFnZSBpZiBuZWNlc3NhcnlcblxuICAgIGlmICh0aGlzLnBhZ2UuZm9udHNbdGhpcy5fZm9udC5pZF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlLmZvbnRzW3RoaXMuX2ZvbnQuaWRdID0gdGhpcy5fZm9udC5yZWYoKTtcbiAgICB9IC8vIGJlZ2luIHRoZSB0ZXh0IG9iamVjdFxuXG5cbiAgICB0aGlzLmFkZENvbnRlbnQoJ0JUJyk7IC8vIHRleHQgcG9zaXRpb25cblxuICAgIHRoaXMuYWRkQ29udGVudChcIjEgMCAwIDEgXCIuY29uY2F0KG51bWJlciQyKHgpLCBcIiBcIikuY29uY2F0KG51bWJlciQyKHkpLCBcIiBUbVwiKSk7IC8vIGZvbnQgYW5kIGZvbnQgc2l6ZVxuXG4gICAgdGhpcy5hZGRDb250ZW50KFwiL1wiLmNvbmNhdCh0aGlzLl9mb250LmlkLCBcIiBcIikuY29uY2F0KG51bWJlciQyKHRoaXMuX2ZvbnRTaXplKSwgXCIgVGZcIikpOyAvLyByZW5kZXJpbmcgbW9kZVxuXG4gICAgdmFyIG1vZGUgPSBvcHRpb25zLmZpbGwgJiYgb3B0aW9ucy5zdHJva2UgPyAyIDogb3B0aW9ucy5zdHJva2UgPyAxIDogMDtcblxuICAgIGlmIChtb2RlKSB7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoXCJcIi5jb25jYXQobW9kZSwgXCIgVHJcIikpO1xuICAgIH0gLy8gQ2hhcmFjdGVyIHNwYWNpbmdcblxuXG4gICAgaWYgKGNoYXJhY3RlclNwYWNpbmcpIHtcbiAgICAgIHRoaXMuYWRkQ29udGVudChcIlwiLmNvbmNhdChudW1iZXIkMihjaGFyYWN0ZXJTcGFjaW5nKSwgXCIgVGNcIikpO1xuICAgIH0gLy8gQWRkIHRoZSBhY3R1YWwgdGV4dFxuICAgIC8vIElmIHdlIGhhdmUgYSB3b3JkIHNwYWNpbmcgdmFsdWUsIHdlIG5lZWQgdG8gZW5jb2RlIGVhY2ggd29yZCBzZXBhcmF0ZWx5XG4gICAgLy8gc2luY2UgdGhlIG5vcm1hbCBUdyBvcGVyYXRvciBvbmx5IHdvcmtzIG9uIGNoYXJhY3RlciBjb2RlIDMyLCB3aGljaCBpc24ndFxuICAgIC8vIHVzZWQgZm9yIGVtYmVkZGVkIGZvbnRzLlxuXG5cbiAgICBpZiAod29yZFNwYWNpbmcpIHtcbiAgICAgIHdvcmRzID0gdGV4dC50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgICAgIHdvcmRTcGFjaW5nICs9IHRoaXMud2lkdGhPZlN0cmluZygnICcpICsgY2hhcmFjdGVyU3BhY2luZztcbiAgICAgIHdvcmRTcGFjaW5nICo9IDEwMDAgLyB0aGlzLl9mb250U2l6ZTtcbiAgICAgIGVuY29kZWQgPSBbXTtcbiAgICAgIHBvc2l0aW9ucyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHdvcmRzKSxcbiAgICAgICAgICBfc3RlcDI7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHdvcmQgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3RoaXMkX2ZvbnQkZW5jb2RlID0gdGhpcy5fZm9udC5lbmNvZGUod29yZCwgb3B0aW9ucy5mZWF0dXJlcyksXG4gICAgICAgICAgICAgIF90aGlzJF9mb250JGVuY29kZTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZm9udCRlbmNvZGUsIDIpLFxuICAgICAgICAgICAgICBlbmNvZGVkV29yZCA9IF90aGlzJF9mb250JGVuY29kZTJbMF0sXG4gICAgICAgICAgICAgIHBvc2l0aW9uc1dvcmQgPSBfdGhpcyRfZm9udCRlbmNvZGUyWzFdO1xuXG4gICAgICAgICAgZW5jb2RlZCA9IGVuY29kZWQuY29uY2F0KGVuY29kZWRXb3JkKTtcbiAgICAgICAgICBwb3NpdGlvbnMgPSBwb3NpdGlvbnMuY29uY2F0KHBvc2l0aW9uc1dvcmQpOyAvLyBhZGQgdGhlIHdvcmQgc3BhY2luZyB0byB0aGUgZW5kIG9mIHRoZSB3b3JkXG4gICAgICAgICAgLy8gY2xvbmUgb2JqZWN0IGJlY2F1c2Ugb2YgY2FjaGVcblxuICAgICAgICAgIHZhciBzcGFjZSA9IHt9O1xuICAgICAgICAgIHZhciBvYmplY3QgPSBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgc3BhY2Vba2V5XSA9IHZhbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcGFjZS54QWR2YW5jZSArPSB3b3JkU3BhY2luZztcbiAgICAgICAgICBwb3NpdGlvbnNbcG9zaXRpb25zLmxlbmd0aCAtIDFdID0gc3BhY2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3RoaXMkX2ZvbnQkZW5jb2RlMyA9IHRoaXMuX2ZvbnQuZW5jb2RlKHRleHQsIG9wdGlvbnMuZmVhdHVyZXMpO1xuXG4gICAgICB2YXIgX3RoaXMkX2ZvbnQkZW5jb2RlNCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9mb250JGVuY29kZTMsIDIpO1xuXG4gICAgICBlbmNvZGVkID0gX3RoaXMkX2ZvbnQkZW5jb2RlNFswXTtcbiAgICAgIHBvc2l0aW9ucyA9IF90aGlzJF9mb250JGVuY29kZTRbMV07XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gdGhpcy5fZm9udFNpemUgLyAxMDAwO1xuICAgIHZhciBjb21tYW5kcyA9IFtdO1xuICAgIHZhciBsYXN0ID0gMDtcbiAgICB2YXIgaGFkT2Zmc2V0ID0gZmFsc2U7IC8vIEFkZHMgYSBzZWdtZW50IG9mIHRleHQgdG8gdGhlIFRKIGNvbW1hbmQgYnVmZmVyXG5cbiAgICB2YXIgYWRkU2VnbWVudCA9IGZ1bmN0aW9uIGFkZFNlZ21lbnQoY3VyKSB7XG4gICAgICBpZiAobGFzdCA8IGN1cikge1xuICAgICAgICB2YXIgaGV4ID0gZW5jb2RlZC5zbGljZShsYXN0LCBjdXIpLmpvaW4oJycpO1xuICAgICAgICB2YXIgYWR2YW5jZSA9IHBvc2l0aW9uc1tjdXIgLSAxXS54QWR2YW5jZSAtIHBvc2l0aW9uc1tjdXIgLSAxXS5hZHZhbmNlV2lkdGg7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goXCI8XCIuY29uY2F0KGhleCwgXCI+IFwiKS5jb25jYXQobnVtYmVyJDIoLWFkdmFuY2UpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsYXN0ID0gY3VyO1xuICAgIH07IC8vIEZsdXNoZXMgdGhlIGN1cnJlbnQgVEogY29tbWFuZHMgdG8gdGhlIG91dHB1dCBzdHJlYW1cblxuXG4gICAgdmFyIGZsdXNoID0gZnVuY3Rpb24gZmx1c2goaSkge1xuICAgICAgYWRkU2VnbWVudChpKTtcblxuICAgICAgaWYgKGNvbW1hbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgX3RoaXM0LmFkZENvbnRlbnQoXCJbXCIuY29uY2F0KGNvbW1hbmRzLmpvaW4oJyAnKSwgXCJdIFRKXCIpKTtcblxuICAgICAgICByZXR1cm4gY29tbWFuZHMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhbiB4IG9yIHkgb2Zmc2V0LCB3ZSBoYXZlIHRvIGJyZWFrIG91dCBvZiB0aGUgY3VycmVudCBUSiBjb21tYW5kXG4gICAgICAvLyBzbyB3ZSBjYW4gbW92ZSB0aGUgdGV4dCBwb3NpdGlvbi5cbiAgICAgIHZhciBwb3MgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIGlmIChwb3MueE9mZnNldCB8fCBwb3MueU9mZnNldCkge1xuICAgICAgICAvLyBGbHVzaCB0aGUgY3VycmVudCBidWZmZXJcbiAgICAgICAgZmx1c2goaSk7IC8vIE1vdmUgdGhlIHRleHQgcG9zaXRpb24gYW5kIGZsdXNoIGp1c3QgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG5cbiAgICAgICAgdGhpcy5hZGRDb250ZW50KFwiMSAwIDAgMSBcIi5jb25jYXQobnVtYmVyJDIoeCArIHBvcy54T2Zmc2V0ICogc2NhbGUpLCBcIiBcIikuY29uY2F0KG51bWJlciQyKHkgKyBwb3MueU9mZnNldCAqIHNjYWxlKSwgXCIgVG1cIikpO1xuICAgICAgICBmbHVzaChpICsgMSk7XG4gICAgICAgIGhhZE9mZnNldCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaGFkIGFuIG9mZnNldCwgcmVzZXQgdGhlIHRleHQgcG9zaXRpb25cbiAgICAgICAgaWYgKGhhZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYWRkQ29udGVudChcIjEgMCAwIDEgXCIuY29uY2F0KG51bWJlciQyKHgpLCBcIiBcIikuY29uY2F0KG51bWJlciQyKHkpLCBcIiBUbVwiKSk7XG4gICAgICAgICAgaGFkT2Zmc2V0ID0gZmFsc2U7XG4gICAgICAgIH0gLy8gR3JvdXAgc2VnbWVudHMgdGhhdCBkb24ndCBoYXZlIGFueSBhZHZhbmNlIGFkanVzdG1lbnRzXG5cblxuICAgICAgICBpZiAocG9zLnhBZHZhbmNlIC0gcG9zLmFkdmFuY2VXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGFkZFNlZ21lbnQoaSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHggKz0gcG9zLnhBZHZhbmNlICogc2NhbGU7XG4gICAgfSAvLyBGbHVzaCBhbnkgcmVtYWluaW5nIGNvbW1hbmRzXG5cblxuICAgIGZsdXNoKGkpOyAvLyBlbmQgdGhlIHRleHQgb2JqZWN0XG5cbiAgICB0aGlzLmFkZENvbnRlbnQoJ0VUJyk7IC8vIHJlc3RvcmUgZmxpcHBlZCBjb29yZGluYXRlIHN5c3RlbVxuXG4gICAgcmV0dXJuIHRoaXMucmVzdG9yZSgpO1xuICB9XG59O1xuXG52YXIgTUFSS0VSUyA9IFsweGZmYzAsIDB4ZmZjMSwgMHhmZmMyLCAweGZmYzMsIDB4ZmZjNSwgMHhmZmM2LCAweGZmYzcsIDB4ZmZjOCwgMHhmZmM5LCAweGZmY2EsIDB4ZmZjYiwgMHhmZmNjLCAweGZmY2QsIDB4ZmZjZSwgMHhmZmNmXTtcbnZhciBDT0xPUl9TUEFDRV9NQVAgPSB7XG4gIDE6ICdEZXZpY2VHcmF5JyxcbiAgMzogJ0RldmljZVJHQicsXG4gIDQ6ICdEZXZpY2VDTVlLJ1xufTtcblxudmFyIEpQRUcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKUEVHKGRhdGEsIGxhYmVsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpQRUcpO1xuXG4gICAgdmFyIG1hcmtlcjtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcblxuICAgIGlmICh0aGlzLmRhdGEucmVhZFVJbnQxNkJFKDApICE9PSAweGZmZDgpIHtcbiAgICAgIHRocm93ICdTT0kgbm90IGZvdW5kIGluIEpQRUcnO1xuICAgIH1cblxuICAgIHZhciBwb3MgPSAyO1xuXG4gICAgd2hpbGUgKHBvcyA8IHRoaXMuZGF0YS5sZW5ndGgpIHtcbiAgICAgIG1hcmtlciA9IHRoaXMuZGF0YS5yZWFkVUludDE2QkUocG9zKTtcbiAgICAgIHBvcyArPSAyO1xuXG4gICAgICBpZiAoTUFSS0VSUy5pbmNsdWRlcyhtYXJrZXIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MgKz0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIH1cblxuICAgIGlmICghTUFSS0VSUy5pbmNsdWRlcyhtYXJrZXIpKSB7XG4gICAgICB0aHJvdyAnSW52YWxpZCBKUEVHLic7XG4gICAgfVxuXG4gICAgcG9zICs9IDI7XG4gICAgdGhpcy5iaXRzID0gdGhpcy5kYXRhW3BvcysrXTtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuZGF0YS5yZWFkVUludDE2QkUocG9zKTtcbiAgICBwb3MgKz0gMjtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5kYXRhLnJlYWRVSW50MTZCRShwb3MpO1xuICAgIHBvcyArPSAyO1xuICAgIHZhciBjaGFubmVscyA9IHRoaXMuZGF0YVtwb3MrK107XG4gICAgdGhpcy5jb2xvclNwYWNlID0gQ09MT1JfU1BBQ0VfTUFQW2NoYW5uZWxzXTtcbiAgICB0aGlzLm9iaiA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSlBFRywgW3tcbiAgICBrZXk6IFwiZW1iZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1iZWQoZG9jdW1lbnQpIHtcbiAgICAgIGlmICh0aGlzLm9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2JqID0gZG9jdW1lbnQucmVmKHtcbiAgICAgICAgVHlwZTogJ1hPYmplY3QnLFxuICAgICAgICBTdWJ0eXBlOiAnSW1hZ2UnLFxuICAgICAgICBCaXRzUGVyQ29tcG9uZW50OiB0aGlzLmJpdHMsXG4gICAgICAgIFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBIZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBDb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsXG4gICAgICAgIEZpbHRlcjogJ0RDVERlY29kZSdcbiAgICAgIH0pOyAvLyBhZGQgZXh0cmEgZGVjb2RlIHBhcmFtcyBmb3IgQ01ZSyBpbWFnZXMuIEJ5IHN3YXBwaW5nIHRoZVxuICAgICAgLy8gbWluIGFuZCBtYXggdmFsdWVzIGZyb20gdGhlIGRlZmF1bHQsIHdlIGludmVydCB0aGUgY29sb3JzLiBTZWVcbiAgICAgIC8vIHNlY3Rpb24gNC44LjQgb2YgdGhlIHNwZWMuXG5cbiAgICAgIGlmICh0aGlzLmNvbG9yU3BhY2UgPT09ICdEZXZpY2VDTVlLJykge1xuICAgICAgICB0aGlzLm9iai5kYXRhWydEZWNvZGUnXSA9IFsxLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDAuMF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2JqLmVuZCh0aGlzLmRhdGEpOyAvLyBmcmVlIG1lbW9yeVxuXG4gICAgICByZXR1cm4gdGhpcy5kYXRhID0gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSlBFRztcbn0oKTtcblxudmFyIFBOR0ltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUE5HSW1hZ2UoZGF0YSwgbGFiZWwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUE5HSW1hZ2UpO1xuXG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMuaW1hZ2UgPSBuZXcgUE5HKGRhdGEpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmltYWdlLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5pbWFnZS5oZWlnaHQ7XG4gICAgdGhpcy5pbWdEYXRhID0gdGhpcy5pbWFnZS5pbWdEYXRhO1xuICAgIHRoaXMub2JqID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQTkdJbWFnZSwgW3tcbiAgICBrZXk6IFwiZW1iZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1iZWQoZG9jdW1lbnQpIHtcbiAgICAgIHZhciBkYXRhRGVjb2RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICBpZiAodGhpcy5vYmopIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzQWxwaGFDaGFubmVsID0gdGhpcy5pbWFnZS5oYXNBbHBoYUNoYW5uZWw7XG4gICAgICB2YXIgaXNJbnRlcmxhY2VkID0gdGhpcy5pbWFnZS5pbnRlcmxhY2VNZXRob2QgPT09IDE7XG4gICAgICB0aGlzLm9iaiA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgVHlwZTogJ1hPYmplY3QnLFxuICAgICAgICBTdWJ0eXBlOiAnSW1hZ2UnLFxuICAgICAgICBCaXRzUGVyQ29tcG9uZW50OiBoYXNBbHBoYUNoYW5uZWwgPyA4IDogdGhpcy5pbWFnZS5iaXRzLFxuICAgICAgICBXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgSGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgRmlsdGVyOiAnRmxhdGVEZWNvZGUnXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFoYXNBbHBoYUNoYW5uZWwpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgICBQcmVkaWN0b3I6IGlzSW50ZXJsYWNlZCA/IDEgOiAxNSxcbiAgICAgICAgICBDb2xvcnM6IHRoaXMuaW1hZ2UuY29sb3JzLFxuICAgICAgICAgIEJpdHNQZXJDb21wb25lbnQ6IHRoaXMuaW1hZ2UuYml0cyxcbiAgICAgICAgICBDb2x1bW5zOiB0aGlzLndpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9iai5kYXRhWydEZWNvZGVQYXJtcyddID0gcGFyYW1zO1xuICAgICAgICBwYXJhbXMuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmltYWdlLnBhbGV0dGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMub2JqLmRhdGFbJ0NvbG9yU3BhY2UnXSA9IHRoaXMuaW1hZ2UuY29sb3JTcGFjZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtYmVkIHRoZSBjb2xvciBwYWxldHRlIGluIHRoZSBQREYgYXMgYW4gb2JqZWN0IHN0cmVhbVxuICAgICAgICB2YXIgcGFsZXR0ZSA9IHRoaXMuZG9jdW1lbnQucmVmKCk7XG4gICAgICAgIHBhbGV0dGUuZW5kKEJ1ZmZlci5mcm9tKHRoaXMuaW1hZ2UucGFsZXR0ZSkpOyAvLyBidWlsZCB0aGUgY29sb3Igc3BhY2UgYXJyYXkgZm9yIHRoZSBpbWFnZVxuXG4gICAgICAgIHRoaXMub2JqLmRhdGFbJ0NvbG9yU3BhY2UnXSA9IFsnSW5kZXhlZCcsICdEZXZpY2VSR0InLCB0aGlzLmltYWdlLnBhbGV0dGUubGVuZ3RoIC8gMyAtIDEsIHBhbGV0dGVdO1xuICAgICAgfSAvLyBGb3IgUE5HIGNvbG9yIHR5cGVzIDAsIDIgYW5kIDMsIHRoZSB0cmFuc3BhcmVuY3kgZGF0YSBpcyBzdG9yZWQgaW5cbiAgICAgIC8vIGEgZGVkaWNhdGVkIFBORyBjaHVuay5cblxuXG4gICAgICBpZiAodGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuZ3JheXNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVXNlIENvbG9yIEtleSBNYXNraW5nIChzcGVjIHNlY3Rpb24gNC44LjUpXG4gICAgICAgIC8vIEFuIGFycmF5IHdpdGggTiBlbGVtZW50cywgd2hlcmUgTiBpcyB0d28gdGltZXMgdGhlIG51bWJlciBvZiBjb2xvciBjb21wb25lbnRzLlxuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuZ3JheXNjYWxlO1xuICAgICAgICB0aGlzLm9iai5kYXRhWydNYXNrJ10gPSBbdmFsLCB2YWxdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmltYWdlLnRyYW5zcGFyZW5jeS5yZ2IpIHtcbiAgICAgICAgLy8gVXNlIENvbG9yIEtleSBNYXNraW5nIChzcGVjIHNlY3Rpb24gNC44LjUpXG4gICAgICAgIC8vIEFuIGFycmF5IHdpdGggTiBlbGVtZW50cywgd2hlcmUgTiBpcyB0d28gdGltZXMgdGhlIG51bWJlciBvZiBjb2xvciBjb21wb25lbnRzLlxuICAgICAgICB2YXIgcmdiID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3kucmdiO1xuICAgICAgICB2YXIgbWFzayA9IFtdO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyZ2IpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG1hc2sucHVzaCh4LCB4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub2JqLmRhdGFbJ01hc2snXSA9IG1hc2s7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW1hZ2UudHJhbnNwYXJlbmN5LmluZGV4ZWQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdHJhbnNwYXJlbmN5IFNNYXNrIGZvciB0aGUgaW1hZ2UgYmFzZWQgb24gdGhlIGRhdGFcbiAgICAgICAgLy8gaW4gdGhlIFBMVEUgYW5kIHRSTlMgc2VjdGlvbnMuIFNlZSBiZWxvdyBmb3IgZGV0YWlscyBvbiBTTWFza3MuXG4gICAgICAgIGRhdGFEZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZEluZGV4ZWRBbHBoYUNoYW5uZWwoKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzQWxwaGFDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciBQTkcgY29sb3IgdHlwZXMgNCBhbmQgNiwgdGhlIHRyYW5zcGFyZW5jeSBkYXRhIGlzIHN0b3JlZCBhcyBhIGFscGhhXG4gICAgICAgIC8vIGNoYW5uZWwgbWl4ZWQgaW4gd2l0aCB0aGUgbWFpbiBpbWFnZSBkYXRhLiBTZXBhcmF0ZSB0aGlzIGRhdGEgb3V0IGludG8gYW5cbiAgICAgICAgLy8gU01hc2sgb2JqZWN0IGFuZCBzdG9yZSBpdCBzZXBhcmF0ZWx5IGluIHRoZSBQREYuXG4gICAgICAgIGRhdGFEZWNvZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRBbHBoYUNoYW5uZWwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSW50ZXJsYWNlZCAmJiAhZGF0YURlY29kZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRGF0YSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmFsaXplKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmFsaXplKCkge1xuICAgICAgaWYgKHRoaXMuYWxwaGFDaGFubmVsKSB7XG4gICAgICAgIHZhciBzTWFzayA9IHRoaXMuZG9jdW1lbnQucmVmKHtcbiAgICAgICAgICBUeXBlOiAnWE9iamVjdCcsXG4gICAgICAgICAgU3VidHlwZTogJ0ltYWdlJyxcbiAgICAgICAgICBIZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgIFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgIEJpdHNQZXJDb21wb25lbnQ6IDgsXG4gICAgICAgICAgRmlsdGVyOiAnRmxhdGVEZWNvZGUnLFxuICAgICAgICAgIENvbG9yU3BhY2U6ICdEZXZpY2VHcmF5JyxcbiAgICAgICAgICBEZWNvZGU6IFswLCAxXVxuICAgICAgICB9KTtcbiAgICAgICAgc01hc2suZW5kKHRoaXMuYWxwaGFDaGFubmVsKTtcbiAgICAgICAgdGhpcy5vYmouZGF0YVsnU01hc2snXSA9IHNNYXNrO1xuICAgICAgfSAvLyBhZGQgdGhlIGFjdHVhbCBpbWFnZSBkYXRhXG5cblxuICAgICAgdGhpcy5vYmouZW5kKHRoaXMuaW1nRGF0YSk7IC8vIGZyZWUgbWVtb3J5XG5cbiAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuaW1nRGF0YSA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0QWxwaGFDaGFubmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0QWxwaGFDaGFubmVsKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuaW1hZ2UuZGVjb2RlUGl4ZWxzKGZ1bmN0aW9uIChwaXhlbHMpIHtcbiAgICAgICAgdmFyIGEsIHA7XG4gICAgICAgIHZhciBjb2xvckNvdW50ID0gX3RoaXMuaW1hZ2UuY29sb3JzO1xuICAgICAgICB2YXIgcGl4ZWxDb3VudCA9IF90aGlzLndpZHRoICogX3RoaXMuaGVpZ2h0O1xuICAgICAgICB2YXIgaW1nRGF0YSA9IEJ1ZmZlci5hbGxvYyhwaXhlbENvdW50ICogY29sb3JDb3VudCk7XG4gICAgICAgIHZhciBhbHBoYUNoYW5uZWwgPSBCdWZmZXIuYWxsb2MocGl4ZWxDb3VudCk7XG4gICAgICAgIHZhciBpID0gcCA9IGEgPSAwO1xuICAgICAgICB2YXIgbGVuID0gcGl4ZWxzLmxlbmd0aDsgLy8gRm9yIDE2Yml0IGltYWdlcyBjb3B5IG9ubHkgbW9zdCBzaWduaWZpY2FudCBieXRlIChNU0IpIC0gUE5HIGRhdGEgaXMgYWx3YXlzIHN0b3JlZCBpbiBuZXR3b3JrIGJ5dGUgb3JkZXIgKE1TQiBmaXJzdClcblxuICAgICAgICB2YXIgc2tpcEJ5dGVDb3VudCA9IF90aGlzLmltYWdlLmJpdHMgPT09IDE2ID8gMSA6IDA7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBmb3IgKHZhciBjb2xvckluZGV4ID0gMDsgY29sb3JJbmRleCA8IGNvbG9yQ291bnQ7IGNvbG9ySW5kZXgrKykge1xuICAgICAgICAgICAgaW1nRGF0YVtwKytdID0gcGl4ZWxzW2krK107XG4gICAgICAgICAgICBpICs9IHNraXBCeXRlQ291bnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYWxwaGFDaGFubmVsW2ErK10gPSBwaXhlbHNbaSsrXTtcbiAgICAgICAgICBpICs9IHNraXBCeXRlQ291bnQ7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5pbWdEYXRhID0gemxpYi5kZWZsYXRlU3luYyhpbWdEYXRhKTtcbiAgICAgICAgX3RoaXMuYWxwaGFDaGFubmVsID0gemxpYi5kZWZsYXRlU3luYyhhbHBoYUNoYW5uZWwpO1xuICAgICAgICByZXR1cm4gX3RoaXMuZmluYWxpemUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkSW5kZXhlZEFscGhhQ2hhbm5lbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb2FkSW5kZXhlZEFscGhhQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJhbnNwYXJlbmN5ID0gdGhpcy5pbWFnZS50cmFuc3BhcmVuY3kuaW5kZXhlZDtcbiAgICAgIHJldHVybiB0aGlzLmltYWdlLmRlY29kZVBpeGVscyhmdW5jdGlvbiAocGl4ZWxzKSB7XG4gICAgICAgIHZhciBhbHBoYUNoYW5uZWwgPSBCdWZmZXIuYWxsb2MoX3RoaXMyLndpZHRoICogX3RoaXMyLmhlaWdodCk7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKHZhciBqID0gMCwgZW5kID0gcGl4ZWxzLmxlbmd0aDsgaiA8IGVuZDsgaisrKSB7XG4gICAgICAgICAgYWxwaGFDaGFubmVsW2krK10gPSB0cmFuc3BhcmVuY3lbcGl4ZWxzW2pdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5hbHBoYUNoYW5uZWwgPSB6bGliLmRlZmxhdGVTeW5jKGFscGhhQ2hhbm5lbCk7XG4gICAgICAgIHJldHVybiBfdGhpczIuZmluYWxpemUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZURhdGEoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5pbWFnZS5kZWNvZGVQaXhlbHMoZnVuY3Rpb24gKHBpeGVscykge1xuICAgICAgICBfdGhpczMuaW1nRGF0YSA9IHpsaWIuZGVmbGF0ZVN5bmMocGl4ZWxzKTtcblxuICAgICAgICBfdGhpczMuZmluYWxpemUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQTkdJbWFnZTtcbn0oKTtcblxudmFyIFBERkltYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGSW1hZ2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkltYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZJbWFnZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwib3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKHNyYywgbGFiZWwpIHtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHNyYykpIHtcbiAgICAgICAgZGF0YSA9IHNyYztcbiAgICAgIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHNyYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICAgIGlmIChtYXRjaCA9IC9eZGF0YTouKztiYXNlNjQsKC4qKSQvLmV4ZWMoc3JjKSkge1xuICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShtYXRjaFsxXSwgJ2Jhc2U2NCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoc3JjKTtcblxuICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YVswXSA9PT0gMHhmZiAmJiBkYXRhWzFdID09PSAweGQ4KSB7XG4gICAgICAgIHJldHVybiBuZXcgSlBFRyhkYXRhLCBsYWJlbCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGFbMF0gPT09IDB4ODkgJiYgZGF0YS50b1N0cmluZygnYXNjaWknLCAxLCA0KSA9PT0gJ1BORycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQTkdJbWFnZShkYXRhLCBsYWJlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gaW1hZ2UgZm9ybWF0LicpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZJbWFnZTtcbn0oKTtcblxudmFyIEltYWdlc01peGluID0ge1xuICBpbml0SW1hZ2VzOiBmdW5jdGlvbiBpbml0SW1hZ2VzKCkge1xuICAgIHRoaXMuX2ltYWdlUmVnaXN0cnkgPSB7fTtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VDb3VudCA9IDA7XG4gIH0sXG4gIGltYWdlOiBmdW5jdGlvbiBpbWFnZShzcmMsIHgsIHkpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDoge307XG4gICAgdmFyIGJoLCBicCwgYncsIGltYWdlLCBpcCwgbGVmdCwgbGVmdDE7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgICBvcHRpb25zID0geDtcbiAgICAgIHggPSBudWxsO1xuICAgIH1cblxuICAgIHggPSAobGVmdCA9IHggIT0gbnVsbCA/IHggOiBvcHRpb25zLngpICE9IG51bGwgPyBsZWZ0IDogdGhpcy54O1xuICAgIHkgPSAobGVmdDEgPSB5ICE9IG51bGwgPyB5IDogb3B0aW9ucy55KSAhPSBudWxsID8gbGVmdDEgOiB0aGlzLnk7XG5cbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltYWdlID0gdGhpcy5faW1hZ2VSZWdpc3RyeVtzcmNdO1xuICAgIH1cblxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIGlmIChzcmMud2lkdGggJiYgc3JjLmhlaWdodCkge1xuICAgICAgICBpbWFnZSA9IHNyYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGltYWdlID0gdGhpcy5vcGVuSW1hZ2Uoc3JjKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWltYWdlLm9iaikge1xuICAgICAgaW1hZ2UuZW1iZWQodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGFnZS54b2JqZWN0c1tpbWFnZS5sYWJlbF0gPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlLnhvYmplY3RzW2ltYWdlLmxhYmVsXSA9IGltYWdlLm9iajtcbiAgICB9XG5cbiAgICB2YXIgdyA9IG9wdGlvbnMud2lkdGggfHwgaW1hZ2Uud2lkdGg7XG4gICAgdmFyIGggPSBvcHRpb25zLmhlaWdodCB8fCBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAob3B0aW9ucy53aWR0aCAmJiAhb3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgIHZhciB3cCA9IHcgLyBpbWFnZS53aWR0aDtcbiAgICAgIHcgPSBpbWFnZS53aWR0aCAqIHdwO1xuICAgICAgaCA9IGltYWdlLmhlaWdodCAqIHdwO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgJiYgIW9wdGlvbnMud2lkdGgpIHtcbiAgICAgIHZhciBocCA9IGggLyBpbWFnZS5oZWlnaHQ7XG4gICAgICB3ID0gaW1hZ2Uud2lkdGggKiBocDtcbiAgICAgIGggPSBpbWFnZS5oZWlnaHQgKiBocDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2NhbGUpIHtcbiAgICAgIHcgPSBpbWFnZS53aWR0aCAqIG9wdGlvbnMuc2NhbGU7XG4gICAgICBoID0gaW1hZ2UuaGVpZ2h0ICogb3B0aW9ucy5zY2FsZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICB2YXIgX29wdGlvbnMkZml0ID0gX3NsaWNlZFRvQXJyYXkob3B0aW9ucy5maXQsIDIpO1xuXG4gICAgICBidyA9IF9vcHRpb25zJGZpdFswXTtcbiAgICAgIGJoID0gX29wdGlvbnMkZml0WzFdO1xuICAgICAgYnAgPSBidyAvIGJoO1xuICAgICAgaXAgPSBpbWFnZS53aWR0aCAvIGltYWdlLmhlaWdodDtcblxuICAgICAgaWYgKGlwID4gYnApIHtcbiAgICAgICAgdyA9IGJ3O1xuICAgICAgICBoID0gYncgLyBpcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSBiaDtcbiAgICAgICAgdyA9IGJoICogaXA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmNvdmVyKSB7XG4gICAgICB2YXIgX29wdGlvbnMkY292ZXIgPSBfc2xpY2VkVG9BcnJheShvcHRpb25zLmNvdmVyLCAyKTtcblxuICAgICAgYncgPSBfb3B0aW9ucyRjb3ZlclswXTtcbiAgICAgIGJoID0gX29wdGlvbnMkY292ZXJbMV07XG4gICAgICBicCA9IGJ3IC8gYmg7XG4gICAgICBpcCA9IGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICBpZiAoaXAgPiBicCkge1xuICAgICAgICBoID0gYmg7XG4gICAgICAgIHcgPSBiaCAqIGlwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdyA9IGJ3O1xuICAgICAgICBoID0gYncgLyBpcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maXQgfHwgb3B0aW9ucy5jb3Zlcikge1xuICAgICAgaWYgKG9wdGlvbnMuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSB4ICsgYncgLyAyIC0gdyAvIDI7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCA9IHggKyBidyAtIHc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnZhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9IHkgKyBiaCAvIDIgLSBoIC8gMjtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy52YWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgPSB5ICsgYmggLSBoO1xuICAgICAgfVxuICAgIH0gLy8gY3JlYXRlIGxpbmsgYW5ub3RhdGlvbnMgaWYgdGhlIGxpbmsgb3B0aW9uIGlzIGdpdmVuXG5cblxuICAgIGlmIChvcHRpb25zLmxpbmsgIT0gbnVsbCkge1xuICAgICAgdGhpcy5saW5rKHgsIHksIHcsIGgsIG9wdGlvbnMubGluayk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZ29UbyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmdvVG8oeCwgeSwgdywgaCwgb3B0aW9ucy5nb1RvKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kZXN0aW5hdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aGlzLmFkZE5hbWVkRGVzdGluYXRpb24ob3B0aW9ucy5kZXN0aW5hdGlvbiwgJ1hZWicsIHgsIHksIG51bGwpO1xuICAgIH0gLy8gU2V0IHRoZSBjdXJyZW50IHkgcG9zaXRpb24gdG8gYmVsb3cgdGhlIGltYWdlIGlmIGl0IGlzIGluIHRoZSBkb2N1bWVudCBmbG93XG5cblxuICAgIGlmICh0aGlzLnkgPT09IHkpIHtcbiAgICAgIHRoaXMueSArPSBoO1xuICAgIH1cblxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMudHJhbnNmb3JtKHcsIDAsIDAsIC1oLCB4LCB5ICsgaCk7XG4gICAgdGhpcy5hZGRDb250ZW50KFwiL1wiLmNvbmNhdChpbWFnZS5sYWJlbCwgXCIgRG9cIikpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvcGVuSW1hZ2U6IGZ1bmN0aW9uIG9wZW5JbWFnZShzcmMpIHtcbiAgICB2YXIgaW1hZ2U7XG5cbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGltYWdlID0gdGhpcy5faW1hZ2VSZWdpc3RyeVtzcmNdO1xuICAgIH1cblxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIGltYWdlID0gUERGSW1hZ2Uub3BlbihzcmMsIFwiSVwiLmNvbmNhdCgrK3RoaXMuX2ltYWdlQ291bnQpKTtcblxuICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2ltYWdlUmVnaXN0cnlbc3JjXSA9IGltYWdlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfVxufTtcblxudmFyIEFubm90YXRpb25zTWl4aW4gPSB7XG4gIGFubm90YXRlOiBmdW5jdGlvbiBhbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5UeXBlID0gJ0Fubm90JztcbiAgICBvcHRpb25zLlJlY3QgPSB0aGlzLl9jb252ZXJ0UmVjdCh4LCB5LCB3LCBoKTtcbiAgICBvcHRpb25zLkJvcmRlciA9IFswLCAwLCAwXTtcblxuICAgIGlmIChvcHRpb25zLlN1YnR5cGUgPT09ICdMaW5rJyAmJiB0eXBlb2Ygb3B0aW9ucy5GID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy5GID0gMSA8PCAyOyAvLyBQcmludCBBbm5vdGF0aW9uIEZsYWdcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5TdWJ0eXBlICE9PSAnTGluaycpIHtcbiAgICAgIGlmIChvcHRpb25zLkMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLkMgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihvcHRpb25zLmNvbG9yIHx8IFswLCAwLCAwXSk7XG4gICAgICB9XG4gICAgfSAvLyBjb252ZXJ0IGNvbG9yc1xuXG5cbiAgICBkZWxldGUgb3B0aW9ucy5jb2xvcjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5EZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy5EZXN0ID0gbmV3IFN0cmluZyhvcHRpb25zLkRlc3QpO1xuICAgIH0gLy8gQ2FwaXRhbGl6ZSBrZXlzXG5cblxuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICB2YXIgdmFsID0gb3B0aW9uc1trZXldO1xuICAgICAgb3B0aW9uc1trZXlbMF0udG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKV0gPSB2YWw7XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHRoaXMucmVmKG9wdGlvbnMpO1xuICAgIHRoaXMucGFnZS5hbm5vdGF0aW9ucy5wdXNoKHJlZik7XG4gICAgcmVmLmVuZCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBub3RlOiBmdW5jdGlvbiBub3RlKHgsIHksIHcsIGgsIGNvbnRlbnRzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdUZXh0JztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZyhjb250ZW50cyk7XG4gICAgb3B0aW9ucy5OYW1lID0gJ0NvbW1lbnQnO1xuXG4gICAgaWYgKG9wdGlvbnMuY29sb3IgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5jb2xvciA9IFsyNDMsIDIyMywgOTJdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBnb1RvOiBmdW5jdGlvbiBnb1RvKHgsIHksIHcsIGgsIG5hbWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0xpbmsnO1xuICAgIG9wdGlvbnMuQSA9IHRoaXMucmVmKHtcbiAgICAgIFM6ICdHb1RvJyxcbiAgICAgIEQ6IG5ldyBTdHJpbmcobmFtZSlcbiAgICB9KTtcbiAgICBvcHRpb25zLkEuZW5kKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGxpbms6IGZ1bmN0aW9uIGxpbmsoeCwgeSwgdywgaCwgdXJsKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdMaW5rJztcblxuICAgIGlmICh0eXBlb2YgdXJsID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gTGluayB0byBhIHBhZ2UgaW4gdGhlIGRvY3VtZW50ICh0aGUgcGFnZSBtdXN0IGFscmVhZHkgZXhpc3QpXG4gICAgICB2YXIgcGFnZXMgPSB0aGlzLl9yb290LmRhdGEuUGFnZXMuZGF0YTtcblxuICAgICAgaWYgKHVybCA+PSAwICYmIHVybCA8IHBhZ2VzLktpZHMubGVuZ3RoKSB7XG4gICAgICAgIG9wdGlvbnMuQSA9IHRoaXMucmVmKHtcbiAgICAgICAgICBTOiAnR29UbycsXG4gICAgICAgICAgRDogW3BhZ2VzLktpZHNbdXJsXSwgJ1hZWicsIG51bGwsIG51bGwsIG51bGxdXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLkEuZW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZG9jdW1lbnQgaGFzIG5vIHBhZ2UgXCIuY29uY2F0KHVybCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaW5rIHRvIGFuIGV4dGVybmFsIHVybFxuICAgICAgb3B0aW9ucy5BID0gdGhpcy5yZWYoe1xuICAgICAgICBTOiAnVVJJJyxcbiAgICAgICAgVVJJOiBuZXcgU3RyaW5nKHVybClcbiAgICAgIH0pO1xuICAgICAgb3B0aW9ucy5BLmVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBfbWFya3VwOiBmdW5jdGlvbiBfbWFya3VwKHgsIHksIHcsIGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG5cbiAgICB2YXIgX3RoaXMkX2NvbnZlcnRSZWN0ID0gdGhpcy5fY29udmVydFJlY3QoeCwgeSwgdywgaCksXG4gICAgICAgIF90aGlzJF9jb252ZXJ0UmVjdDIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfY29udmVydFJlY3QsIDQpLFxuICAgICAgICB4MSA9IF90aGlzJF9jb252ZXJ0UmVjdDJbMF0sXG4gICAgICAgIHkxID0gX3RoaXMkX2NvbnZlcnRSZWN0MlsxXSxcbiAgICAgICAgeDIgPSBfdGhpcyRfY29udmVydFJlY3QyWzJdLFxuICAgICAgICB5MiA9IF90aGlzJF9jb252ZXJ0UmVjdDJbM107XG5cbiAgICBvcHRpb25zLlF1YWRQb2ludHMgPSBbeDEsIHkyLCB4MiwgeTIsIHgxLCB5MSwgeDIsIHkxXTtcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIHJldHVybiB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBoaWdobGlnaHQ6IGZ1bmN0aW9uIGhpZ2hsaWdodCh4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdIaWdobGlnaHQnO1xuXG4gICAgaWYgKG9wdGlvbnMuY29sb3IgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5jb2xvciA9IFsyNDEsIDIzOCwgMTQ4XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWFya3VwKHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICB1bmRlcmxpbmU6IGZ1bmN0aW9uIHVuZGVybGluZSh4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdVbmRlcmxpbmUnO1xuICAgIHJldHVybiB0aGlzLl9tYXJrdXAoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0cmlrZTogZnVuY3Rpb24gc3RyaWtlKHgsIHksIHcsIGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ1N0cmlrZU91dCc7XG4gICAgcmV0dXJuIHRoaXMuX21hcmt1cCh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgbGluZUFubm90YXRpb246IGZ1bmN0aW9uIGxpbmVBbm5vdGF0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdMaW5lJztcbiAgICBvcHRpb25zLkNvbnRlbnRzID0gbmV3IFN0cmluZygpO1xuICAgIG9wdGlvbnMuTCA9IFt4MSwgdGhpcy5wYWdlLmhlaWdodCAtIHkxLCB4MiwgdGhpcy5wYWdlLmhlaWdodCAtIHkyXTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gIH0sXG4gIHJlY3RBbm5vdGF0aW9uOiBmdW5jdGlvbiByZWN0QW5ub3RhdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdTcXVhcmUnO1xuICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIGVsbGlwc2VBbm5vdGF0aW9uOiBmdW5jdGlvbiBlbGxpcHNlQW5ub3RhdGlvbih4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdDaXJjbGUnO1xuICAgIG9wdGlvbnMuQ29udGVudHMgPSBuZXcgU3RyaW5nKCk7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIHRleHRBbm5vdGF0aW9uOiBmdW5jdGlvbiB0ZXh0QW5ub3RhdGlvbih4LCB5LCB3LCBoLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIG9wdGlvbnMuU3VidHlwZSA9ICdGcmVlVGV4dCc7XG4gICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcodGV4dCk7XG4gICAgb3B0aW9ucy5EQSA9IG5ldyBTdHJpbmcoKTtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0ZSh4LCB5LCB3LCBoLCBvcHRpb25zKTtcbiAgfSxcbiAgZmlsZUFubm90YXRpb246IGZ1bmN0aW9uIGZpbGVBbm5vdGF0aW9uKHgsIHksIHcsIGgpIHtcbiAgICB2YXIgZmlsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIC8vIGNyZWF0ZSBoaWRkZW4gZmlsZVxuICAgIHZhciBmaWxlc3BlYyA9IHRoaXMuZmlsZShmaWxlLnNyYywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBoaWRkZW46IHRydWVcbiAgICB9LCBmaWxlKSk7XG4gICAgb3B0aW9ucy5TdWJ0eXBlID0gJ0ZpbGVBdHRhY2htZW50JztcbiAgICBvcHRpb25zLkZTID0gZmlsZXNwZWM7IC8vIGFkZCBkZXNjcmlwdGlvbiBmcm9tIGZpbGVzcGVjIHVubGVzcyBkZXNjcmlwdGlvbiAoQ29udGVudHMpIGhhcyBhbHJlYWR5IGJlZW4gc2V0XG5cbiAgICBpZiAob3B0aW9ucy5Db250ZW50cykge1xuICAgICAgb3B0aW9ucy5Db250ZW50cyA9IG5ldyBTdHJpbmcob3B0aW9ucy5Db250ZW50cyk7XG4gICAgfSBlbHNlIGlmIChmaWxlc3BlYy5kYXRhLkRlc2MpIHtcbiAgICAgIG9wdGlvbnMuQ29udGVudHMgPSBmaWxlc3BlYy5kYXRhLkRlc2M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGUoeCwgeSwgdywgaCwgb3B0aW9ucyk7XG4gIH0sXG4gIF9jb252ZXJ0UmVjdDogZnVuY3Rpb24gX2NvbnZlcnRSZWN0KHgxLCB5MSwgdywgaCkge1xuICAgIC8vIGZsaXAgeTEgYW5kIHkyXG4gICAgdmFyIHkyID0geTE7XG4gICAgeTEgKz0gaDsgLy8gbWFrZSB4MlxuXG4gICAgdmFyIHgyID0geDEgKyB3OyAvLyBhcHBseSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBwb2ludHNcblxuICAgIHZhciBfdGhpcyRfY3RtID0gX3NsaWNlZFRvQXJyYXkodGhpcy5fY3RtLCA2KSxcbiAgICAgICAgbTAgPSBfdGhpcyRfY3RtWzBdLFxuICAgICAgICBtMSA9IF90aGlzJF9jdG1bMV0sXG4gICAgICAgIG0yID0gX3RoaXMkX2N0bVsyXSxcbiAgICAgICAgbTMgPSBfdGhpcyRfY3RtWzNdLFxuICAgICAgICBtNCA9IF90aGlzJF9jdG1bNF0sXG4gICAgICAgIG01ID0gX3RoaXMkX2N0bVs1XTtcblxuICAgIHgxID0gbTAgKiB4MSArIG0yICogeTEgKyBtNDtcbiAgICB5MSA9IG0xICogeDEgKyBtMyAqIHkxICsgbTU7XG4gICAgeDIgPSBtMCAqIHgyICsgbTIgKiB5MiArIG00O1xuICAgIHkyID0gbTEgKiB4MiArIG0zICogeTIgKyBtNTtcbiAgICByZXR1cm4gW3gxLCB5MSwgeDIsIHkyXTtcbiAgfVxufTtcblxudmFyIFBERk91dGxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZPdXRsaW5lKGRvY3VtZW50LCBwYXJlbnQsIHRpdGxlLCBkZXN0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHtcbiAgICAgIGV4cGFuZGVkOiBmYWxzZVxuICAgIH07XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGT3V0bGluZSk7XG5cbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLm91dGxpbmVEYXRhID0ge307XG5cbiAgICBpZiAoZGVzdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YVsnRGVzdCddID0gW2Rlc3QuZGljdGlvbmFyeSwgJ0ZpdCddO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3V0bGluZURhdGFbJ1BhcmVudCddID0gcGFyZW50O1xuICAgIH1cblxuICAgIGlmICh0aXRsZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5vdXRsaW5lRGF0YVsnVGl0bGUnXSA9IG5ldyBTdHJpbmcodGl0bGUpO1xuICAgIH1cblxuICAgIHRoaXMuZGljdGlvbmFyeSA9IHRoaXMuZG9jdW1lbnQucmVmKHRoaXMub3V0bGluZURhdGEpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZPdXRsaW5lLCBbe1xuICAgIGtleTogXCJhZGRJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEl0ZW0odGl0bGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7XG4gICAgICAgIGV4cGFuZGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgUERGT3V0bGluZSh0aGlzLmRvY3VtZW50LCB0aGlzLmRpY3Rpb25hcnksIHRpdGxlLCB0aGlzLmRvY3VtZW50LnBhZ2UsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRPdXRsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZE91dGxpbmUoKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwYW5kZWQpIHtcbiAgICAgICAgICB0aGlzLm91dGxpbmVEYXRhLkNvdW50ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3QgPSB0aGlzLmNoaWxkcmVuWzBdLFxuICAgICAgICAgICAgbGFzdCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5vdXRsaW5lRGF0YS5GaXJzdCA9IGZpcnN0LmRpY3Rpb25hcnk7XG4gICAgICAgIHRoaXMub3V0bGluZURhdGEuTGFzdCA9IGxhc3QuZGljdGlvbmFyeTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGNoaWxkLm91dGxpbmVEYXRhLlByZXYgPSB0aGlzLmNoaWxkcmVuW2kgLSAxXS5kaWN0aW9uYXJ5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBjaGlsZC5vdXRsaW5lRGF0YS5OZXh0ID0gdGhpcy5jaGlsZHJlbltpICsgMV0uZGljdGlvbmFyeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZC5lbmRPdXRsaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZGljdGlvbmFyeS5lbmQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGT3V0bGluZTtcbn0oKTtcblxudmFyIE91dGxpbmVNaXhpbiA9IHtcbiAgaW5pdE91dGxpbmU6IGZ1bmN0aW9uIGluaXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm91dGxpbmUgPSBuZXcgUERGT3V0bGluZSh0aGlzLCBudWxsLCBudWxsLCBudWxsKTtcbiAgfSxcbiAgZW5kT3V0bGluZTogZnVuY3Rpb24gZW5kT3V0bGluZSgpIHtcbiAgICB0aGlzLm91dGxpbmUuZW5kT3V0bGluZSgpO1xuXG4gICAgaWYgKHRoaXMub3V0bGluZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuT3V0bGluZXMgPSB0aGlzLm91dGxpbmUuZGljdGlvbmFyeTtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LmRhdGEuUGFnZU1vZGUgPSAnVXNlT3V0bGluZXMnO1xuICAgIH1cbiAgfVxufTtcblxuLypcclxuUERGU3RydWN0dXJlQ29udGVudCAtIGEgcmVmZXJlbmNlIHRvIGEgbWFya2VkIHN0cnVjdHVyZSBjb250ZW50XHJcbkJ5IEJlbiBTY2htaWR0XHJcbiovXG52YXIgUERGU3RydWN0dXJlQ29udGVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERlN0cnVjdHVyZUNvbnRlbnQocGFnZVJlZiwgbWNpZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZTdHJ1Y3R1cmVDb250ZW50KTtcblxuICAgIHRoaXMucmVmcyA9IFt7XG4gICAgICBwYWdlUmVmOiBwYWdlUmVmLFxuICAgICAgbWNpZDogbWNpZFxuICAgIH1dO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERlN0cnVjdHVyZUNvbnRlbnQsIFt7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaChzdHJ1Y3RDb250ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBzdHJ1Y3RDb250ZW50LnJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5yZWZzLnB1c2gocmVmKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZTdHJ1Y3R1cmVDb250ZW50O1xufSgpO1xuXG52YXIgUERGU3RydWN0dXJlRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERlN0cnVjdHVyZUVsZW1lbnQoZG9jdW1lbnQsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBjaGlsZHJlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZTdHJ1Y3R1cmVFbGVtZW50KTtcblxuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLl9hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fZmx1c2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZGljdGlvbmFyeSA9IGRvY3VtZW50LnJlZih7XG4gICAgICAvLyBUeXBlOiBcIlN0cnVjdEVsZW1cIixcbiAgICAgIFM6IHR5cGVcbiAgICB9KTtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGljdGlvbmFyeS5kYXRhO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykgfHwgdGhpcy5faXNWYWxpZENoaWxkKG9wdGlvbnMpKSB7XG4gICAgICBjaGlsZHJlbiA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRpdGxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5UID0gbmV3IFN0cmluZyhvcHRpb25zLnRpdGxlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubGFuZyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhdGEuTGFuZyA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYW5nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGF0YS5BbHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWx0KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwYW5kZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLkUgPSBuZXcgU3RyaW5nKG9wdGlvbnMuZXhwYW5kZWQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hY3R1YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkYXRhLkFjdHVhbFRleHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWN0dWFsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGNoaWxkcmVuID0gW2NoaWxkcmVuXTtcbiAgICAgIH1cblxuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmFkZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERlN0cnVjdHVyZUVsZW1lbnQsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoY2hpbGQpIHtcbiAgICAgIGlmICh0aGlzLl9lbmRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIGNoaWxkIHRvIGFscmVhZHktZW5kZWQgc3RydWN0dXJlIGVsZW1lbnRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faXNWYWxpZENoaWxkKGNoaWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cnVjdHVyZSBlbGVtZW50IGNoaWxkXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVFbGVtZW50KSB7XG4gICAgICAgIGNoaWxkLnNldFBhcmVudCh0aGlzLmRpY3Rpb25hcnkpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hlZCkge1xuICAgICAgICAgIGNoaWxkLnNldEF0dGFjaGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlQ29udGVudCkge1xuICAgICAgICB0aGlzLl9hZGRDb250ZW50VG9QYXJlbnRUcmVlKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLl9hdHRhY2hlZCkge1xuICAgICAgICAvLyBfY29udGVudEZvckNsb3N1cmUoKSBhZGRzIHRoZSBjb250ZW50IHRvIHRoZSBwYXJlbnQgdHJlZVxuICAgICAgICBjaGlsZCA9IHRoaXMuX2NvbnRlbnRGb3JDbG9zdXJlKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ29udGVudFRvUGFyZW50VHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQ29udGVudFRvUGFyZW50VHJlZShjb250ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgY29udGVudC5yZWZzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHBhZ2VSZWYgPSBfcmVmLnBhZ2VSZWYsXG4gICAgICAgICAgICBtY2lkID0gX3JlZi5tY2lkO1xuXG4gICAgICAgIHZhciBwYWdlU3RydWN0UGFyZW50cyA9IF90aGlzMi5kb2N1bWVudC5nZXRTdHJ1Y3RQYXJlbnRUcmVlKCkuZ2V0KHBhZ2VSZWYuZGF0YS5TdHJ1Y3RQYXJlbnRzKTtcblxuICAgICAgICBwYWdlU3RydWN0UGFyZW50c1ttY2lkXSA9IF90aGlzMi5kaWN0aW9uYXJ5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJlbnQocGFyZW50UmVmKSB7XG4gICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5LmRhdGEuUCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJ1Y3R1cmUgZWxlbWVudCBhZGRlZCB0byBtb3JlIHRoYW4gb25lIHBhcmVudFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kaWN0aW9uYXJ5LmRhdGEuUCA9IHBhcmVudFJlZjtcblxuICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0QXR0YWNoZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QXR0YWNoZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2F0dGFjaGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUVsZW1lbnQpIHtcbiAgICAgICAgICBjaGlsZC5zZXRBdHRhY2hlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF90aGlzMy5fY2hpbGRyZW5baW5kZXhdID0gX3RoaXMzLl9jb250ZW50Rm9yQ2xvc3VyZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9hdHRhY2hlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2ZsdXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUVsZW1lbnQ7XG4gICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQuZW5kKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9mbHVzaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNWYWxpZENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZhbGlkQ2hpbGQoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUVsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiBQREZTdHJ1Y3R1cmVDb250ZW50IHx8IHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRlbnRGb3JDbG9zdXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250ZW50Rm9yQ2xvc3VyZShjbG9zdXJlKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuZG9jdW1lbnQubWFya1N0cnVjdHVyZUNvbnRlbnQodGhpcy5kaWN0aW9uYXJ5LmRhdGEuUyk7XG4gICAgICBjbG9zdXJlKCk7XG4gICAgICB0aGlzLmRvY3VtZW50LmVuZE1hcmtlZENvbnRlbnQoKTtcblxuICAgICAgdGhpcy5fYWRkQ29udGVudFRvUGFyZW50VHJlZShjb250ZW50KTtcblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9pc0ZsdXNoYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNGbHVzaGFibGUoKSB7XG4gICAgICBpZiAoIXRoaXMuZGljdGlvbmFyeS5kYXRhLlAgfHwgIXRoaXMuX2VuZGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmV2ZXJ5KGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZC5faXNGbHVzaGFibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9mbHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmx1c2goKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2ZsdXNoZWQgfHwgIXRoaXMuX2lzRmx1c2hhYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LID0gW107XG5cbiAgICAgIHRoaXMuX2NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuX2ZsdXNoQ2hpbGQoY2hpbGQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZGljdGlvbmFyeS5lbmQoKTsgLy8gZnJlZSBtZW1vcnkgdXNlZCBieSBjaGlsZHJlbjsgdGhlIGRpY3Rpb25hcnkgaXRzZWxmIG1heSBzdGlsbCBiZVxuICAgICAgLy8gcmVmZXJlbmNlZCBieSBhIHBhcmVudCBzdHJ1Y3R1cmUgZWxlbWVudCBvciByb290LCBidXQgd2UgY2FuXG4gICAgICAvLyBhdCBsZWFzdCB0cmltIHRoZSB0cmVlIGhlcmVcblxuICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcbiAgICAgIHRoaXMuZGljdGlvbmFyeS5kYXRhLksgPSBudWxsO1xuICAgICAgdGhpcy5fZmx1c2hlZCA9IHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9mbHVzaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mbHVzaENoaWxkKGNoaWxkKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgUERGU3RydWN0dXJlRWxlbWVudCkge1xuICAgICAgICB0aGlzLmRpY3Rpb25hcnkuZGF0YS5LLnB1c2goY2hpbGQuZGljdGlvbmFyeSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIFBERlN0cnVjdHVyZUNvbnRlbnQpIHtcbiAgICAgICAgY2hpbGQucmVmcy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgIHZhciBwYWdlUmVmID0gX3JlZjIucGFnZVJlZixcbiAgICAgICAgICAgICAgbWNpZCA9IF9yZWYyLm1jaWQ7XG5cbiAgICAgICAgICBpZiAoIV90aGlzNS5kaWN0aW9uYXJ5LmRhdGEuUGcpIHtcbiAgICAgICAgICAgIF90aGlzNS5kaWN0aW9uYXJ5LmRhdGEuUGcgPSBwYWdlUmVmO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpczUuZGljdGlvbmFyeS5kYXRhLlBnID09PSBwYWdlUmVmKSB7XG4gICAgICAgICAgICBfdGhpczUuZGljdGlvbmFyeS5kYXRhLksucHVzaChtY2lkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXM1LmRpY3Rpb25hcnkuZGF0YS5LLnB1c2goe1xuICAgICAgICAgICAgICBUeXBlOiBcIk1DUlwiLFxuICAgICAgICAgICAgICBQZzogcGFnZVJlZixcbiAgICAgICAgICAgICAgTUNJRDogbWNpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGU3RydWN0dXJlRWxlbWVudDtcbn0oKTtcblxudmFyIFBERk51bWJlclRyZWUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QREZUcmVlKSB7XG4gIF9pbmhlcml0cyhQREZOdW1iZXJUcmVlLCBfUERGVHJlZSk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQREZOdW1iZXJUcmVlKTtcblxuICBmdW5jdGlvbiBQREZOdW1iZXJUcmVlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOdW1iZXJUcmVlKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZOdW1iZXJUcmVlLCBbe1xuICAgIGtleTogXCJfY29tcGFyZUtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbXBhcmVLZXlzKGEsIGIpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChhKSAtIHBhcnNlSW50KGIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfa2V5c05hbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2tleXNOYW1lKCkge1xuICAgICAgcmV0dXJuIFwiTnVtc1wiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZGF0YUZvcktleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGF0YUZvcktleShrKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoayk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk51bWJlclRyZWU7XG59KFBERlRyZWUpO1xuXG52YXIgTWFya2luZ3NNaXhpbiA9IHtcbiAgaW5pdE1hcmtpbmdzOiBmdW5jdGlvbiBpbml0TWFya2luZ3Mob3B0aW9ucykge1xuICAgIHRoaXMuc3RydWN0Q2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChvcHRpb25zLnRhZ2dlZCkge1xuICAgICAgdGhpcy5nZXRNYXJrSW5mb0RpY3Rpb25hcnkoKS5kYXRhLk1hcmtlZCA9IHRydWU7XG4gICAgICB0aGlzLmdldFN0cnVjdFRyZWVSb290KCk7XG4gICAgfVxuICB9LFxuICBtYXJrQ29udGVudDogZnVuY3Rpb24gbWFya0NvbnRlbnQodGFnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICBpZiAodGFnID09PSAnQXJ0aWZhY3QnIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5tY2lkKSB7XG4gICAgICB2YXIgdG9DbG9zZSA9IDA7XG4gICAgICB0aGlzLnBhZ2UubWFya2luZ3MuZm9yRWFjaChmdW5jdGlvbiAobWFya2luZykge1xuICAgICAgICBpZiAodG9DbG9zZSB8fCBtYXJraW5nLnN0cnVjdENvbnRlbnQgfHwgbWFya2luZy50YWcgPT09ICdBcnRpZmFjdCcpIHtcbiAgICAgICAgICB0b0Nsb3NlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB3aGlsZSAodG9DbG9zZS0tKSB7XG4gICAgICAgIHRoaXMuZW5kTWFya2VkQ29udGVudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgdGhpcy5wYWdlLm1hcmtpbmdzLnB1c2goe1xuICAgICAgICB0YWc6IHRhZ1xuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZENvbnRlbnQoXCIvXCIuY29uY2F0KHRhZywgXCIgQk1DXCIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMucGFnZS5tYXJraW5ncy5wdXNoKHtcbiAgICAgIHRhZzogdGFnLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICAgIHZhciBkaWN0aW9uYXJ5ID0ge307XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWNpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRpY3Rpb25hcnkuTUNJRCA9IG9wdGlvbnMubWNpZDtcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnQXJ0aWZhY3QnKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGljdGlvbmFyeS5UeXBlID0gb3B0aW9ucy50eXBlO1xuICAgICAgfVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmJib3gpKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuQkJveCA9IFtvcHRpb25zLmJib3hbMF0sIHRoaXMucGFnZS5oZWlnaHQgLSBvcHRpb25zLmJib3hbM10sIG9wdGlvbnMuYmJveFsyXSwgdGhpcy5wYWdlLmhlaWdodCAtIG9wdGlvbnMuYmJveFsxXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYXR0YWNoZWQpICYmIG9wdGlvbnMuYXR0YWNoZWQuZXZlcnkoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG4gICAgICB9KSkge1xuICAgICAgICBkaWN0aW9uYXJ5LkF0dGFjaGVkID0gb3B0aW9ucy5hdHRhY2hlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFnID09PSAnU3BhbicpIHtcbiAgICAgIGlmIChvcHRpb25zLmxhbmcpIHtcbiAgICAgICAgZGljdGlvbmFyeS5MYW5nID0gbmV3IFN0cmluZyhvcHRpb25zLmxhbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbHQpIHtcbiAgICAgICAgZGljdGlvbmFyeS5BbHQgPSBuZXcgU3RyaW5nKG9wdGlvbnMuYWx0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZXhwYW5kZWQpIHtcbiAgICAgICAgZGljdGlvbmFyeS5FID0gbmV3IFN0cmluZyhvcHRpb25zLmV4cGFuZGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWN0dWFsKSB7XG4gICAgICAgIGRpY3Rpb25hcnkuQWN0dWFsVGV4dCA9IG5ldyBTdHJpbmcob3B0aW9ucy5hY3R1YWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRkQ29udGVudChcIi9cIi5jb25jYXQodGFnLCBcIiBcIikuY29uY2F0KFBERk9iamVjdC5jb252ZXJ0KGRpY3Rpb25hcnkpLCBcIiBCRENcIikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtYXJrU3RydWN0dXJlQ29udGVudDogZnVuY3Rpb24gbWFya1N0cnVjdHVyZUNvbnRlbnQodGFnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBwYWdlU3RydWN0UGFyZW50cyA9IHRoaXMuZ2V0U3RydWN0UGFyZW50VHJlZSgpLmdldCh0aGlzLnBhZ2Uuc3RydWN0UGFyZW50VHJlZUtleSk7XG4gICAgdmFyIG1jaWQgPSBwYWdlU3RydWN0UGFyZW50cy5sZW5ndGg7XG4gICAgcGFnZVN0cnVjdFBhcmVudHMucHVzaChudWxsKTtcbiAgICB0aGlzLm1hcmtDb250ZW50KHRhZywgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWNpZDogbWNpZFxuICAgIH0pKTtcbiAgICB2YXIgc3RydWN0Q29udGVudCA9IG5ldyBQREZTdHJ1Y3R1cmVDb250ZW50KHRoaXMucGFnZS5kaWN0aW9uYXJ5LCBtY2lkKTtcbiAgICB0aGlzLnBhZ2UubWFya2luZ3Muc2xpY2UoLTEpWzBdLnN0cnVjdENvbnRlbnQgPSBzdHJ1Y3RDb250ZW50O1xuICAgIHJldHVybiBzdHJ1Y3RDb250ZW50O1xuICB9LFxuICBlbmRNYXJrZWRDb250ZW50OiBmdW5jdGlvbiBlbmRNYXJrZWRDb250ZW50KCkge1xuICAgIHRoaXMucGFnZS5tYXJraW5ncy5wb3AoKTtcbiAgICB0aGlzLmFkZENvbnRlbnQoJ0VNQycpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzdHJ1Y3Q6IGZ1bmN0aW9uIHN0cnVjdCh0eXBlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciBjaGlsZHJlbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERlN0cnVjdHVyZUVsZW1lbnQodGhpcywgdHlwZSwgb3B0aW9ucywgY2hpbGRyZW4pO1xuICB9LFxuICBhZGRTdHJ1Y3R1cmU6IGZ1bmN0aW9uIGFkZFN0cnVjdHVyZShzdHJ1Y3RFbGVtKSB7XG4gICAgdmFyIHN0cnVjdFRyZWVSb290ID0gdGhpcy5nZXRTdHJ1Y3RUcmVlUm9vdCgpO1xuICAgIHN0cnVjdEVsZW0uc2V0UGFyZW50KHN0cnVjdFRyZWVSb290KTtcbiAgICBzdHJ1Y3RFbGVtLnNldEF0dGFjaGVkKCk7XG4gICAgdGhpcy5zdHJ1Y3RDaGlsZHJlbi5wdXNoKHN0cnVjdEVsZW0pO1xuXG4gICAgaWYgKCFzdHJ1Y3RUcmVlUm9vdC5kYXRhLkspIHtcbiAgICAgIHN0cnVjdFRyZWVSb290LmRhdGEuSyA9IFtdO1xuICAgIH1cblxuICAgIHN0cnVjdFRyZWVSb290LmRhdGEuSy5wdXNoKHN0cnVjdEVsZW0uZGljdGlvbmFyeSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGluaXRQYWdlTWFya2luZ3M6IGZ1bmN0aW9uIGluaXRQYWdlTWFya2luZ3MocGFnZU1hcmtpbmdzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHBhZ2VNYXJraW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChtYXJraW5nKSB7XG4gICAgICBpZiAobWFya2luZy5zdHJ1Y3RDb250ZW50KSB7XG4gICAgICAgIHZhciBzdHJ1Y3RDb250ZW50ID0gbWFya2luZy5zdHJ1Y3RDb250ZW50O1xuXG4gICAgICAgIHZhciBuZXdTdHJ1Y3RDb250ZW50ID0gX3RoaXMubWFya1N0cnVjdHVyZUNvbnRlbnQobWFya2luZy50YWcsIG1hcmtpbmcub3B0aW9ucyk7XG5cbiAgICAgICAgc3RydWN0Q29udGVudC5wdXNoKG5ld1N0cnVjdENvbnRlbnQpO1xuICAgICAgICBfdGhpcy5wYWdlLm1hcmtpbmdzLnNsaWNlKC0xKVswXS5zdHJ1Y3RDb250ZW50ID0gc3RydWN0Q29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLm1hcmtDb250ZW50KG1hcmtpbmcudGFnLCBtYXJraW5nLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICBlbmRQYWdlTWFya2luZ3M6IGZ1bmN0aW9uIGVuZFBhZ2VNYXJraW5ncyhwYWdlKSB7XG4gICAgdmFyIHBhZ2VNYXJraW5ncyA9IHBhZ2UubWFya2luZ3M7XG4gICAgcGFnZU1hcmtpbmdzLmZvckVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhZ2Uud3JpdGUoJ0VNQycpO1xuICAgIH0pO1xuICAgIHBhZ2UubWFya2luZ3MgPSBbXTtcbiAgICByZXR1cm4gcGFnZU1hcmtpbmdzO1xuICB9LFxuICBnZXRNYXJrSW5mb0RpY3Rpb25hcnk6IGZ1bmN0aW9uIGdldE1hcmtJbmZvRGljdGlvbmFyeSgpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5NYXJrSW5mbykge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvID0gdGhpcy5yZWYoe30pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yb290LmRhdGEuTWFya0luZm87XG4gIH0sXG4gIGdldFN0cnVjdFRyZWVSb290OiBmdW5jdGlvbiBnZXRTdHJ1Y3RUcmVlUm9vdCgpIHtcbiAgICBpZiAoIXRoaXMuX3Jvb3QuZGF0YS5TdHJ1Y3RUcmVlUm9vdCkge1xuICAgICAgdGhpcy5fcm9vdC5kYXRhLlN0cnVjdFRyZWVSb290ID0gdGhpcy5yZWYoe1xuICAgICAgICBUeXBlOiAnU3RydWN0VHJlZVJvb3QnLFxuICAgICAgICBQYXJlbnRUcmVlOiBuZXcgUERGTnVtYmVyVHJlZSgpLFxuICAgICAgICBQYXJlbnRUcmVlTmV4dEtleTogMFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QuZGF0YS5TdHJ1Y3RUcmVlUm9vdDtcbiAgfSxcbiAgZ2V0U3RydWN0UGFyZW50VHJlZTogZnVuY3Rpb24gZ2V0U3RydWN0UGFyZW50VHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdHJ1Y3RUcmVlUm9vdCgpLmRhdGEuUGFyZW50VHJlZTtcbiAgfSxcbiAgY3JlYXRlU3RydWN0UGFyZW50VHJlZU5leHRLZXk6IGZ1bmN0aW9uIGNyZWF0ZVN0cnVjdFBhcmVudFRyZWVOZXh0S2V5KCkge1xuICAgIC8vIGluaXRpYWxpc2UgdGhlIE1hcmtJbmZvIGRpY3Rpb25hcnlcbiAgICB0aGlzLmdldE1hcmtJbmZvRGljdGlvbmFyeSgpO1xuICAgIHZhciBzdHJ1Y3RUcmVlUm9vdCA9IHRoaXMuZ2V0U3RydWN0VHJlZVJvb3QoKTtcbiAgICB2YXIga2V5ID0gc3RydWN0VHJlZVJvb3QuZGF0YS5QYXJlbnRUcmVlTmV4dEtleSsrO1xuICAgIHN0cnVjdFRyZWVSb290LmRhdGEuUGFyZW50VHJlZS5hZGQoa2V5LCBbXSk7XG4gICAgcmV0dXJuIGtleTtcbiAgfSxcbiAgZW5kTWFya2luZ3M6IGZ1bmN0aW9uIGVuZE1hcmtpbmdzKCkge1xuICAgIHZhciBzdHJ1Y3RUcmVlUm9vdCA9IHRoaXMuX3Jvb3QuZGF0YS5TdHJ1Y3RUcmVlUm9vdDtcblxuICAgIGlmIChzdHJ1Y3RUcmVlUm9vdCkge1xuICAgICAgc3RydWN0VHJlZVJvb3QuZW5kKCk7XG4gICAgICB0aGlzLnN0cnVjdENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKHN0cnVjdEVsZW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cnVjdEVsZW0uZW5kKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcm9vdC5kYXRhLk1hcmtJbmZvKSB7XG4gICAgICB0aGlzLl9yb290LmRhdGEuTWFya0luZm8uZW5kKCk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgRklFTERfRkxBR1MgPSB7XG4gIHJlYWRPbmx5OiAxLFxuICByZXF1aXJlZDogMixcbiAgbm9FeHBvcnQ6IDQsXG4gIG11bHRpbGluZTogMHgxMDAwLFxuICBwYXNzd29yZDogMHgyMDAwLFxuICB0b2dnbGVUb09mZkJ1dHRvbjogMHg0MDAwLFxuICByYWRpb0J1dHRvbjogMHg4MDAwLFxuICBwdXNoQnV0dG9uOiAweDEwMDAwLFxuICBjb21ibzogMHgyMDAwMCxcbiAgZWRpdDogMHg0MDAwMCxcbiAgc29ydDogMHg4MDAwMCxcbiAgbXVsdGlTZWxlY3Q6IDB4MjAwMDAwLFxuICBub1NwZWxsOiAweDQwMDAwMFxufTtcbnZhciBGSUVMRF9KVVNUSUZZID0ge1xuICBsZWZ0OiAwLFxuICBjZW50ZXI6IDEsXG4gIHJpZ2h0OiAyXG59O1xudmFyIFZBTFVFX01BUCA9IHtcbiAgdmFsdWU6ICdWJyxcbiAgZGVmYXVsdFZhbHVlOiAnRFYnXG59O1xudmFyIEZPUk1BVF9TUEVDSUFMID0ge1xuICB6aXA6ICcwJyxcbiAgemlwUGx1czQ6ICcxJyxcbiAgemlwNDogJzEnLFxuICBwaG9uZTogJzInLFxuICBzc246ICczJ1xufTtcbnZhciBGT1JNQVRfREVGQVVMVCA9IHtcbiAgbnVtYmVyOiB7XG4gICAgbkRlYzogMCxcbiAgICBzZXBDb21tYTogZmFsc2UsXG4gICAgbmVnU3R5bGU6ICdNaW51c0JsYWNrJyxcbiAgICBjdXJyZW5jeTogJycsXG4gICAgY3VycmVuY3lQcmVwZW5kOiB0cnVlXG4gIH0sXG4gIHBlcmNlbnQ6IHtcbiAgICBuRGVjOiAwLFxuICAgIHNlcENvbW1hOiBmYWxzZVxuICB9XG59O1xudmFyIEFjcm9Gb3JtTWl4aW4gPSB7XG4gIC8qKlxyXG4gICAqIE11c3QgY2FsbCBpZiBhZGRpbmcgQWNyb0Zvcm1zIHRvIGEgZG9jdW1lbnQuIE11c3QgYWxzbyBjYWxsIGZvbnQoKSBiZWZvcmVcclxuICAgKiB0aGlzIG1ldGhvZCB0byBzZXQgdGhlIGRlZmF1bHQgZm9udC5cclxuICAgKi9cbiAgaW5pdEZvcm06IGZ1bmN0aW9uIGluaXRGb3JtKCkge1xuICAgIGlmICghdGhpcy5fZm9udCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNldCBhIGZvbnQgYmVmb3JlIGNhbGxpbmcgaW5pdEZvcm0gbWV0aG9kJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fYWNyb2Zvcm0gPSB7XG4gICAgICBmb250czoge30sXG4gICAgICBkZWZhdWx0Rm9udDogdGhpcy5fZm9udC5uYW1lXG4gICAgfTtcbiAgICB0aGlzLl9hY3JvZm9ybS5mb250c1t0aGlzLl9mb250LmlkXSA9IHRoaXMuX2ZvbnQucmVmKCk7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBGaWVsZHM6IFtdLFxuICAgICAgTmVlZEFwcGVhcmFuY2VzOiB0cnVlLFxuICAgICAgREE6IG5ldyBTdHJpbmcoXCIvXCIuY29uY2F0KHRoaXMuX2ZvbnQuaWQsIFwiIDAgVGYgMCBnXCIpKSxcbiAgICAgIERSOiB7XG4gICAgICAgIEZvbnQ6IHt9XG4gICAgICB9XG4gICAgfTtcbiAgICBkYXRhLkRSLkZvbnRbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgIHZhciBBY3JvRm9ybSA9IHRoaXMucmVmKGRhdGEpO1xuICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybSA9IEFjcm9Gb3JtO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IGRvY3VtZW50LmpzXHJcbiAgICovXG4gIGVuZEFjcm9Gb3JtOiBmdW5jdGlvbiBlbmRBY3JvRm9ybSgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybSkge1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyh0aGlzLl9hY3JvZm9ybS5mb250cykubGVuZ3RoICYmICF0aGlzLl9hY3JvZm9ybS5kZWZhdWx0Rm9udCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZvbnRzIHNwZWNpZmllZCBmb3IgUERGIGZvcm0nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnREaWN0ID0gdGhpcy5fcm9vdC5kYXRhLkFjcm9Gb3JtLmRhdGEuRFIuRm9udDtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2Fjcm9mb3JtLmZvbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGZvbnREaWN0W25hbWVdID0gX3RoaXMuX2Fjcm9mb3JtLmZvbnRzW25hbWVdO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybS5kYXRhLkZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZFJlZikge1xuICAgICAgICBfdGhpcy5fZW5kQ2hpbGQoZmllbGRSZWYpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybS5lbmQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2VuZENoaWxkOiBmdW5jdGlvbiBfZW5kQ2hpbGQocmVmKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWYuZGF0YS5LaWRzKSkge1xuICAgICAgcmVmLmRhdGEuS2lkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZFJlZikge1xuICAgICAgICBfdGhpczIuX2VuZENoaWxkKGNoaWxkUmVmKTtcbiAgICAgIH0pO1xuICAgICAgcmVmLmVuZCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIGFkZHMgYSBmb3JtIGZpZWxkIHRvIHRoZSBkb2N1bWVudC4gRm9ybSBmaWVsZHMgYXJlIGludGVybWVkaWF0ZVxyXG4gICAqIG5vZGVzIGluIGEgUERGIGZvcm0gdGhhdCBhcmUgdXNlZCB0byBzcGVjaWZ5IGZvcm0gbmFtZSBoZWlyYXJjaHkgYW5kIGZvcm1cclxuICAgKiB2YWx1ZSBkZWZhdWx0cy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGZpZWxkIG5hbWUgKFQgYXR0cmlidXRlIGluIGZpZWxkIGRpY3Rpb25hcnkpXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIC0gb3RoZXIgYXR0cmlidXRlcyB0byBpbmNsdWRlIGluIGZpZWxkIGRpY3Rpb25hcnlcclxuICAgKi9cbiAgZm9ybUZpZWxkOiBmdW5jdGlvbiBmb3JtRmllbGQobmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIHZhciBmaWVsZERpY3QgPSB0aGlzLl9maWVsZERpY3QobmFtZSwgbnVsbCwgb3B0aW9ucyk7XG5cbiAgICB2YXIgZmllbGRSZWYgPSB0aGlzLnJlZihmaWVsZERpY3QpO1xuXG4gICAgdGhpcy5fYWRkVG9QYXJlbnQoZmllbGRSZWYpO1xuXG4gICAgcmV0dXJuIGZpZWxkUmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIGFkZHMgYSBGb3JtIEFubm90YXRpb24gdG8gdGhlIGRvY3VtZW50LiBGb3JtIGFubm90YXRpb25zIGFyZVxyXG4gICAqIGNhbGxlZCBXaWRnZXQgYW5ub3RhdGlvbnMgaW50ZXJuYWxseSB3aXRoaW4gYSBQREYgZmlsZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIGZvcm0gZmllbGQgbmFtZSAoVCBhdHRyaWJ1dGUgb2Ygd2lkZ2V0IGFubm90YXRpb25cclxuICAgKiBkaWN0aW9uYXJ5KVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgKi9cbiAgZm9ybUFubm90YXRpb246IGZ1bmN0aW9uIGZvcm1Bbm5vdGF0aW9uKG5hbWUsIHR5cGUsIHgsIHksIHcsIGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDoge307XG5cbiAgICB2YXIgZmllbGREaWN0ID0gdGhpcy5fZmllbGREaWN0KG5hbWUsIHR5cGUsIG9wdGlvbnMpO1xuXG4gICAgZmllbGREaWN0LlN1YnR5cGUgPSAnV2lkZ2V0JztcblxuICAgIGlmIChmaWVsZERpY3QuRiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWVsZERpY3QuRiA9IDQ7IC8vIHByaW50IHRoZSBhbm5vdGF0aW9uXG4gICAgfSAvLyBBZGQgRmllbGQgYW5ub3QgdG8gcGFnZSwgYW5kIGdldCBpdCdzIHJlZlxuXG5cbiAgICB0aGlzLmFubm90YXRlKHgsIHksIHcsIGgsIGZpZWxkRGljdCk7XG4gICAgdmFyIGFubm90UmVmID0gdGhpcy5wYWdlLmFubm90YXRpb25zW3RoaXMucGFnZS5hbm5vdGF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gdGhpcy5fYWRkVG9QYXJlbnQoYW5ub3RSZWYpO1xuICB9LFxuICBmb3JtVGV4dDogZnVuY3Rpb24gZm9ybVRleHQobmFtZSwgeCwgeSwgdywgaCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAndGV4dCcsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtUHVzaEJ1dHRvbjogZnVuY3Rpb24gZm9ybVB1c2hCdXR0b24obmFtZSwgeCwgeSwgdywgaCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAncHVzaEJ1dHRvbicsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtQ29tYm86IGZ1bmN0aW9uIGZvcm1Db21ibyhuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdjb21ibycsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtTGlzdDogZnVuY3Rpb24gZm9ybUxpc3QobmFtZSwgeCwgeSwgdywgaCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB7fTtcbiAgICByZXR1cm4gdGhpcy5mb3JtQW5ub3RhdGlvbihuYW1lLCAnbGlzdCcsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtUmFkaW9CdXR0b246IGZ1bmN0aW9uIGZvcm1SYWRpb0J1dHRvbihuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdyYWRpb0J1dHRvbicsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBmb3JtQ2hlY2tib3g6IGZ1bmN0aW9uIGZvcm1DaGVja2JveChuYW1lLCB4LCB5LCB3LCBoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHt9O1xuICAgIHJldHVybiB0aGlzLmZvcm1Bbm5vdGF0aW9uKG5hbWUsICdjaGVja2JveCcsIHgsIHksIHcsIGgsIG9wdGlvbnMpO1xuICB9LFxuICBfYWRkVG9QYXJlbnQ6IGZ1bmN0aW9uIF9hZGRUb1BhcmVudChmaWVsZFJlZikge1xuICAgIHZhciBwYXJlbnQgPSBmaWVsZFJlZi5kYXRhLlBhcmVudDtcblxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGlmICghcGFyZW50LmRhdGEuS2lkcykge1xuICAgICAgICBwYXJlbnQuZGF0YS5LaWRzID0gW107XG4gICAgICB9XG5cbiAgICAgIHBhcmVudC5kYXRhLktpZHMucHVzaChmaWVsZFJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5BY3JvRm9ybS5kYXRhLkZpZWxkcy5wdXNoKGZpZWxkUmVmKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2ZpZWxkRGljdDogZnVuY3Rpb24gX2ZpZWxkRGljdChuYW1lLCB0eXBlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCF0aGlzLl9hY3JvZm9ybSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIGRvY3VtZW50LmluaXRGb3JtcygpIG1ldGhvZCBiZWZvcmUgYWRkaW5nIGZvcm0gZWxlbWVudHMgdG8gZG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICB2YXIgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXG4gICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlVHlwZSh0eXBlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUZsYWdzKG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlSnVzdGlmeShvcHRzKTtcbiAgICBvcHRzID0gdGhpcy5fcmVzb2x2ZUZvbnQob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX3Jlc29sdmVTdHJpbmdzKG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlQ29sb3JzKG9wdHMpO1xuICAgIG9wdHMgPSB0aGlzLl9yZXNvbHZlRm9ybWF0KG9wdHMpO1xuICAgIG9wdHMuVCA9IG5ldyBTdHJpbmcobmFtZSk7XG5cbiAgICBpZiAob3B0cy5wYXJlbnQpIHtcbiAgICAgIG9wdHMuUGFyZW50ID0gb3B0cy5wYXJlbnQ7XG4gICAgICBkZWxldGUgb3B0cy5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdHM7XG4gIH0sXG4gIF9yZXNvbHZlVHlwZTogZnVuY3Rpb24gX3Jlc29sdmVUeXBlKHR5cGUsIG9wdHMpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICBvcHRzLkZUID0gJ1R4JztcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwdXNoQnV0dG9uJykge1xuICAgICAgb3B0cy5GVCA9ICdCdG4nO1xuICAgICAgb3B0cy5wdXNoQnV0dG9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdyYWRpb0J1dHRvbicpIHtcbiAgICAgIG9wdHMuRlQgPSAnQnRuJztcbiAgICAgIG9wdHMucmFkaW9CdXR0b24gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgb3B0cy5GVCA9ICdCdG4nO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NvbWJvJykge1xuICAgICAgb3B0cy5GVCA9ICdDaCc7XG4gICAgICBvcHRzLmNvbWJvID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaXN0Jykge1xuICAgICAgb3B0cy5GVCA9ICdDaCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZm9ybSBhbm5vdGF0aW9uIHR5cGUgJ1wiLmNvbmNhdCh0eXBlLCBcIidcIikpO1xuICAgIH1cblxuICAgIHJldHVybiBvcHRzO1xuICB9LFxuICBfcmVzb2x2ZUZvcm1hdDogZnVuY3Rpb24gX3Jlc29sdmVGb3JtYXQob3B0cykge1xuICAgIHZhciBmID0gb3B0cy5mb3JtYXQ7XG5cbiAgICBpZiAoZiAmJiBmLnR5cGUpIHtcbiAgICAgIHZhciBmbktleXN0cm9rZTtcbiAgICAgIHZhciBmbkZvcm1hdDtcbiAgICAgIHZhciBwYXJhbXMgPSAnJztcblxuICAgICAgaWYgKEZPUk1BVF9TUEVDSUFMW2YudHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmbktleXN0cm9rZSA9IFwiQUZTcGVjaWFsX0tleXN0cm9rZVwiO1xuICAgICAgICBmbkZvcm1hdCA9IFwiQUZTcGVjaWFsX0Zvcm1hdFwiO1xuICAgICAgICBwYXJhbXMgPSBGT1JNQVRfU1BFQ0lBTFtmLnR5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IGYudHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGYudHlwZS5zbGljZSgxKTtcbiAgICAgICAgZm5LZXlzdHJva2UgPSBcIkFGXCIuY29uY2F0KGZvcm1hdCwgXCJfS2V5c3Ryb2tlXCIpO1xuICAgICAgICBmbkZvcm1hdCA9IFwiQUZcIi5jb25jYXQoZm9ybWF0LCBcIl9Gb3JtYXRcIik7XG5cbiAgICAgICAgaWYgKGYudHlwZSA9PT0gJ2RhdGUnKSB7XG4gICAgICAgICAgZm5LZXlzdHJva2UgKz0gJ0V4JztcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoZi5wYXJhbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoZi5wYXJhbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHZhciBwID0gT2JqZWN0LmFzc2lnbih7fSwgRk9STUFUX0RFRkFVTFQubnVtYmVyLCBmKTtcbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoW1N0cmluZyhwLm5EZWMpLCBwLnNlcENvbW1hID8gJzAnIDogJzEnLCAnXCInICsgcC5uZWdTdHlsZSArICdcIicsICdudWxsJywgJ1wiJyArIHAuY3VycmVuY3kgKyAnXCInLCBTdHJpbmcocC5jdXJyZW5jeVByZXBlbmQpXS5qb2luKCcsJykpO1xuICAgICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gJ3BlcmNlbnQnKSB7XG4gICAgICAgICAgdmFyIF9wID0gT2JqZWN0LmFzc2lnbih7fSwgRk9STUFUX0RFRkFVTFQucGVyY2VudCwgZik7XG5cbiAgICAgICAgICBwYXJhbXMgPSBTdHJpbmcoW1N0cmluZyhfcC5uRGVjKSwgX3Auc2VwQ29tbWEgPyAnMCcgOiAnMSddLmpvaW4oJywnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0cy5BQSA9IG9wdHMuQUEgPyBvcHRzLkFBIDoge307XG4gICAgICBvcHRzLkFBLksgPSB7XG4gICAgICAgIFM6ICdKYXZhU2NyaXB0JyxcbiAgICAgICAgSlM6IG5ldyBTdHJpbmcoXCJcIi5jb25jYXQoZm5LZXlzdHJva2UsIFwiKFwiKS5jb25jYXQocGFyYW1zLCBcIik7XCIpKVxuICAgICAgfTtcbiAgICAgIG9wdHMuQUEuRiA9IHtcbiAgICAgICAgUzogJ0phdmFTY3JpcHQnLFxuICAgICAgICBKUzogbmV3IFN0cmluZyhcIlwiLmNvbmNhdChmbkZvcm1hdCwgXCIoXCIpLmNvbmNhdChwYXJhbXMsIFwiKTtcIikpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlbGV0ZSBvcHRzLmZvcm1hdDtcbiAgICByZXR1cm4gb3B0cztcbiAgfSxcbiAgX3Jlc29sdmVDb2xvcnM6IGZ1bmN0aW9uIF9yZXNvbHZlQ29sb3JzKG9wdHMpIHtcbiAgICB2YXIgY29sb3IgPSB0aGlzLl9ub3JtYWxpemVDb2xvcihvcHRzLmJhY2tncm91bmRDb2xvcik7XG5cbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGlmICghb3B0cy5NSykge1xuICAgICAgICBvcHRzLk1LID0ge307XG4gICAgICB9XG5cbiAgICAgIG9wdHMuTUsuQkcgPSBjb2xvcjtcbiAgICB9XG5cbiAgICBjb2xvciA9IHRoaXMuX25vcm1hbGl6ZUNvbG9yKG9wdHMuYm9yZGVyQ29sb3IpO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBpZiAoIW9wdHMuTUspIHtcbiAgICAgICAgb3B0cy5NSyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBvcHRzLk1LLkJDID0gY29sb3I7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdHMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRlbGV0ZSBvcHRzLmJvcmRlckNvbG9yO1xuICAgIHJldHVybiBvcHRzO1xuICB9LFxuICBfcmVzb2x2ZUZsYWdzOiBmdW5jdGlvbiBfcmVzb2x2ZUZsYWdzKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcbiAgICBPYmplY3Qua2V5cyhvcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChGSUVMRF9GTEFHU1trZXldKSB7XG4gICAgICAgIHJlc3VsdCB8PSBGSUVMRF9GTEFHU1trZXldO1xuICAgICAgICBkZWxldGUgb3B0aW9uc1trZXldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3VsdCAhPT0gMCkge1xuICAgICAgb3B0aW9ucy5GZiA9IG9wdGlvbnMuRmYgPyBvcHRpb25zLkZmIDogMDtcbiAgICAgIG9wdGlvbnMuRmYgfD0gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuICBfcmVzb2x2ZUp1c3RpZnk6IGZ1bmN0aW9uIF9yZXNvbHZlSnVzdGlmeShvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG5cbiAgICBpZiAob3B0aW9ucy5hbGlnbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIEZJRUxEX0pVU1RJRllbb3B0aW9ucy5hbGlnbl0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJlc3VsdCA9IEZJRUxEX0pVU1RJRllbb3B0aW9ucy5hbGlnbl07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvcHRpb25zLmFsaWduO1xuICAgIH1cblxuICAgIGlmIChyZXN1bHQgIT09IDApIHtcbiAgICAgIG9wdGlvbnMuUSA9IHJlc3VsdDsgLy8gZGVmYXVsdFxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9LFxuICBfcmVzb2x2ZUZvbnQ6IGZ1bmN0aW9uIF9yZXNvbHZlRm9udChvcHRpb25zKSB7XG4gICAgLy8gYWRkIGN1cnJlbnQgZm9udCB0byBkb2N1bWVudC1sZXZlbCBBY3JvRm9ybSBkaWN0IGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLl9hY3JvZm9ybS5mb250c1t0aGlzLl9mb250LmlkXSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fYWNyb2Zvcm0uZm9udHNbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgIH0gLy8gYWRkIGN1cnJlbnQgZm9udCB0byBmaWVsZCdzIHJlc291cmNlIGRpY3QgKFJEKSBpZiBub3QgdGhlIGRlZmF1bHQgYWNyb2Zvcm0gZm9udFxuXG5cbiAgICBpZiAodGhpcy5fYWNyb2Zvcm0uZGVmYXVsdEZvbnQgIT09IHRoaXMuX2ZvbnQubmFtZSkge1xuICAgICAgb3B0aW9ucy5EUiA9IHtcbiAgICAgICAgRm9udDoge31cbiAgICAgIH07IC8vIEdldCB0aGUgZm9udFNpemUgb3B0aW9uLiBJZiBub3Qgc2V0IHVzZSBhdXRvIHNpemluZ1xuXG4gICAgICB2YXIgZm9udFNpemUgPSBvcHRpb25zLmZvbnRTaXplIHx8IDA7XG4gICAgICBvcHRpb25zLkRSLkZvbnRbdGhpcy5fZm9udC5pZF0gPSB0aGlzLl9mb250LnJlZigpO1xuICAgICAgb3B0aW9ucy5EQSA9IG5ldyBTdHJpbmcoXCIvXCIuY29uY2F0KHRoaXMuX2ZvbnQuaWQsIFwiIFwiKS5jb25jYXQoZm9udFNpemUsIFwiIFRmIDAgZ1wiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sXG4gIF9yZXNvbHZlU3RyaW5nczogZnVuY3Rpb24gX3Jlc29sdmVTdHJpbmdzKG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZWN0ID0gW107XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRDaG9pY2VzKGEpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgYVtpZHhdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2VsZWN0LnB1c2gobmV3IFN0cmluZyhhW2lkeF0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0LnB1c2goYVtpZHhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBlbmRDaG9pY2VzKG9wdGlvbnMuT3B0KTtcblxuICAgIGlmIChvcHRpb25zLnNlbGVjdCkge1xuICAgICAgYXBwZW5kQ2hvaWNlcyhvcHRpb25zLnNlbGVjdCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5zZWxlY3Q7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdC5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnMuT3B0ID0gc2VsZWN0O1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKFZBTFVFX01BUCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAob3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9uc1tWQUxVRV9NQVBba2V5XV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgWydWJywgJ0RWJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnNba2V5XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gbmV3IFN0cmluZyhvcHRpb25zW2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMuTUsgJiYgb3B0aW9ucy5NSy5DQSkge1xuICAgICAgb3B0aW9ucy5NSy5DQSA9IG5ldyBTdHJpbmcob3B0aW9ucy5NSy5DQSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgIG9wdGlvbnMuTUsgPSBvcHRpb25zLk1LID8gb3B0aW9ucy5NSyA6IHt9O1xuICAgICAgb3B0aW9ucy5NSy5DQSA9IG5ldyBTdHJpbmcob3B0aW9ucy5sYWJlbCk7XG4gICAgICBkZWxldGUgb3B0aW9ucy5sYWJlbDtcbiAgICB9XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxufTtcblxudmFyIEF0dGFjaG1lbnRzTWl4aW4gPSB7XG4gIC8qKlxyXG4gICAqIEVtYmVkIGNvbnRlbnRzIG9mIGBzcmNgIGluIFBERlxyXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXIgfCBzdHJpbmd9IHNyYyBpbnB1dCBCdWZmZXIsIEFycmF5QnVmZmVyLCBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb3IgcGF0aCB0byBmaWxlXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgKiAgKiBvcHRpb25zLm5hbWU6IGZpbGVuYW1lIHRvIGJlIHNob3duIGluIFBERiwgd2lsbCB1c2UgYHNyY2AgaWYgbm9uZSBzZXRcclxuICAgKiAgKiBvcHRpb25zLnR5cGU6IGZpbGV0eXBlIHRvIGJlIHNob3duIGluIFBERlxyXG4gICAqICAqIG9wdGlvbnMuZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIHRvIGJlIHNob3duIGluIFBERlxyXG4gICAqICAqIG9wdGlvbnMuaGlkZGVuOiBpZiB0cnVlLCBkbyBub3QgYWRkIGF0dGFjaG1lbnQgdG8gRW1iZWRkZWRGaWxlcyBkaWN0aW9uYXJ5LiBVc2VmdWwgZm9yIGZpbGUgYXR0YWNobWVudCBhbm5vdGF0aW9uc1xyXG4gICAqICAqIG9wdGlvbnMuY3JlYXRpb25EYXRlOiBvdmVycmlkZSBjcmVhdGlvbiBkYXRlXHJcbiAgICogICogb3B0aW9ucy5tb2RpZmllZERhdGU6IG92ZXJyaWRlIG1vZGlmaWVkIGRhdGVcclxuICAgKiBAcmV0dXJucyBmaWxlc3BlYyByZWZlcmVuY2VcclxuICAgKi9cbiAgZmlsZTogZnVuY3Rpb24gZmlsZShzcmMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IHNyYztcbiAgICB2YXIgcmVmQm9keSA9IHtcbiAgICAgIFR5cGU6ICdFbWJlZGRlZEZpbGUnLFxuICAgICAgUGFyYW1zOiB7fVxuICAgIH07XG4gICAgdmFyIGRhdGE7XG5cbiAgICBpZiAoIXNyYykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzcmMgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzcmMpKSB7XG4gICAgICBkYXRhID0gc3JjO1xuICAgIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShzcmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICBpZiAobWF0Y2ggPSAvXmRhdGE6KC4qKTtiYXNlNjQsKC4qKSQvLmV4ZWMoc3JjKSkge1xuICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICByZWZCb2R5LlN1YnR5cGUgPSBtYXRjaFsxXS5yZXBsYWNlKCcvJywgJyMyRicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKG1hdGNoWzJdLCAnYmFzZTY0Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gZnMucmVhZEZpbGVTeW5jKHNyYyk7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlYWQgY29udGVudHMgb2YgZmlsZSBhdCBmaWxlcGF0aCBcIi5jb25jYXQoc3JjKSk7XG4gICAgICAgIH0gLy8gdXBkYXRlIENyZWF0aW9uRGF0ZSBhbmQgTW9kRGF0ZVxuXG5cbiAgICAgICAgdmFyIF9mcyRzdGF0U3luYyA9IGZzLnN0YXRTeW5jKHNyYyksXG4gICAgICAgICAgICBiaXJ0aHRpbWUgPSBfZnMkc3RhdFN5bmMuYmlydGh0aW1lLFxuICAgICAgICAgICAgY3RpbWUgPSBfZnMkc3RhdFN5bmMuY3RpbWU7XG5cbiAgICAgICAgcmVmQm9keS5QYXJhbXMuQ3JlYXRpb25EYXRlID0gYmlydGh0aW1lO1xuICAgICAgICByZWZCb2R5LlBhcmFtcy5Nb2REYXRlID0gY3RpbWU7XG4gICAgICB9XG4gICAgfSAvLyBvdmVycmlkZSBjcmVhdGlvbiBkYXRlIGFuZCBtb2RpZmllZCBkYXRlXG5cblxuICAgIGlmIChvcHRpb25zLmNyZWF0aW9uRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJlZkJvZHkuUGFyYW1zLkNyZWF0aW9uRGF0ZSA9IG9wdGlvbnMuY3JlYXRpb25EYXRlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm1vZGlmaWVkRGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJlZkJvZHkuUGFyYW1zLk1vZERhdGUgPSBvcHRpb25zLm1vZGlmaWVkRGF0ZTtcbiAgICB9IC8vIGFkZCBvcHRpb25hbCBzdWJ0eXBlXG5cblxuICAgIGlmIChvcHRpb25zLnR5cGUpIHtcbiAgICAgIHJlZkJvZHkuU3VidHlwZSA9IG9wdGlvbnMudHlwZS5yZXBsYWNlKCcvJywgJyMyRicpO1xuICAgIH0gLy8gYWRkIGNoZWNrc3VtIGFuZCBzaXplIGluZm9ybWF0aW9uXG5cblxuICAgIHZhciBjaGVja3N1bSA9IENyeXB0b0pTLk1ENShDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShuZXcgVWludDhBcnJheShkYXRhKSkpO1xuICAgIHJlZkJvZHkuUGFyYW1zLkNoZWNrU3VtID0gbmV3IFN0cmluZyhjaGVja3N1bSk7XG4gICAgcmVmQm9keS5QYXJhbXMuU2l6ZSA9IGRhdGEuYnl0ZUxlbmd0aDsgLy8gc2F2ZSBzb21lIHNwYWNlIHdoZW4gZW1iZWRkaW5nIHRoZSBzYW1lIGZpbGUgYWdhaW5cbiAgICAvLyBpZiBhIGZpbGUgd2l0aCB0aGUgc2FtZSBuYW1lIGFuZCBtZXRhZGF0YSBleGlzdHMsIHJldXNlIGl0cyByZWZlcmVuY2VcblxuICAgIHZhciByZWY7XG4gICAgaWYgKCF0aGlzLl9maWxlUmVnaXN0cnkpIHRoaXMuX2ZpbGVSZWdpc3RyeSA9IHt9O1xuICAgIHZhciBmaWxlID0gdGhpcy5fZmlsZVJlZ2lzdHJ5W29wdGlvbnMubmFtZV07XG5cbiAgICBpZiAoZmlsZSAmJiBpc0VxdWFsKHJlZkJvZHksIGZpbGUpKSB7XG4gICAgICByZWYgPSBmaWxlLnJlZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmID0gdGhpcy5yZWYocmVmQm9keSk7XG4gICAgICByZWYuZW5kKGRhdGEpO1xuICAgICAgdGhpcy5fZmlsZVJlZ2lzdHJ5W29wdGlvbnMubmFtZV0gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcmVmQm9keSksIHt9LCB7XG4gICAgICAgIHJlZjogcmVmXG4gICAgICB9KTtcbiAgICB9IC8vIGFkZCBmaWxlc3BlYyBmb3IgZW1iZWRkZWQgZmlsZVxuXG5cbiAgICB2YXIgZmlsZVNwZWNCb2R5ID0ge1xuICAgICAgVHlwZTogJ0ZpbGVzcGVjJyxcbiAgICAgIEY6IG5ldyBTdHJpbmcob3B0aW9ucy5uYW1lKSxcbiAgICAgIEVGOiB7XG4gICAgICAgIEY6IHJlZlxuICAgICAgfSxcbiAgICAgIFVGOiBuZXcgU3RyaW5nKG9wdGlvbnMubmFtZSlcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGVzY3JpcHRpb24pIHtcbiAgICAgIGZpbGVTcGVjQm9keS5EZXNjID0gbmV3IFN0cmluZyhvcHRpb25zLmRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICB2YXIgZmlsZXNwZWMgPSB0aGlzLnJlZihmaWxlU3BlY0JvZHkpO1xuICAgIGZpbGVzcGVjLmVuZCgpO1xuXG4gICAgaWYgKCFvcHRpb25zLmhpZGRlbikge1xuICAgICAgdGhpcy5hZGROYW1lZEVtYmVkZGVkRmlsZShvcHRpb25zLm5hbWUsIGZpbGVzcGVjKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsZXNwZWM7XG4gIH1cbn07XG4vKiogY2hlY2sgdHdvIGVtYmVkZGVkIGZpbGUgbWV0YWRhdGEgb2JqZWN0cyBmb3IgZXF1YWxpdHkgKi9cblxuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLlN1YnR5cGUgPT09IGIuU3VidHlwZSAmJiBhLlBhcmFtcy5DaGVja1N1bS50b1N0cmluZygpID09PSBiLlBhcmFtcy5DaGVja1N1bS50b1N0cmluZygpICYmIGEuUGFyYW1zLlNpemUgPT09IGIuUGFyYW1zLlNpemUgJiYgYS5QYXJhbXMuQ3JlYXRpb25EYXRlID09PSBiLlBhcmFtcy5DcmVhdGlvbkRhdGUgJiYgYS5QYXJhbXMuTW9kRGF0ZSA9PT0gYi5QYXJhbXMuTW9kRGF0ZTtcbn1cblxudmFyIFBERkEgPSB7XG4gIGluaXRQREZBOiBmdW5jdGlvbiBpbml0UERGQShwU3Vic2V0KSB7XG4gICAgaWYgKHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMykgPT09ICctJykge1xuICAgICAgdGhpcy5zdWJzZXRfY29uZm9ybWFuY2UgPSBwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDEpLnRvVXBwZXJDYXNlKCk7XG4gICAgICB0aGlzLnN1YnNldCA9IHBhcnNlSW50KHBTdWJzZXQuY2hhckF0KHBTdWJzZXQubGVuZ3RoIC0gMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IHRvIEJhc2ljIGNvbmZvcm1hbmNlIHdoZW4gdXNlciBkb2Vzbid0IHNwZWNpZnlcbiAgICAgIHRoaXMuc3Vic2V0X2NvbmZvcm1hbmNlID0gJ0InO1xuICAgICAgdGhpcy5zdWJzZXQgPSBwYXJzZUludChwU3Vic2V0LmNoYXJBdChwU3Vic2V0Lmxlbmd0aCAtIDEpKTtcbiAgICB9XG4gIH0sXG4gIGVuZFN1YnNldDogZnVuY3Rpb24gZW5kU3Vic2V0KCkge1xuICAgIHRoaXMuX2FkZFBkZmFNZXRhZGF0YSgpO1xuXG4gICAgdmFyIGpzUGF0aCA9IFwiXCIuY29uY2F0KF9fZGlybmFtZSwgXCIvZGF0YS9zUkdCX0lFQzYxOTY2XzJfMS5pY2NcIik7XG4gICAgdmFyIGplc3RQYXRoID0gXCJcIi5jb25jYXQoX19kaXJuYW1lLCBcIi8uLi9jb2xvcl9wcm9maWxlcy9zUkdCX0lFQzYxOTY2XzJfMS5pY2NcIik7XG5cbiAgICB0aGlzLl9hZGRDb2xvck91dHB1dEludGVudChmcy5leGlzdHNTeW5jKGpzUGF0aCkgPyBqc1BhdGggOiBqZXN0UGF0aCk7XG4gIH0sXG4gIF9hZGRDb2xvck91dHB1dEludGVudDogZnVuY3Rpb24gX2FkZENvbG9yT3V0cHV0SW50ZW50KHBJQ0NQYXRoKSB7XG4gICAgdmFyIGljY1Byb2ZpbGUgPSBmcy5yZWFkRmlsZVN5bmMocElDQ1BhdGgpO1xuICAgIHZhciBjb2xvclByb2ZpbGVSZWYgPSB0aGlzLnJlZih7XG4gICAgICBMZW5ndGg6IGljY1Byb2ZpbGUubGVuZ3RoLFxuICAgICAgTjogM1xuICAgIH0pO1xuICAgIGNvbG9yUHJvZmlsZVJlZi53cml0ZShpY2NQcm9maWxlKTtcbiAgICBjb2xvclByb2ZpbGVSZWYuZW5kKCk7XG4gICAgdmFyIGludGVudFJlZiA9IHRoaXMucmVmKHtcbiAgICAgIFR5cGU6ICdPdXRwdXRJbnRlbnQnLFxuICAgICAgUzogJ0dUU19QREZBMScsXG4gICAgICBJbmZvOiBuZXcgU3RyaW5nKCdzUkdCIElFQzYxOTY2LTIuMScpLFxuICAgICAgT3V0cHV0Q29uZGl0aW9uSWRlbnRpZmllcjogbmV3IFN0cmluZygnc1JHQiBJRUM2MTk2Ni0yLjEnKSxcbiAgICAgIERlc3RPdXRwdXRQcm9maWxlOiBjb2xvclByb2ZpbGVSZWZcbiAgICB9KTtcbiAgICBpbnRlbnRSZWYuZW5kKCk7XG4gICAgdGhpcy5fcm9vdC5kYXRhLk91dHB1dEludGVudHMgPSBbaW50ZW50UmVmXTtcbiAgfSxcbiAgX2dldFBkZmFpZDogZnVuY3Rpb24gX2dldFBkZmFpZCgpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICAgIDxyZGY6RGVzY3JpcHRpb24geG1sbnM6cGRmYWlkPVxcXCJodHRwOi8vd3d3LmFpaW0ub3JnL3BkZmEvbnMvaWQvXFxcIiByZGY6YWJvdXQ9XFxcIlxcXCI+XFxuICAgICAgICAgICAgPHBkZmFpZDpwYXJ0PlwiLmNvbmNhdCh0aGlzLnN1YnNldCwgXCI8L3BkZmFpZDpwYXJ0PlxcbiAgICAgICAgICAgIDxwZGZhaWQ6Y29uZm9ybWFuY2U+XCIpLmNvbmNhdCh0aGlzLnN1YnNldF9jb25mb3JtYW5jZSwgXCI8L3BkZmFpZDpjb25mb3JtYW5jZT5cXG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxcbiAgICAgICAgXCIpO1xuICB9LFxuICBfYWRkUGRmYU1ldGFkYXRhOiBmdW5jdGlvbiBfYWRkUGRmYU1ldGFkYXRhKCkge1xuICAgIHRoaXMuYXBwZW5kWE1MKHRoaXMuX2dldFBkZmFpZCgpKTtcbiAgfVxufTtcblxudmFyIFN1YnNldE1peGluID0ge1xuICBfaW1wb3J0U3Vic2V0OiBmdW5jdGlvbiBfaW1wb3J0U3Vic2V0KHN1YnNldCkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3Vic2V0KTtcbiAgfSxcbiAgaW5pdFN1YnNldDogZnVuY3Rpb24gaW5pdFN1YnNldChvcHRpb25zKSB7XG4gICAgc3dpdGNoIChvcHRpb25zLnN1YnNldCkge1xuICAgICAgY2FzZSAnUERGL0EtMSc6XG4gICAgICBjYXNlICdQREYvQS0xYSc6XG4gICAgICBjYXNlICdQREYvQS0xYic6XG4gICAgICBjYXNlICdQREYvQS0yJzpcbiAgICAgIGNhc2UgJ1BERi9BLTJhJzpcbiAgICAgIGNhc2UgJ1BERi9BLTJiJzpcbiAgICAgIGNhc2UgJ1BERi9BLTMnOlxuICAgICAgY2FzZSAnUERGL0EtM2EnOlxuICAgICAgY2FzZSAnUERGL0EtM2InOlxuICAgICAgICB0aGlzLl9pbXBvcnRTdWJzZXQoUERGQSk7XG5cbiAgICAgICAgdGhpcy5pbml0UERGQShvcHRpb25zLnN1YnNldCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFBERk1ldGFkYXRhID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGTWV0YWRhdGEoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERk1ldGFkYXRhKTtcblxuICAgIHRoaXMuX21ldGFkYXRhID0gXCJcXG4gICAgICAgIDw/eHBhY2tldCBiZWdpbj1cXFwiXFx1RkVGRlxcXCIgaWQ9XFxcIlc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZFxcXCI/PlxcbiAgICAgICAgICAgIDx4OnhtcG1ldGEgeG1sbnM6eD1cXFwiYWRvYmU6bnM6bWV0YS9cXFwiPlxcbiAgICAgICAgICAgICAgICA8cmRmOlJERiB4bWxuczpyZGY9XFxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcXFwiPlxcbiAgICAgICAgXCI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGTWV0YWRhdGEsIFt7XG4gICAga2V5OiBcIl9jbG9zZVRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Nsb3NlVGFncygpIHtcbiAgICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fbWV0YWRhdGEuY29uY2F0KFwiXFxuICAgICAgICAgICAgICAgIDwvcmRmOlJERj5cXG4gICAgICAgICAgICA8L3g6eG1wbWV0YT5cXG4gICAgICAgIDw/eHBhY2tldCBlbmQ9XFxcIndcXFwiPz5cXG4gICAgICAgIFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGVuZCh4bWwpIHtcbiAgICAgIHZhciBuZXdsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdGhpcy5fbWV0YWRhdGEgPSB0aGlzLl9tZXRhZGF0YS5jb25jYXQoeG1sKTtcbiAgICAgIGlmIChuZXdsaW5lKSB0aGlzLl9tZXRhZGF0YSA9IHRoaXMuX21ldGFkYXRhLmNvbmNhdCgnXFxuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFhNTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRYTUwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZW5ndGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5kKCkge1xuICAgICAgdGhpcy5fY2xvc2VUYWdzKCk7XG5cbiAgICAgIHRoaXMuX21ldGFkYXRhID0gdGhpcy5fbWV0YWRhdGEudHJpbSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZNZXRhZGF0YTtcbn0oKTtcblxudmFyIE1ldGFkYXRhTWl4aW4gPSB7XG4gIGluaXRNZXRhZGF0YTogZnVuY3Rpb24gaW5pdE1ldGFkYXRhKCkge1xuICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgUERGTWV0YWRhdGEoKTtcbiAgfSxcbiAgYXBwZW5kWE1MOiBmdW5jdGlvbiBhcHBlbmRYTUwoeG1sKSB7XG4gICAgdmFyIG5ld2xpbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgdGhpcy5tZXRhZGF0YS5hcHBlbmQoeG1sLCBuZXdsaW5lKTtcbiAgfSxcbiAgX2FkZEluZm86IGZ1bmN0aW9uIF9hZGRJbmZvKCkge1xuICAgIHRoaXMuYXBwZW5kWE1MKFwiXFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cXFwiXFxcIiB4bWxuczp4bXA9XFxcImh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9cXFwiPlxcbiAgICAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT5cIi5jb25jYXQodGhpcy5pbmZvLkNyZWF0aW9uRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCcuJylbMF0gKyBcIlpcIiwgXCI8L3htcDpDcmVhdGVEYXRlPlxcbiAgICAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+XCIpLmNvbmNhdCh0aGlzLmluZm8uQ3JlYXRvciwgXCI8L3htcDpDcmVhdG9yVG9vbD5cXG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxcbiAgICAgICAgXCIpKTtcblxuICAgIGlmICh0aGlzLmluZm8uVGl0bGUgfHwgdGhpcy5pbmZvLkF1dGhvciB8fCB0aGlzLmluZm8uU3ViamVjdCkge1xuICAgICAgdGhpcy5hcHBlbmRYTUwoXCJcXG4gICAgICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cXFwiXFxcIiB4bWxuczpkYz1cXFwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cXFwiPlxcbiAgICAgICAgICAgIFwiKTtcblxuICAgICAgaWYgKHRoaXMuaW5mby5UaXRsZSkge1xuICAgICAgICB0aGlzLmFwcGVuZFhNTChcIlxcbiAgICAgICAgICAgICAgICA8ZGM6dGl0bGU+XFxuICAgICAgICAgICAgICAgICAgICA8cmRmOkFsdD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8cmRmOmxpIHhtbDpsYW5nPVxcXCJ4LWRlZmF1bHRcXFwiPlwiLmNvbmNhdCh0aGlzLmluZm8uVGl0bGUsIFwiPC9yZGY6bGk+XFxuICAgICAgICAgICAgICAgICAgICA8L3JkZjpBbHQ+XFxuICAgICAgICAgICAgICAgIDwvZGM6dGl0bGU+XFxuICAgICAgICAgICAgICAgIFwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmluZm8uQXV0aG9yKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kWE1MKFwiXFxuICAgICAgICAgICAgICAgIDxkYzpjcmVhdG9yPlxcbiAgICAgICAgICAgICAgICAgICAgPHJkZjpTZXE+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaT5cIi5jb25jYXQodGhpcy5pbmZvLkF1dGhvciwgXCI8L3JkZjpsaT5cXG4gICAgICAgICAgICAgICAgICAgIDwvcmRmOlNlcT5cXG4gICAgICAgICAgICAgICAgPC9kYzpjcmVhdG9yPlxcbiAgICAgICAgICAgICAgICBcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbmZvLlN1YmplY3QpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRYTUwoXCJcXG4gICAgICAgICAgICAgICAgPGRjOmRlc2NyaXB0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgPHJkZjpBbHQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHJkZjpsaSB4bWw6bGFuZz1cXFwieC1kZWZhdWx0XFxcIj5cIi5jb25jYXQodGhpcy5pbmZvLlN1YmplY3QsIFwiPC9yZGY6bGk+XFxuICAgICAgICAgICAgICAgICAgICA8L3JkZjpBbHQ+XFxuICAgICAgICAgICAgICAgIDwvZGM6ZGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgICAgIFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kWE1MKFwiXFxuICAgICAgICAgICAgPC9yZGY6RGVzY3JpcHRpb24+XFxuICAgICAgICAgICAgXCIpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kWE1MKFwiXFxuICAgICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD1cXFwiXFxcIiB4bWxuczpwZGY9XFxcImh0dHA6Ly9ucy5hZG9iZS5jb20vcGRmLzEuMy9cXFwiPlxcbiAgICAgICAgICAgIDxwZGY6UHJvZHVjZXI+XCIuY29uY2F0KHRoaXMuaW5mby5DcmVhdG9yLCBcIjwvcGRmOlByb2R1Y2VyPlwiKSwgZmFsc2UpO1xuXG4gICAgaWYgKHRoaXMuaW5mby5LZXl3b3Jkcykge1xuICAgICAgdGhpcy5hcHBlbmRYTUwoXCJcXG4gICAgICAgICAgICA8cGRmOktleXdvcmRzPlwiLmNvbmNhdCh0aGlzLmluZm8uS2V5d29yZHMsIFwiPC9wZGY6S2V5d29yZHM+XCIpLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmRYTUwoXCJcXG4gICAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPlxcbiAgICAgICAgXCIpO1xuICB9LFxuICBlbmRNZXRhZGF0YTogZnVuY3Rpb24gZW5kTWV0YWRhdGEoKSB7XG4gICAgdGhpcy5fYWRkSW5mbygpO1xuXG4gICAgdGhpcy5tZXRhZGF0YS5lbmQoKTtcbiAgICAvKlxyXG4gICAgTWV0YWRhdGEgd2FzIGludHJvZHVjZWQgaW4gUERGIDEuNCwgc28gYWRkaW5nIGl0IHRvIDEuMyBcclxuICAgIHdpbGwgbGlrZWx5IG9ubHkgdGFrZSB1cCBtb3JlIHNwYWNlLlxyXG4gICAgKi9cblxuICAgIGlmICh0aGlzLnZlcnNpb24gIT0gMS4zKSB7XG4gICAgICB0aGlzLm1ldGFkYXRhUmVmID0gdGhpcy5yZWYoe1xuICAgICAgICBsZW5ndGg6IHRoaXMubWV0YWRhdGEuZ2V0TGVuZ3RoKCksXG4gICAgICAgIFR5cGU6ICdNZXRhZGF0YScsXG4gICAgICAgIFN1YnR5cGU6ICdYTUwnXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWV0YWRhdGFSZWYuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgIHRoaXMubWV0YWRhdGFSZWYud3JpdGUoQnVmZmVyLmZyb20odGhpcy5tZXRhZGF0YS5nZXRYTUwoKSwgJ3V0Zi04JykpO1xuICAgICAgdGhpcy5tZXRhZGF0YVJlZi5lbmQoKTtcbiAgICAgIHRoaXMuX3Jvb3QuZGF0YS5NZXRhZGF0YSA9IHRoaXMubWV0YWRhdGFSZWY7XG4gICAgfVxuICB9XG59O1xuXG52YXIgUERGRG9jdW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9zdHJlYW0kUmVhZGFibGUpIHtcbiAgX2luaGVyaXRzKFBERkRvY3VtZW50LCBfc3RyZWFtJFJlYWRhYmxlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFBERkRvY3VtZW50KTtcblxuICBmdW5jdGlvbiBQREZEb2N1bWVudCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRG9jdW1lbnQpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICBfdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gUERGIHZlcnNpb25cblxuICAgIHN3aXRjaCAob3B0aW9ucy5wZGZWZXJzaW9uKSB7XG4gICAgICBjYXNlICcxLjQnOlxuICAgICAgICBfdGhpcy52ZXJzaW9uID0gMS40O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnMS41JzpcbiAgICAgICAgX3RoaXMudmVyc2lvbiA9IDEuNTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzEuNic6XG4gICAgICAgIF90aGlzLnZlcnNpb24gPSAxLjY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcxLjcnOlxuICAgICAgY2FzZSAnMS43ZXh0Myc6XG4gICAgICAgIF90aGlzLnZlcnNpb24gPSAxLjc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBfdGhpcy52ZXJzaW9uID0gMS4zO1xuICAgICAgICBicmVhaztcbiAgICB9IC8vIFdoZXRoZXIgc3RyZWFtcyBzaG91bGQgYmUgY29tcHJlc3NlZFxuXG5cbiAgICBfdGhpcy5jb21wcmVzcyA9IF90aGlzLm9wdGlvbnMuY29tcHJlc3MgIT0gbnVsbCA/IF90aGlzLm9wdGlvbnMuY29tcHJlc3MgOiB0cnVlO1xuICAgIF90aGlzLl9wYWdlQnVmZmVyID0gW107XG4gICAgX3RoaXMuX3BhZ2VCdWZmZXJTdGFydCA9IDA7IC8vIFRoZSBQREYgb2JqZWN0IHN0b3JlXG5cbiAgICBfdGhpcy5fb2Zmc2V0cyA9IFtdO1xuICAgIF90aGlzLl93YWl0aW5nID0gMDtcbiAgICBfdGhpcy5fZW5kZWQgPSBmYWxzZTtcbiAgICBfdGhpcy5fb2Zmc2V0ID0gMDtcblxuICAgIHZhciBQYWdlcyA9IF90aGlzLnJlZih7XG4gICAgICBUeXBlOiAnUGFnZXMnLFxuICAgICAgQ291bnQ6IDAsXG4gICAgICBLaWRzOiBbXVxuICAgIH0pO1xuXG4gICAgdmFyIE5hbWVzID0gX3RoaXMucmVmKHtcbiAgICAgIERlc3RzOiBuZXcgUERGTmFtZVRyZWUoKVxuICAgIH0pO1xuXG4gICAgX3RoaXMuX3Jvb3QgPSBfdGhpcy5yZWYoe1xuICAgICAgVHlwZTogJ0NhdGFsb2cnLFxuICAgICAgUGFnZXM6IFBhZ2VzLFxuICAgICAgTmFtZXM6IE5hbWVzXG4gICAgfSk7XG5cbiAgICBpZiAoX3RoaXMub3B0aW9ucy5sYW5nKSB7XG4gICAgICBfdGhpcy5fcm9vdC5kYXRhLkxhbmcgPSBuZXcgU3RyaW5nKF90aGlzLm9wdGlvbnMubGFuZyk7XG4gICAgfSAvLyBUaGUgY3VycmVudCBwYWdlXG5cblxuICAgIF90aGlzLnBhZ2UgPSBudWxsOyAvLyBJbml0aWFsaXplIG1peGluc1xuXG4gICAgX3RoaXMuaW5pdE1ldGFkYXRhKCk7XG5cbiAgICBfdGhpcy5pbml0Q29sb3IoKTtcblxuICAgIF90aGlzLmluaXRWZWN0b3IoKTtcblxuICAgIF90aGlzLmluaXRGb250cyhvcHRpb25zLmZvbnQpO1xuXG4gICAgX3RoaXMuaW5pdFRleHQoKTtcblxuICAgIF90aGlzLmluaXRJbWFnZXMoKTtcblxuICAgIF90aGlzLmluaXRPdXRsaW5lKCk7XG5cbiAgICBfdGhpcy5pbml0TWFya2luZ3Mob3B0aW9ucyk7XG5cbiAgICBfdGhpcy5pbml0U3Vic2V0KG9wdGlvbnMpOyAvLyBJbml0aWFsaXplIHRoZSBtZXRhZGF0YVxuXG5cbiAgICBfdGhpcy5pbmZvID0ge1xuICAgICAgUHJvZHVjZXI6ICdQREZLaXQnLFxuICAgICAgQ3JlYXRvcjogJ1BERktpdCcsXG4gICAgICBDcmVhdGlvbkRhdGU6IG5ldyBEYXRlKClcbiAgICB9O1xuXG4gICAgaWYgKF90aGlzLm9wdGlvbnMuaW5mbykge1xuICAgICAgZm9yICh2YXIga2V5IGluIF90aGlzLm9wdGlvbnMuaW5mbykge1xuICAgICAgICB2YXIgdmFsID0gX3RoaXMub3B0aW9ucy5pbmZvW2tleV07XG4gICAgICAgIF90aGlzLmluZm9ba2V5XSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3RoaXMub3B0aW9ucy5kaXNwbGF5VGl0bGUpIHtcbiAgICAgIF90aGlzLl9yb290LmRhdGEuVmlld2VyUHJlZmVyZW5jZXMgPSBfdGhpcy5yZWYoe1xuICAgICAgICBEaXNwbGF5RG9jVGl0bGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gLy8gR2VuZXJhdGUgZmlsZSBJRFxuXG5cbiAgICBfdGhpcy5faWQgPSBQREZTZWN1cml0eS5nZW5lcmF0ZUZpbGVJRChfdGhpcy5pbmZvKTsgLy8gSW5pdGlhbGl6ZSBzZWN1cml0eSBzZXR0aW5nc1xuXG4gICAgX3RoaXMuX3NlY3VyaXR5ID0gUERGU2VjdXJpdHkuY3JlYXRlKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBvcHRpb25zKTsgLy8gV3JpdGUgdGhlIGhlYWRlclxuICAgIC8vIFBERiB2ZXJzaW9uXG5cbiAgICBfdGhpcy5fd3JpdGUoXCIlUERGLVwiLmNvbmNhdChfdGhpcy52ZXJzaW9uKSk7IC8vIDQgYmluYXJ5IGNoYXJzLCBhcyByZWNvbW1lbmRlZCBieSB0aGUgc3BlY1xuXG5cbiAgICBfdGhpcy5fd3JpdGUoJyVcXHhGRlxceEZGXFx4RkZcXHhGRicpOyAvLyBBZGQgdGhlIGZpcnN0IHBhZ2VcblxuXG4gICAgaWYgKF90aGlzLm9wdGlvbnMuYXV0b0ZpcnN0UGFnZSAhPT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmFkZFBhZ2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRG9jdW1lbnQsIFt7XG4gICAga2V5OiBcImFkZFBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUGFnZShvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB9IC8vIGVuZCB0aGUgY3VycmVudCBwYWdlIGlmIG5lZWRlZFxuXG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1ZmZlclBhZ2VzKSB7XG4gICAgICAgIHRoaXMuZmx1c2hQYWdlcygpO1xuICAgICAgfSAvLyBjcmVhdGUgYSBwYWdlIG9iamVjdFxuXG5cbiAgICAgIHRoaXMucGFnZSA9IG5ldyBQREZQYWdlKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLl9wYWdlQnVmZmVyLnB1c2godGhpcy5wYWdlKTsgLy8gYWRkIHRoZSBwYWdlIHRvIHRoZSBvYmplY3Qgc3RvcmVcblxuXG4gICAgICB2YXIgcGFnZXMgPSB0aGlzLl9yb290LmRhdGEuUGFnZXMuZGF0YTtcbiAgICAgIHBhZ2VzLktpZHMucHVzaCh0aGlzLnBhZ2UuZGljdGlvbmFyeSk7XG4gICAgICBwYWdlcy5Db3VudCsrOyAvLyByZXNldCB4IGFuZCB5IGNvb3JkaW5hdGVzXG5cbiAgICAgIHRoaXMueCA9IHRoaXMucGFnZS5tYXJnaW5zLmxlZnQ7XG4gICAgICB0aGlzLnkgPSB0aGlzLnBhZ2UubWFyZ2lucy50b3A7IC8vIGZsaXAgUERGIGNvb3JkaW5hdGUgc3lzdGVtIHNvIHRoYXQgdGhlIG9yaWdpbiBpcyBpblxuICAgICAgLy8gdGhlIHRvcCBsZWZ0IHJhdGhlciB0aGFuIHRoZSBib3R0b20gbGVmdFxuXG4gICAgICB0aGlzLl9jdG0gPSBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgICB0aGlzLnRyYW5zZm9ybSgxLCAwLCAwLCAtMSwgMCwgdGhpcy5wYWdlLmhlaWdodCk7XG4gICAgICB0aGlzLmVtaXQoJ3BhZ2VBZGRlZCcpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRpbnVlT25OZXdQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRpbnVlT25OZXdQYWdlKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYWdlTWFya2luZ3MgPSB0aGlzLmVuZFBhZ2VNYXJraW5ncyh0aGlzLnBhZ2UpO1xuICAgICAgdGhpcy5hZGRQYWdlKG9wdGlvbnMpO1xuICAgICAgdGhpcy5pbml0UGFnZU1hcmtpbmdzKHBhZ2VNYXJraW5ncyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYnVmZmVyZWRQYWdlUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVyZWRQYWdlUmFuZ2UoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogdGhpcy5fcGFnZUJ1ZmZlclN0YXJ0LFxuICAgICAgICBjb3VudDogdGhpcy5fcGFnZUJ1ZmZlci5sZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN3aXRjaFRvUGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2l0Y2hUb1BhZ2Uobikge1xuICAgICAgdmFyIHBhZ2U7XG5cbiAgICAgIGlmICghKHBhZ2UgPSB0aGlzLl9wYWdlQnVmZmVyW24gLSB0aGlzLl9wYWdlQnVmZmVyU3RhcnRdKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzd2l0Y2hUb1BhZ2UoXCIuY29uY2F0KG4sIFwiKSBvdXQgb2YgYm91bmRzLCBjdXJyZW50IGJ1ZmZlciBjb3ZlcnMgcGFnZXMgXCIpLmNvbmNhdCh0aGlzLl9wYWdlQnVmZmVyU3RhcnQsIFwiIHRvIFwiKS5jb25jYXQodGhpcy5fcGFnZUJ1ZmZlclN0YXJ0ICsgdGhpcy5fcGFnZUJ1ZmZlci5sZW5ndGggLSAxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmbHVzaFBhZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZsdXNoUGFnZXMoKSB7XG4gICAgICAvLyB0aGlzIGxvY2FsIHZhcmlhYmxlIGV4aXN0cyBzbyB3ZSdyZSBmdXR1cmUtcHJvb2YgYWdhaW5zdFxuICAgICAgLy8gcmVlbnRyYW50IGNhbGxzIHRvIGZsdXNoUGFnZXMuXG4gICAgICB2YXIgcGFnZXMgPSB0aGlzLl9wYWdlQnVmZmVyO1xuICAgICAgdGhpcy5fcGFnZUJ1ZmZlciA9IFtdO1xuICAgICAgdGhpcy5fcGFnZUJ1ZmZlclN0YXJ0ICs9IHBhZ2VzLmxlbmd0aDtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBhZ2VzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcGFnZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHRoaXMuZW5kUGFnZU1hcmtpbmdzKHBhZ2UpO1xuICAgICAgICAgIHBhZ2UuZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTmFtZWREZXN0aW5hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROYW1lZERlc3RpbmF0aW9uKG5hbWUpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcmdzID0gWydYWVonLCBudWxsLCBudWxsLCBudWxsXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3NbMF0gPT09ICdYWVonICYmIGFyZ3NbMl0gIT09IG51bGwpIHtcbiAgICAgICAgYXJnc1syXSA9IHRoaXMucGFnZS5oZWlnaHQgLSBhcmdzWzJdO1xuICAgICAgfVxuXG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5wYWdlLmRpY3Rpb25hcnkpO1xuXG4gICAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5EZXN0cy5hZGQobmFtZSwgYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE5hbWVkRW1iZWRkZWRGaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5hbWVkRW1iZWRkZWRGaWxlKG5hbWUsIHJlZikge1xuICAgICAgaWYgKCF0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5FbWJlZGRlZEZpbGVzKSB7XG4gICAgICAgIC8vIGRpc2FibGluZyAvTGltaXRzIGZvciB0aGlzIHRyZWUgZml4ZXMgYXR0YWNobWVudHMgbm90IHNob3dpbmcgaW4gQWRvYmUgUmVhZGVyXG4gICAgICAgIHRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5kYXRhLkVtYmVkZGVkRmlsZXMgPSBuZXcgUERGTmFtZVRyZWUoe1xuICAgICAgICAgIGxpbWl0czogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIGFkZCBmaWxlc3BlYyB0byBFbWJlZGRlZEZpbGVzXG5cblxuICAgICAgdGhpcy5fcm9vdC5kYXRhLk5hbWVzLmRhdGEuRW1iZWRkZWRGaWxlcy5hZGQobmFtZSwgcmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTmFtZWRKYXZhU2NyaXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5hbWVkSmF2YVNjcmlwdChuYW1lLCBqcykge1xuICAgICAgaWYgKCF0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5KYXZhU2NyaXB0KSB7XG4gICAgICAgIHRoaXMuX3Jvb3QuZGF0YS5OYW1lcy5kYXRhLkphdmFTY3JpcHQgPSBuZXcgUERGTmFtZVRyZWUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIEpTOiBuZXcgU3RyaW5nKGpzKSxcbiAgICAgICAgUzogJ0phdmFTY3JpcHQnXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZGF0YS5KYXZhU2NyaXB0LmFkZChuYW1lLCBkYXRhKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVmXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZihkYXRhKSB7XG4gICAgICB2YXIgcmVmID0gbmV3IFBERlJlZmVyZW5jZSh0aGlzLCB0aGlzLl9vZmZzZXRzLmxlbmd0aCArIDEsIGRhdGEpO1xuXG4gICAgICB0aGlzLl9vZmZzZXRzLnB1c2gobnVsbCk7IC8vIHBsYWNlaG9sZGVyIGZvciB0aGlzIG9iamVjdCdzIG9mZnNldCBvbmNlIGl0IGlzIGZpbmFsaXplZFxuXG5cbiAgICAgIHRoaXMuX3dhaXRpbmcrKztcbiAgICAgIHJldHVybiByZWY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkKCkge30gLy8gZG8gbm90aGluZywgYnV0IHRoaXMgbWV0aG9kIGlzIHJlcXVpcmVkIGJ5IG5vZGVcblxuICB9LCB7XG4gICAga2V5OiBcIl93cml0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd3JpdGUoZGF0YSkge1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEgKyAnXFxuJywgJ2JpbmFyeScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENvbnRlbnQoZGF0YSkge1xuICAgICAgdGhpcy5wYWdlLndyaXRlKGRhdGEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZWZFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZkVuZChyZWYpIHtcbiAgICAgIHRoaXMuX29mZnNldHNbcmVmLmlkIC0gMV0gPSByZWYub2Zmc2V0O1xuXG4gICAgICBpZiAoLS10aGlzLl93YWl0aW5nID09PSAwICYmIHRoaXMuX2VuZGVkKSB7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndyaXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlKGZpbGVuYW1lLCBmbikge1xuICAgICAgLy8gcHJpbnQgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggYSBzdGFja3RyYWNlXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFwiUERGRG9jdW1lbnQjd3JpdGUgaXMgZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFBERktpdC4gUGxlYXNlIHBpcGUgdGhlIGRvY3VtZW50IGludG8gYSBOb2RlIHN0cmVhbS5cIik7XG4gICAgICBjb25zb2xlLndhcm4oZXJyLnN0YWNrKTtcbiAgICAgIHRoaXMucGlwZShmcy5jcmVhdGVXcml0ZVN0cmVhbShmaWxlbmFtZSkpO1xuICAgICAgdGhpcy5lbmQoKTtcbiAgICAgIHJldHVybiB0aGlzLm9uY2UoJ2VuZCcsIGZuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIHRoaXMuZmx1c2hQYWdlcygpO1xuICAgICAgdGhpcy5faW5mbyA9IHRoaXMucmVmKCk7XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluZm8pIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuaW5mb1trZXldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhbCA9IG5ldyBTdHJpbmcodmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMucmVmKHZhbCk7XG4gICAgICAgIGVudHJ5LmVuZCgpO1xuICAgICAgICB0aGlzLl9pbmZvLmRhdGFba2V5XSA9IGVudHJ5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbmZvLmVuZCgpO1xuXG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMuX2ZvbnRGYW1pbGllcykge1xuICAgICAgICB2YXIgZm9udCA9IHRoaXMuX2ZvbnRGYW1pbGllc1tuYW1lXTtcbiAgICAgICAgZm9udC5maW5hbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVuZE91dGxpbmUoKTtcbiAgICAgIHRoaXMuZW5kTWFya2luZ3MoKTtcblxuICAgICAgaWYgKHRoaXMuc3Vic2V0KSB7XG4gICAgICAgIHRoaXMuZW5kU3Vic2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW5kTWV0YWRhdGEoKTtcblxuICAgICAgdGhpcy5fcm9vdC5lbmQoKTtcblxuICAgICAgdGhpcy5fcm9vdC5kYXRhLlBhZ2VzLmVuZCgpO1xuXG4gICAgICB0aGlzLl9yb290LmRhdGEuTmFtZXMuZW5kKCk7XG5cbiAgICAgIHRoaXMuZW5kQWNyb0Zvcm0oKTtcblxuICAgICAgaWYgKHRoaXMuX3Jvb3QuZGF0YS5WaWV3ZXJQcmVmZXJlbmNlcykge1xuICAgICAgICB0aGlzLl9yb290LmRhdGEuVmlld2VyUHJlZmVyZW5jZXMuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZWN1cml0eSkge1xuICAgICAgICB0aGlzLl9zZWN1cml0eS5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3dhaXRpbmcgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZmluYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmFsaXplKCkge1xuICAgICAgLy8gZ2VuZXJhdGUgeHJlZlxuICAgICAgdmFyIHhSZWZPZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG5cbiAgICAgIHRoaXMuX3dyaXRlKCd4cmVmJyk7XG5cbiAgICAgIHRoaXMuX3dyaXRlKFwiMCBcIi5jb25jYXQodGhpcy5fb2Zmc2V0cy5sZW5ndGggKyAxKSk7XG5cbiAgICAgIHRoaXMuX3dyaXRlKCcwMDAwMDAwMDAwIDY1NTM1IGYgJyk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fb2Zmc2V0cyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBvZmZzZXQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgb2Zmc2V0ID0gXCIwMDAwMDAwMDAwXCIuY29uY2F0KG9mZnNldCkuc2xpY2UoLTEwKTtcblxuICAgICAgICAgIHRoaXMuX3dyaXRlKG9mZnNldCArICcgMDAwMDAgbiAnKTtcbiAgICAgICAgfSAvLyB0cmFpbGVyXG5cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhaWxlciA9IHtcbiAgICAgICAgU2l6ZTogdGhpcy5fb2Zmc2V0cy5sZW5ndGggKyAxLFxuICAgICAgICBSb290OiB0aGlzLl9yb290LFxuICAgICAgICBJbmZvOiB0aGlzLl9pbmZvLFxuICAgICAgICBJRDogW3RoaXMuX2lkLCB0aGlzLl9pZF1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9zZWN1cml0eSkge1xuICAgICAgICB0cmFpbGVyLkVuY3J5cHQgPSB0aGlzLl9zZWN1cml0eS5kaWN0aW9uYXJ5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl93cml0ZSgndHJhaWxlcicpO1xuXG4gICAgICB0aGlzLl93cml0ZShQREZPYmplY3QuY29udmVydCh0cmFpbGVyKSk7XG5cbiAgICAgIHRoaXMuX3dyaXRlKCdzdGFydHhyZWYnKTtcblxuICAgICAgdGhpcy5fd3JpdGUoXCJcIi5jb25jYXQoeFJlZk9mZnNldCkpO1xuXG4gICAgICB0aGlzLl93cml0ZSgnJSVFT0YnKTsgLy8gZW5kIHRoZSBzdHJlYW1cblxuXG4gICAgICByZXR1cm4gdGhpcy5wdXNoKG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnW29iamVjdCBQREZEb2N1bWVudF0nO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZEb2N1bWVudDtcbn0oc3RyZWFtLlJlYWRhYmxlKTtcblxudmFyIG1peGluID0gZnVuY3Rpb24gbWl4aW4obWV0aG9kcykge1xuICBPYmplY3QuYXNzaWduKFBERkRvY3VtZW50LnByb3RvdHlwZSwgbWV0aG9kcyk7XG59O1xuXG5taXhpbihNZXRhZGF0YU1peGluKTtcbm1peGluKENvbG9yTWl4aW4pO1xubWl4aW4oVmVjdG9yTWl4aW4pO1xubWl4aW4oRm9udHNNaXhpbik7XG5taXhpbihUZXh0TWl4aW4pO1xubWl4aW4oSW1hZ2VzTWl4aW4pO1xubWl4aW4oQW5ub3RhdGlvbnNNaXhpbik7XG5taXhpbihPdXRsaW5lTWl4aW4pO1xubWl4aW4oTWFya2luZ3NNaXhpbik7XG5taXhpbihBY3JvRm9ybU1peGluKTtcbm1peGluKEF0dGFjaG1lbnRzTWl4aW4pO1xubWl4aW4oU3Vic2V0TWl4aW4pO1xuUERGRG9jdW1lbnQuTGluZVdyYXBwZXIgPSBMaW5lV3JhcHBlcjtcblxuZXhwb3J0IGRlZmF1bHQgUERGRG9jdW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGZraXQuZXM1LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pdfkit/js/pdfkit.es5.js\n");

/***/ })

};
;